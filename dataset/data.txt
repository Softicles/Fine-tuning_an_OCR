crop_img/assembly_hw_226_crop_0.jpg	left char R1
crop_img/assembly_hw_226_crop_1.jpg	right char
crop_img/assembly_hw_226_crop_2.jpg	bft Addr
crop_img/assembly_hw_226_crop_3.jpg	Right Addr
crop_img/assembly_hw_226_crop_4.jpg	Stop when bft ≥ right
crop_img/assembly_hw_226_crop_5.jpg	Find Minimum Index :
crop_img/assembly_hw_226_crop_6.jpg	(initially (s8)
crop_img/assembly_hw_226_crop_7.jpg	ptr to min element: Ro
crop_img/assembly_hw_226_crop_8.jpg	min element's value : R1
crop_img/assembly_hw_226_crop_9.jpg	ptr to each element : Ra
crop_img/assembly_hw_226_crop_10.jpg	6
crop_img/assembly_hw_226_crop_11.jpg	1
crop_img/assembly_hw_226_crop_12.jpg	乙
crop_img/assembly_hw_226_crop_13.jpg	3
crop_img/assembly_hw_226_crop_14.jpg	4
crop_img/assembly_hw_226_crop_15.jpg	each element's value : R 3
crop_img/assembly_hw_226_crop_16.jpg	-addr of final element R4
crop_img/assembly_hw_226_crop_17.jpg	b
crop_img/assembly_hw_226_crop_18.jpg	a
crop_img/assembly_hw_226_crop_19.jpg	) caesar cipher ;
crop_img/assembly_hw_226_crop_20.jpg	mod-return
crop_img/assembly_hw_226_crop_21.jpg	string
crop_img/assembly_hw_226_crop_22.jpg	caesar:
crop_img/assembly_hw_226_crop_23.jpg	Shift
crop_img/assembly_hw_226_crop_24.jpg	find length
crop_img/assembly_hw_226_crop_25.jpg	get arguments for mod and mod-return
crop_img/assembly_hw_226_crop_26.jpg	(push a) push b)
crop_img/assembly_hw_226_crop_27.jpg	mod :
crop_img/assembly_hw_226_crop_28.jpg	。
crop_img/assembly_hw_226_crop_29.jpg	R4:=a (pop)
crop_img/assembly_hw_227_crop_0.jpg	negate stop-addr
crop_img/assembly_hw_227_crop_1.jpg	if(
crop_img/assembly_hw_227_crop_2.jpg	R4+R5
crop_img/assembly_hw_227_crop_3.jpg	HALT
crop_img/assembly_hw_227_crop_4.jpg	while R2+Ra !=0
crop_img/assembly_hw_227_crop_5.jpg	ret
crop_img/assembly_hw_227_crop_6.jpg	LDR R2,R3,#0
crop_img/assembly_hw_227_crop_7.jpg	R1+
crop_img/assembly_hw_227_crop_8.jpg	R34
crop_img/assembly_hw_227_crop_9.jpg	R2=0
crop_img/assembly_hw_227_crop_10.jpg	STR RB,R2
crop_img/assembly_hw_227_crop_11.jpg	JML RU
crop_img/assembly_hw_227_crop_12.jpg	-R3
crop_img/assembly_hw_227_crop_13.jpg	-R4
crop_img/assembly_hw_227_crop_14.jpg	.) merge sort
crop_img/assembly_hw_227_crop_15.jpg	MERGESORT(ar, buf, rt, end)
crop_img/avl_hw_179_crop_0.jpg	.)add():
crop_img/avl_hw_179_crop_1.jpg	P
crop_img/avl_hw_179_crop_2.jpg	6
crop_img/avl_hw_179_crop_3.jpg	①
crop_img/avl_hw_179_crop_4.jpg	BST. Add ( )
crop_img/avl_hw_179_crop_5.jpg	2
crop_img/avl_hw_179_crop_6.jpg	Update height (from newly added node→ root)
crop_img/avl_hw_179_crop_7.jpg	③
crop_img/avl_hw_179_crop_8.jpg	Update BF
crop_img/avl_hw_179_crop_9.jpg	④
crop_img/avl_hw_179_crop_10.jpg	Fix unbalanced node
crop_img/avl_hw_179_crop_11.jpg	Fix unbalanced node
crop_img/avl_hw_179_crop_12.jpg	a.getBF()=2&&a.getleft().getBF()=1:
crop_img/avl_hw_179_crop_13.jpg	B
crop_img/avl_hw_179_crop_14.jpg	A
crop_img/avl_hw_179_crop_15.jpg	notR
crop_img/avl_hw_179_crop_16.jpg	A
crop_img/avl_hw_179_crop_17.jpg	β
crop_img/avl_hw_179_crop_18.jpg	0
crop_img/avl_hw_179_crop_19.jpg	4
crop_img/avl_hw_179_crop_20.jpg	4
crop_img/avl_hw_179_crop_21.jpg	C
crop_img/avl_hw_179_crop_22.jpg	2
crop_img/avl_hw_179_crop_23.jpg	S
crop_img/avl_hw_179_crop_24.jpg	2
crop_img/avl_hw_179_crop_25.jpg	o
crop_img/avl_hw_179_crop_26.jpg	oT
crop_img/avl_hw_179_crop_27.jpg	if curr.getBF()=-a && left child.getBF()=-1:
crop_img/avl_hw_179_crop_28.jpg	B
crop_img/avl_hw_179_crop_29.jpg	4
crop_img/avl_hw_179_crop_30.jpg	not L
crop_img/avl_hw_179_crop_31.jpg	O
crop_img/avl_hw_179_crop_32.jpg	C
crop_img/avl_hw_179_crop_33.jpg	B
crop_img/avl_hw_179_crop_34.jpg	A
crop_img/avl_hw_179_crop_35.jpg	→
crop_img/avl_hw_179_crop_36.jpg	4
crop_img/avl_hw_179_crop_37.jpg	0
crop_img/avl_hw_179_crop_38.jpg	6
crop_img/avl_hw_179_crop_39.jpg	8
crop_img/avl_hw_179_crop_40.jpg	3
crop_img/avl_hw_179_crop_41.jpg	6
crop_img/avl_hw_179_crop_42.jpg	0
crop_img/avl_hw_179_crop_43.jpg	3
crop_img/avl_hw_179_crop_44.jpg	4
crop_img/c_programming_hw_review_217_crop_0.jpg	HW7, part(practice dynamic memory allocation)
crop_img/c_programming_hw_review_217_crop_1.jpg	) logic error in is name-unique ():
crop_img/c_programming_hw_review_217_crop_2.jpg	while(my-strncmp(*(player+count))->name,name)
crop_img/c_programming_hw_review_217_crop_3.jpg	&& count < num-player){
crop_img/c_programming_hw_review_217_crop_4.jpg	count ++;
crop_img/c_programming_hw_review_217_crop_5.jpg	3
crop_img/c_programming_hw_review_217_crop_6.jpg	At the last player if my-strncmp count is
crop_img/c_programming_hw_review_217_crop_7.jpg	out of bounds, which will make my-strncmp() crash
crop_img/c_programming_hw_review_217_crop_8.jpg	at the next iteration
crop_img/c_programming_hw_review_217_crop_9.jpg	 Cannot free() on reallocate() const ptr
crop_img/c_programming_hw_review_217_crop_10.jpg	) cannot initialize a ptr with i 
crop_img/c_programming_hw_review_217_crop_11.jpg	) error to use realloc():
crop_img/c_programming_hw_review_217_crop_12.jpg	① Modify the original ptr → correct version (not efficient
crop_img/c_programming_hw_review_217_crop_13.jpg	for memory but will be dealt with using realloc() later)
crop_img/c_programming_hw_review_217_crop_14.jpg	realloc() to new location with efficient storage in terms of
crop_img/c_programming_hw_review_217_crop_15.jpg	2
crop_img/c_programming_hw_review_217_crop_16.jpg	memory
crop_img/c_programming_hw_review_217_crop_17.jpg	)
crop_img/c_programming_hw_review_217_crop_18.jpg	add-to-addn-list:
crop_img/c_programming_hw_review_217_crop_19.jpg	. When add to front, re assign head using
crop_img/c_programming_hw_review_217_crop_20.jpg	addn-list = block
crop_img/c_programming_hw_review_217_crop_21.jpg	seen as
crop_img/c_programming_hw_review_217_crop_22.jpg	head
crop_img/computer_organization_exam_note_7_crop_0.jpg	1's complement : Positive nums → Same as 2's complement
crop_img/computer_organization_exam_note_7_crop_1.jpg	Negative nums → Flip all bits
crop_img/computer_organization_exam_note_7_crop_2.jpg	n-bit 1's comp range：[-(2^n-1), 2^n-1]
crop_img/computer_organization_exam_note_7_crop_3.jpg	overflow
crop_img/computer_organization_exam_note_7_crop_4.jpg	.For signed magnitude: it is a count of the digit
crop_img/computer_organization_exam_note_7_crop_5.jpg	. For 1's comp : a sum too large becomes negative
crop_img/computer_organization_exam_note_7_crop_6.jpg	a sum too small
crop_img/computer_organization_exam_note_7_crop_7.jpg	positive
crop_img/computer_organization_exam_note_7_crop_8.jpg	 Fractional Binary Number :
crop_img/computer_organization_exam_note_7_crop_9.jpg	￥-1
crop_img/computer_organization_exam_note_7_crop_10.jpg	1.M: Ex：1.0101=1*2^0+0*2^-1+1*2^-2+0*2^-3+1*2^-4
crop_img/computer_organization_exam_note_7_crop_11.jpg	*
crop_img/computer_organization_exam_note_7_crop_12.jpg	-4
crop_img/computer_organization_exam_note_7_crop_13.jpg	Mantissa (M)
crop_img/computer_organization_exam_note_7_crop_14.jpg	IEEE-754: Expand the range of 1.M) use 32 bits
crop_img/computer_organization_exam_note_7_crop_15.jpg	E-127
crop_img/computer_organization_exam_note_7_crop_16.jpg	. Rule: (-1)
crop_img/computer_organization_exam_note_7_crop_17.jpg	*
crop_img/computer_organization_exam_note_7_crop_18.jpg	*
crop_img/computer_organization_exam_note_7_crop_19.jpg	1.M
crop_img/computer_organization_exam_note_7_crop_20.jpg	8 bits
crop_img/computer_organization_exam_note_7_crop_21.jpg	23 bits
crop_img/computer_organization_exam_note_7_crop_22.jpg	1 bit
crop_img/computer_organization_exam_note_7_crop_23.jpg	. Drawbacks : big value sacrifices precision because big value
crop_img/computer_organization_exam_note_7_crop_24.jpg	means E large → shifting the floating point to the right
crop_img/computer_organization_exam_note_7_crop_25.jpg	comparing diff nums:
crop_img/computer_organization_exam_note_7_crop_26.jpg	. Positive > Negative
crop_img/computer_organization_exam_note_7_crop_27.jpg	If both positive compare from left → right, which has
crop_img/computer_organization_exam_note_7_crop_28.jpg	larger bits first is larger
crop_img/computer_organization_exam_note_7_crop_29.jpg	. If both negative,
crop_img/computer_organization_exam_note_7_crop_30.jpg	smaller
crop_img/computer_organization_exam_note_8_crop_0.jpg	) Bitwise operator:
crop_img/computer_organization_exam_note_8_crop_1.jpg	.AND: AND every bit between A and B, denoted as A & B
crop_img/computer_organization_exam_note_8_crop_2.jpg	.OR : OR every bit between A and B, denoted as A | B
crop_img/computer_organization_exam_note_8_crop_3.jpg	.NOT : Flip every bit of A, denoted as ~A or A (not for computer)
crop_img/computer_organization_exam_note_8_crop_4.jpg	. XOR : XOR
crop_img/computer_organization_exam_note_8_crop_5.jpg	between A and B, denoted as A ^ B
crop_img/computer_organization_exam_note_8_crop_6.jpg	.NAND : A NAND B is denoted as ~(A & B)
crop_img/computer_organization_exam_note_8_crop_7.jpg	. NOR : A NOR B is denoted as ~(A | B)
crop_img/computer_organization_exam_note_8_crop_8.jpg	left shift : shift all bits of A to the left by decimal places
crop_img/computer_organization_exam_note_8_crop_9.jpg	the gap created filled by 0, denoted as A << B
crop_img/computer_organization_exam_note_8_crop_10.jpg	. Right shift: shift all bits of A to the right by B
crop_img/computer_organization_exam_note_8_crop_11.jpg	the gap created filled by the leading digit, denoted as A >> B
crop_img/computer_organization_exam_note_8_crop_12.jpg	 Manipulating bit using bool funcs:
crop_img/computer_organization_exam_note_8_crop_13.jpg	. CLEAR : zero out a bit → use AND with 0 at the same place
crop_img/computer_organization_exam_note_8_crop_14.jpg	. SET : make a bit become 1 → use OR with 1
crop_img/computer_organization_exam_note_8_crop_15.jpg	.TOGGLE: flip a bit → use XOR with 1
crop_img/computer_organization_exam_note_8_crop_16.jpg	m
crop_img/computer_organization_exam_note_8_crop_17.jpg	ASCII: Binary can be used to represent char, by assign a char with
crop_img/computer_organization_exam_note_8_crop_18.jpg	a binary num
crop_img/computer_organization_exam_note_8_crop_19.jpg	uppercase → lowercase : SET bit 5
crop_img/computer_organization_exam_note_8_crop_20.jpg	lowercase → uppercase : CLEAR bit 5
crop_img/computer_organization_exam_note_8_crop_21.jpg	) Transistor: the bitwise operators can be encoded by circuits by
crop_img/computer_organization_exam_note_8_crop_22.jpg	using transistor
crop_img/computer_organization_exam_note_9_crop_0.jpg	1→A
crop_img/computer_organization_exam_note_9_crop_1.jpg	0→B
crop_img/computer_organization_exam_note_9_crop_2.jpg	.
crop_img/computer_organization_exam_note_9_crop_3.jpg	. NAND gate:
crop_img/computer_organization_exam_note_10_crop_0.jpg	1
crop_img/computer_organization_exam_note_10_crop_1.jpg	C→1
crop_img/computer_organization_exam_note_10_crop_2.jpg	B—↓
crop_img/computer_organization_exam_note_10_crop_3.jpg	1
crop_img/computer_organization_exam_note_10_crop_4.jpg	-
crop_img/computer_organization_exam_note_10_crop_5.jpg	1
crop_img/computer_organization_exam_note_10_crop_6.jpg	1
crop_img/computer_organization_exam_note_10_crop_7.jpg	1
crop_img/computer_organization_exam_note_10_crop_8.jpg	1
crop_img/computer_organization_exam_note_10_crop_9.jpg	1
crop_img/computer_organization_exam_note_10_crop_10.jpg	1
crop_img/computer_organization_exam_note_10_crop_11.jpg	1
crop_img/computer_organization_exam_note_10_crop_12.jpg	NAND
crop_img/computer_organization_exam_note_10_crop_13.jpg	Note : Don't connect, N-type
crop_img/computer_organization_exam_note_10_crop_14.jpg	transistor to power
crop_img/computer_organization_exam_note_10_crop_15.jpg	P-type
crop_img/computer_organization_exam_note_10_crop_16.jpg	ground
crop_img/computer_organization_exam_note_10_crop_17.jpg	Because there will be floating voltage across the transistor
crop_img/computer_organization_exam_note_10_crop_18.jpg	) Combinational logic circuits: output depends only on the inputs
crop_img/computer_organization_exam_note_10_crop_19.jpg	. Decoder: Output has one bit 1 and the rest are 0 represent the chosen
crop_img/computer_organization_exam_note_10_crop_20.jpg	combination of value of the input bits
crop_img/computer_organization_exam_note_10_crop_21.jpg	. n-bit input
crop_img/computer_organization_exam_note_10_crop_22.jpg	. a-bit output
crop_img/computer_organization_exam_note_10_crop_23.jpg	A
crop_img/computer_organization_exam_note_10_crop_24.jpg	B
crop_img/computer_organization_exam_note_10_crop_25.jpg	A
crop_img/computer_organization_exam_note_10_crop_26.jpg	B
crop_img/computer_organization_exam_note_10_crop_27.jpg	output
crop_img/computer_organization_exam_note_10_crop_28.jpg	Inverter
crop_img/computer_organization_exam_note_10_crop_29.jpg	denote as:
crop_img/computer_organization_exam_note_10_crop_30.jpg	$Q_{}B
crop_img/computer_organization_exam_note_10_crop_31.jpg	$Q_{1}AB
crop_img/computer_organization_exam_note_10_crop_32.jpg	Binary Inputs
crop_img/computer_organization_exam_note_10_crop_33.jpg	AND Gates
crop_img/computer_organization_exam_note_10_crop_34.jpg	Input
crop_img/computer_organization_exam_note_10_crop_35.jpg	Q{2}B
crop_img/computer_organization_exam_note_10_crop_36.jpg	B
crop_img/computer_organization_exam_note_10_crop_37.jpg	Q_3}=  AB
crop_img/computer_organization_exam_note_10_crop_38.jpg	Data Lines
crop_img/computer_organization_exam_note_11_crop_0.jpg	• Mux : select one of the inputs to be the output
crop_img/computer_organization_exam_note_11_crop_1.jpg	. n input lines ( inverters)
crop_img/computer_organization_exam_note_11_crop_2.jpg	.2 inputs to choose which to output
crop_img/computer_organization_exam_note_11_crop_3.jpg	A
crop_img/computer_organization_exam_note_11_crop_4.jpg	B
crop_img/computer_organization_exam_note_11_crop_5.jpg	C。
crop_img/computer_organization_exam_note_11_crop_6.jpg	n input lines
crop_img/computer_organization_exam_note_11_crop_7.jpg	Inverters
crop_img/computer_organization_exam_note_11_crop_8.jpg	denote as:
crop_img/computer_organization_exam_note_11_crop_9.jpg	2
crop_img/computer_organization_exam_note_11_crop_10.jpg	S
crop_img/computer_organization_exam_note_11_crop_11.jpg	ybjieshou@easmoney.com
crop_img/computer_organization_exam_note_11_crop_12.jpg	a
crop_img/computer_organization_exam_note_11_crop_13.jpg	b
crop_img/computer_organization_exam_note_11_crop_14.jpg	"AND" gate
crop_img/computer_organization_exam_note_11_crop_15.jpg	0
crop_img/computer_organization_exam_note_11_crop_16.jpg	“OR" gate
crop_img/computer_organization_exam_note_11_crop_17.jpg	B
crop_img/computer_organization_exam_note_11_crop_18.jpg	O
crop_img/computer_organization_exam_note_11_crop_19.jpg	co
crop_img/computer_organization_exam_note_11_crop_20.jpg	D
crop_img/computer_organization_exam_note_11_crop_21.jpg	One Bit Adder : for form A tB where A and B are 1-bit number
crop_img/computer_organization_exam_note_11_crop_22.jpg	· Three 1-bit inputs : A,B, and the carry-in
crop_img/computer_organization_exam_note_11_crop_23.jpg	.Two 1-bit outputs : output bit and the carry out
crop_img/computer_organization_exam_note_11_crop_24.jpg	Carry in
crop_img/computer_organization_exam_note_11_crop_25.jpg	Denoted as:
crop_img/computer_organization_exam_note_11_crop_26.jpg	A
crop_img/computer_organization_exam_note_11_crop_27.jpg	out
crop_img/computer_organization_exam_note_11_crop_28.jpg	B
crop_img/computer_organization_exam_note_11_crop_29.jpg	S
crop_img/computer_organization_exam_note_11_crop_30.jpg	carry out
crop_img/computer_organization_exam_note_11_crop_31.jpg	日
crop_img/computer_organization_exam_note_11_crop_32.jpg	Cin
crop_img/computer_organization_exam_note_11_crop_33.jpg	Cout
crop_img/computer_organization_exam_note_11_crop_34.jpg	. N-bit adder : Combine N one-bit adders, let the carry out
crop_img/computer_organization_exam_note_11_crop_35.jpg	of the previous place be the carry-in of the current place
crop_img/computer_organization_exam_note_11_crop_36.jpg	Boolean algebra : Some useful equations
crop_img/computer_organization_exam_note_12_crop_0.jpg	A+ AB =A
crop_img/computer_organization_exam_note_12_crop_1.jpg	.A +AB=A+B
crop_img/computer_organization_exam_note_12_crop_2.jpg	.（A+B)(A+C)=A+BC
crop_img/computer_organization_exam_note_12_crop_3.jpg	) From Truth table to Circuit : choose the rows that has output 1
crop_img/computer_organization_exam_note_12_crop_4.jpg	. Each AND gate represents one row of the truth table
crop_img/computer_organization_exam_note_12_crop_5.jpg	OR all the outputs of the AND gates
crop_img/computer_organization_exam_note_12_crop_6.jpg	)k-map : A neat way to encode the Truth Table
crop_img/computer_organization_exam_note_12_crop_7.jpg	. Valid grey code : One entity changes from one state to the next
crop_img/computer_organization_exam_note_12_crop_8.jpg	(even from the last state to the 1st stage)
crop_img/computer_organization_exam_note_12_crop_9.jpg	. Get the boolean expression from k-map:
crop_img/computer_organization_exam_note_12_crop_10.jpg	① Group the 1s on the table in group of a (n even)
crop_img/computer_organization_exam_note_12_crop_11.jpg	2 Add the boolean expressions of all the groups together
crop_img/computer_organization_exam_note_12_crop_12.jpg	Note: “x is also counted as
crop_img/computer_organization_exam_note_12_crop_13.jpg	.) sequential logic circuit: Output depends on both current input and
crop_img/computer_organization_exam_note_12_crop_14.jpg	stored elements (in the past)
crop_img/computer_organization_exam_note_12_crop_15.jpg	) RS Latch : When both R and S are 1, one change doesn't affect
crop_img/computer_organization_exam_note_12_crop_16.jpg	the output
crop_img/computer_organization_exam_note_12_crop_17.jpg	It's possible that when R and S are both 1
crop_img/computer_organization_exam_note_12_crop_18.jpg	R
crop_img/computer_organization_exam_note_12_crop_19.jpg	1
crop_img/computer_organization_exam_note_12_crop_20.jpg	0
crop_img/computer_organization_exam_note_12_crop_21.jpg	output is U=1,D=0 or U=0,D=1
crop_img/computer_organization_exam_note_12_crop_22.jpg	S
crop_img/computer_organization_exam_note_12_crop_23.jpg	1
crop_img/computer_organization_exam_note_13_crop_0.jpg	) Gated D Latch: When Enable = 1, D=1, output is Q=1, Q=0
crop_img/computer_organization_exam_note_13_crop_1.jpg	Enable=1, D=0, output is Q=0, Q=1
crop_img/computer_organization_exam_note_13_crop_2.jpg	When Enable = 0, Q and Q keep their previous values despite D
crop_img/computer_organization_exam_note_13_crop_3.jpg	changing
crop_img/computer_organization_exam_note_13_crop_4.jpg	D
crop_img/computer_organization_exam_note_13_crop_5.jpg	S
crop_img/computer_organization_exam_note_13_crop_6.jpg	Enable
crop_img/computer_organization_exam_note_13_crop_7.jpg	) Register: An array of Gated D Latches
crop_img/computer_organization_exam_note_13_crop_8.jpg	Leader-Follower Flip Flop: Allow the output to be controlled by clock
crop_img/computer_organization_exam_note_13_crop_9.jpg	leader
crop_img/computer_organization_exam_note_13_crop_10.jpg	Follower
crop_img/computer_organization_exam_note_13_crop_11.jpg	D
crop_img/computer_organization_exam_note_13_crop_12.jpg	D
crop_img/computer_organization_exam_note_13_crop_13.jpg	Gated
crop_img/computer_organization_exam_note_13_crop_14.jpg	Gated
crop_img/computer_organization_exam_note_13_crop_15.jpg	WE
crop_img/computer_organization_exam_note_13_crop_16.jpg	0
crop_img/computer_organization_exam_note_13_crop_17.jpg	WE
crop_img/computer_organization_exam_note_13_crop_18.jpg	D
crop_img/computer_organization_exam_note_13_crop_19.jpg	>0
crop_img/computer_organization_exam_note_13_crop_20.jpg	Latch
crop_img/computer_organization_exam_note_13_crop_21.jpg	Latch
crop_img/computer_organization_exam_note_13_crop_22.jpg	)Triggering
crop_img/computer_organization_exam_note_13_crop_23.jpg	allowing the circuit to be active, ie. it can take input
crop_img/computer_organization_exam_note_13_crop_24.jpg	个
crop_img/computer_organization_exam_note_13_crop_25.jpg	and give output
crop_img/computer_organization_exam_note_13_crop_26.jpg	. level trigger: The circuit becomes active when the gating or clock
crop_img/computer_organization_exam_note_13_crop_27.jpg	pulse is on a particular level
crop_img/computer_organization_exam_note_13_crop_28.jpg	Edge trigger: The circuit becomes active at negative or positive
crop_img/computer_organization_exam_note_13_crop_29.jpg	edge of the clock signal
crop_img/computer_organization_exam_note_13_crop_30.jpg	. Flip-flop is edge triggered
crop_img/computer_organization_exam_note_14_crop_0.jpg	State machine: control system with finite # states
crop_img/computer_organization_exam_note_14_crop_1.jpg	How to maintain state? Memory
crop_img/computer_organization_exam_note_14_crop_2.jpg	• What state to go next the circuit output depends on the current
crop_img/computer_organization_exam_note_14_crop_3.jpg	state and circuit input
crop_img/computer_organization_exam_note_14_crop_4.jpg	Moore machine: its output values are determined solely by its current
crop_img/computer_organization_exam_note_14_crop_5.jpg	state
crop_img/computer_organization_exam_note_14_crop_6.jpg	) Algorithm for creating state machine logic:
crop_img/computer_organization_exam_note_14_crop_7.jpg	① Label the states
crop_img/computer_organization_exam_note_14_crop_8.jpg	Create the truth table from the state diagram using all values of
crop_img/computer_organization_exam_note_14_crop_9.jpg	2
crop_img/computer_organization_exam_note_14_crop_10.jpg	the input lines and current-state lines
crop_img/computer_organization_exam_note_14_crop_11.jpg	③
crop_img/computer_organization_exam_note_14_crop_12.jpg	Write a sum-of-product boolean equation for each output value
crop_img/computer_organization_exam_note_14_crop_13.jpg	(next state and output lines) from the truth table
crop_img/computer_organization_exam_note_14_crop_14.jpg	④ simplify the equations
crop_img/computer_organization_exam_note_14_crop_15.jpg	⑤
crop_img/computer_organization_exam_note_14_crop_16.jpg	Implement the equations with gates
crop_img/computer_organization_exam_note_14_crop_17.jpg	) Von Neumann Model: A fundamental model of a computer for processing
crop_img/computer_organization_exam_note_14_crop_18.jpg	comp programs) consisting of:
crop_img/computer_organization_exam_note_14_crop_19.jpg	. Memory
crop_img/computer_organization_exam_note_14_crop_20.jpg	. A processing unit
crop_img/computer_organization_exam_note_14_crop_21.jpg	. Input
crop_img/computer_organization_exam_note_14_crop_22.jpg	output
crop_img/computer_organization_exam_note_15_crop_0.jpg	. A control unit
crop_img/computer_organization_exam_note_15_crop_1.jpg	Comp program: a set of instructions, contained in memory
crop_img/computer_organization_exam_note_15_crop_2.jpg	. The data the program needs is either in input or mem
crop_img/computer_organization_exam_note_15_crop_3.jpg	Address space: # distinct memory locations
crop_img/computer_organization_exam_note_15_crop_4.jpg	Addressability: capacity of each location #bit each location can store
crop_img/computer_organization_exam_note_15_crop_5.jpg	.) Reading from a mem location:
crop_img/computer_organization_exam_note_15_crop_6.jpg	① Place the addr of that location in the mem addr reg (MAR)
crop_img/computer_organization_exam_note_15_crop_7.jpg	The data in the location then put into mem data reg (MDR)
crop_img/computer_organization_exam_note_15_crop_8.jpg	2
crop_img/computer_organization_exam_note_15_crop_9.jpg	) writing to a mem location:
crop_img/computer_organization_exam_note_15_crop_10.jpg	1 Place the addr of that location into MAR
crop_img/computer_organization_exam_note_15_crop_11.jpg	2
crop_img/computer_organization_exam_note_15_crop_12.jpg	Place the data to write into MDR
crop_img/computer_organization_exam_note_15_crop_13.jpg	Turn on Write Enable signal (WE)
crop_img/computer_organization_exam_note_15_crop_14.jpg	3
crop_img/computer_organization_exam_note_15_crop_15.jpg	(GPR)
crop_img/computer_organization_exam_note_15_crop_16.jpg	) Processing Unit: ALU + 8 general purpose register (R0→ R7)
crop_img/computer_organization_exam_note_15_crop_17.jpg	Input / output:
crop_img/computer_organization_exam_note_15_crop_18.jpg	keyboard / monitor
crop_img/computer_organization_exam_note_15_crop_19.jpg	Control Unit: keep track of both where we are in the process of
crop_img/computer_organization_exam_note_15_crop_20.jpg	executing the program and executing each instruction
crop_img/computer_organization_exam_note_15_crop_21.jpg	Inst are processed one at a time
crop_img/computer_organization_exam_note_16_crop_0.jpg	program Counter (PC): Holds the current program counter (addr of the
crop_img/computer_organization_exam_note_16_crop_1.jpg	next instruction)
crop_img/computer_organization_exam_note_16_crop_2.jpg	.3 ways to update PC:
crop_img/computer_organization_exam_note_16_crop_3.jpg	Given a value for the PC via address adder
crop_img/computer_organization_exam_note_16_crop_4.jpg	. PC=PC+1
crop_img/computer_organization_exam_note_16_crop_5.jpg	. Given the value for the PC via the bus
crop_img/computer_organization_exam_note_16_crop_6.jpg	) Instruction Register (IR): holds the value of the current instruction
crop_img/computer_organization_exam_note_16_crop_7.jpg	on the processor
crop_img/computer_organization_exam_note_16_crop_8.jpg	) Instruction set: The LC3 ISA instruction set has 15 instructions
crop_img/computer_organization_exam_note_16_crop_9.jpg	. Not 16 because one is reserved for future use
crop_img/computer_organization_exam_note_16_crop_10.jpg	) operand: An operand can be found in 3 places
crop_img/computer_organization_exam_note_16_crop_11.jpg	. part of the instruction → immediate value
crop_img/computer_organization_exam_note_16_crop_12.jpg	. Register
crop_img/computer_organization_exam_note_16_crop_13.jpg	Memory
crop_img/computer_organization_exam_note_16_crop_14.jpg	2) Addressing mode: A formula to calculate the addr of a mem location
crop_img/computer_organization_exam_note_16_crop_15.jpg	to be read / write
crop_img/computer_organization_exam_note_16_crop_16.jpg	V
crop_img/computer_organization_exam_note_16_crop_17.jpg	go in to see what in the mem loc
crop_img/computer_organization_exam_note_16_crop_18.jpg	Base+offset mode: let R0 = x3001 be the base register
crop_img/computer_organization_exam_note_16_crop_19.jpg	offset=3
crop_img/computer_organization_exam_note_17_crop_0.jpg	(what inst is it!)
crop_img/computer_organization_exam_note_17_crop_1.jpg	0) Instruction:
crop_img/computer_organization_exam_note_17_crop_2.jpg	opcode
crop_img/computer_organization_exam_note_17_crop_3.jpg	+
crop_img/computer_organization_exam_note_17_crop_4.jpg	operands
crop_img/computer_organization_exam_note_17_crop_5.jpg	.3 kinds of inst:
crop_img/computer_organization_exam_note_17_crop_6.jpg	. operates: operate on data (ADD, AND, NOT)
crop_img/computer_organization_exam_note_17_crop_7.jpg	. Data Movement: move info from processing unit to and from
crop_img/computer_organization_exam_note_17_crop_8.jpg	mem and to and from I/O devices
crop_img/computer_organization_exam_note_17_crop_9.jpg	Control: Altering order of instructions (normally the inst
crop_img/computer_organization_exam_note_17_crop_10.jpg	in the next mem loc will be processed)
crop_img/computer_organization_exam_note_17_crop_11.jpg	ADD:
crop_img/computer_organization_exam_note_17_crop_12.jpg	& source operands
crop_img/computer_organization_exam_note_17_crop_13.jpg	+ 1 destination operand
crop_img/computer_organization_exam_note_17_crop_14.jpg	≥1 of them
crop_img/computer_organization_exam_note_17_crop_15.jpg	GPR
crop_img/computer_organization_exam_note_17_crop_16.jpg	is stored
crop_img/computer_organization_exam_note_17_crop_17.jpg	in GPR
crop_img/computer_organization_exam_note_17_crop_18.jpg	.Note: 3 bits to identify GPR (from 0→7)
crop_img/computer_organization_exam_note_17_crop_19.jpg	.Ex: 0001|110|010|00110
crop_img/computer_organization_exam_note_17_crop_20.jpg	↓
crop_img/computer_organization_exam_note_17_crop_21.jpg	R6
crop_img/computer_organization_exam_note_17_crop_22.jpg	R6
crop_img/computer_organization_exam_note_17_crop_23.jpg	R2
crop_img/computer_organization_exam_note_17_crop_24.jpg	2 row
crop_img/computer_organization_exam_note_17_crop_25.jpg	V
crop_img/computer_organization_exam_note_17_crop_26.jpg	operands taken
crop_img/computer_organization_exam_note_17_crop_27.jpg	dest operand
crop_img/computer_organization_exam_note_17_crop_28.jpg	from GPR
crop_img/computer_organization_exam_note_17_crop_29.jpg	Do: Add Rd and R6 ) store result to R6
crop_img/computer_organization_exam_note_17_crop_30.jpg	0001|110|010|1|00110
crop_img/computer_organization_exam_note_17_crop_31.jpg	↓
crop_img/computer_organization_exam_note_17_crop_32.jpg	immediate
crop_img/computer_organization_exam_note_17_crop_33.jpg	R2
crop_img/computer_organization_exam_note_17_crop_34.jpg	R6
crop_img/computer_organization_exam_note_17_crop_35.jpg	1 o
crop_img/computer_organization_exam_note_17_crop_36.jpg	value6
crop_img/computer_organization_exam_note_17_crop_37.jpg	V
crop_img/computer_organization_exam_note_17_crop_38.jpg	operands taken
crop_img/computer_organization_exam_note_17_crop_39.jpg	from GLR
crop_img/computer_organization_exam_note_17_crop_40.jpg	dest operand
crop_img/computer_organization_exam_note_17_crop_41.jpg	D。: Add R2 and 6 store result to R6
crop_img/computer_organization_exam_note_18_crop_0.jpg	Lo（load): go into a mem location, read the value in there and t
crop_img/computer_organization_exam_note_18_crop_1.jpg	it in one of the GPR
crop_img/computer_organization_exam_note_18_crop_2.jpg	Ex:
crop_img/computer_organization_exam_note_18_crop_3.jpg	00100 10011000 110
crop_img/computer_organization_exam_note_18_crop_4.jpg	Ra
crop_img/computer_organization_exam_note_18_crop_5.jpg	198
crop_img/computer_organization_exam_note_18_crop_6.jpg	↓
crop_img/computer_organization_exam_note_18_crop_7.jpg	V
crop_img/computer_organization_exam_note_18_crop_8.jpg	dest operand
crop_img/computer_organization_exam_note_18_crop_9.jpg	offset, used addressing
crop_img/computer_organization_exam_note_18_crop_10.jpg	mode
crop_img/computer_organization_exam_note_18_crop_11.jpg	of mem loc
crop_img/computer_organization_exam_note_18_crop_12.jpg	to read
crop_img/computer_organization_exam_note_18_crop_13.jpg	.) LEA ; load a GPR with an addr
crop_img/computer_organization_exam_note_18_crop_14.jpg	1110| 101
crop_img/computer_organization_exam_note_18_crop_15.jpg	Ex:
crop_img/computer_organization_exam_note_18_crop_16.jpg	111111101
crop_img/computer_organization_exam_note_18_crop_17.jpg	R5
crop_img/computer_organization_exam_note_18_crop_18.jpg	-3
crop_img/computer_organization_exam_note_18_crop_19.jpg	D{ :Store lc*+(-3) to R5
crop_img/computer_organization_exam_note_18_crop_20.jpg	*
crop_img/computer_organization_exam_note_18_crop_21.jpg	)Condition codes: There are single-bit eg N that are initially
crop_img/computer_organization_exam_note_18_crop_22.jpg	set each time one of the GPR is written
crop_img/computer_organization_exam_note_18_crop_23.jpg	. 1o0: negative data written into GPR
crop_img/computer_organization_exam_note_18_crop_24.jpg	. 010 : zero
crop_img/computer_organization_exam_note_18_crop_25.jpg	data written into GPR
crop_img/computer_organization_exam_note_18_crop_26.jpg	. ool : positive data written into GPR
crop_img/computer_organization_exam_note_18_crop_27.jpg	)Instruction Cycle: 6 phases
crop_img/computer_organization_exam_note_18_crop_28.jpg	.Fetch:
crop_img/computer_organization_exam_note_18_crop_29.jpg	obtain the next inst from memory and loads it into IR
crop_img/computer_organization_exam_note_18_crop_30.jpg	increment Ic
crop_img/computer_organization_exam_note_18_crop_31.jpg	Decode: 4-to-16 decoder, taking in opcode output the line of to
crop_img/computer_organization_exam_note_19_crop_0.jpg	that opcode
crop_img/computer_organization_exam_note_19_crop_1.jpg	. Evaluate addr: compute the addr of mem location that is needed for
crop_img/computer_organization_exam_note_19_crop_2.jpg	for the inst
crop_img/computer_organization_exam_note_19_crop_3.jpg	. Fetch operands: Loading MAR with the addr calculated in Evaluated
crop_img/computer_organization_exam_note_19_crop_4.jpg	addr
crop_img/computer_organization_exam_note_19_crop_5.jpg	Execute: perform the task
crop_img/computer_organization_exam_note_19_crop_6.jpg	Store result
crop_img/computer_organization_exam_note_19_crop_7.jpg	* Note: Not all inst use all 6 phases
crop_img/computer_organization_exam_note_19_crop_8.jpg	) BR(branch); If(condition …)→ do this inst
crop_img/computer_organization_exam_note_19_crop_9.jpg	Format: 0000|n2P|loff
crop_img/computer_organization_exam_note_19_crop_10.jpg	Use pc-relative
crop_img/computer_organization_exam_note_19_crop_11.jpg	Po:
crop_img/computer_organization_exam_note_19_crop_12.jpg	If n/z/p=1, check the condition code if N/z/p=1
crop_img/computer_organization_exam_note_19_crop_13.jpg	then set Ic to new addr
crop_img/computer_organization_exam_note_19_crop_14.jpg	Use base + offset
crop_img/computer_organization_exam_note_19_crop_15.jpg	√
crop_img/computer_organization_exam_note_19_crop_16.jpg	) JMs: change Pc* to data in the base register
crop_img/computer_organization_exam_note_19_crop_17.jpg	This helps reaching mem location outside of offset range
crop_img/computer_organization_exam_note_19_crop_18.jpg	Format: 1100000|010|000000
crop_img/computer_organization_exam_note_19_crop_19.jpg	BaseR:
crop_img/computer_organization_exam_note_19_crop_20.jpg	offset=0
crop_img/computer_organization_exam_note_19_crop_21.jpg	R2
crop_img/computer_organization_exam_note_20_crop_0.jpg	) Assembly: a low level language
crop_img/computer_organization_exam_note_20_crop_1.jpg	) Instructions: Label
crop_img/computer_organization_exam_note_20_crop_2.jpg	Opcode operand
crop_img/computer_organization_exam_note_20_crop_3.jpg	Comment
crop_img/computer_organization_exam_note_20_crop_4.jpg	Optional
crop_img/computer_organization_exam_note_20_crop_5.jpg	Use name
crop_img/computer_organization_exam_note_20_crop_6.jpg	optional
crop_img/computer_organization_exam_note_20_crop_7.jpg	s.t ADD, LO
crop_img/computer_organization_exam_note_20_crop_8.jpg	) Labels: symbolic name assigned to the mem loc
crop_img/computer_organization_exam_note_20_crop_9.jpg	. A location can contain an inst/value
crop_img/computer_organization_exam_note_20_crop_10.jpg	) Assembler: translate program in Assembly → machine language
crop_img/computer_organization_exam_note_20_crop_11.jpg	) Pseudo-Ops (Assembler directives): A message from programmer
crop_img/computer_organization_exam_note_20_crop_12.jpg	to the assembler to help it process
crop_img/computer_organization_exam_note_20_crop_13.jpg	•.ORIG: tell the assembler where in the mem to place the program
crop_img/computer_organization_exam_note_20_crop_14.jpg	Ex:.ORIG × 3001
crop_img/computer_organization_exam_note_20_crop_15.jpg	•.FILL: set aside the next loc in the program and initialize it
crop_img/computer_organization_exam_note_20_crop_16.jpg	with a value/label
crop_img/computer_organization_exam_note_20_crop_17.jpg	•.BLKW: set aside a # sequential mem locations
crop_img/computer_organization_exam_note_20_crop_18.jpg	NEXTBLKW 2
crop_img/computer_organization_exam_note_20_crop_19.jpg	Ex:
crop_img/computer_organization_exam_note_20_crop_20.jpg	•.STRINGZ: initialize a sequence of n + mem locs to store n
crop_img/computer_organization_exam_note_20_crop_21.jpg	chars (last loc contains x0000 - end-of-string char)
crop_img/computer_organization_exam_note_20_crop_22.jpg	.END:
crop_img/computer_organization_exam_note_20_crop_23.jpg	end of program ) don't process any after
crop_img/computer_organization_exam_note_21_crop_0.jpg	Assembly progress: The progress of running an Assembly program
crop_img/computer_organization_exam_note_21_crop_1.jpg	. 2 complete passes:
crop_img/computer_organization_exam_note_21_crop_2.jpg	① Identify the addr and to each symbolic label and store them
crop_img/computer_organization_exam_note_21_crop_3.jpg	to a table (symbol table)
crop_img/computer_organization_exam_note_21_crop_4.jpg	Translate Assembly insts into machine language
crop_img/computer_organization_exam_note_21_crop_5.jpg	2
crop_img/computer_organization_exam_note_21_crop_6.jpg	) Subroutines: functions for Assembly
crop_img/computer_organization_exam_note_21_crop_7.jpg	) call/Return mechanism: the user makes a call inst to code A, and
crop_img/computer_organization_exam_note_21_crop_8.jpg	after the computer execute code A, it makes a return instruction to the
crop_img/computer_organization_exam_note_21_crop_9.jpg	next inst in the program
crop_img/computer_organization_exam_note_21_crop_10.jpg	. caller: the program that contains the call inst
crop_img/computer_organization_exam_note_21_crop_11.jpg	. callee: the function
crop_img/computer_organization_exam_note_21_crop_12.jpg	 JsR(R): loads lc with the starting addr of the subroutine and loads
crop_img/computer_organization_exam_note_21_crop_13.jpg	R7 with the addr of the inst immediately after the JsR(R) inst
crop_img/computer_organization_exam_note_21_crop_14.jpg	. JSR : use PC-relative addr mode
crop_img/computer_organization_exam_note_21_crop_15.jpg	Format : opcode 11 l offset 11
crop_img/computer_organization_exam_note_21_crop_16.jpg	. JSRR : use BaseR addr mode
crop_img/computer_organization_exam_note_21_crop_17.jpg	Format: Opcode o|oo Base Rooo oo0
crop_img/computer_organization_exam_note_21_crop_18.jpg	 callee Save : the subroutine have to store the existed value into
crop_img/computer_organization_exam_note_21_crop_19.jpg	memory
crop_img/computer_organization_exam_note_21_crop_20.jpg	before overwriting them
crop_img/computer_organization_exam_note_21_crop_21.jpg	 caller save : the caller stores Rt into mem because it will be
crop_img/computer_organization_exam_note_21_crop_22.jpg	Overwritten by JSR(R)
crop_img/computer_organization_exam_note_22_crop_0.jpg	) Stack : last thing We stored in a stack is the 1st thing we remove
crop_img/computer_organization_exam_note_22_crop_1.jpg	from it
crop_img/computer_organization_exam_note_22_crop_2.jpg	. Usage for memory management: We can use stack to manage memory
crop_img/computer_organization_exam_note_22_crop_3.jpg	. R6 stores the addr of the top stack → Stack Pointer
crop_img/computer_organization_exam_note_22_crop_4.jpg	.push (): store data into memory and decrement top = move top
crop_img/computer_organization_exam_note_22_crop_5.jpg	up one pos
crop_img/computer_organization_exam_note_22_crop_6.jpg	pop() : take the data at top position out of stack by incrementing
crop_img/computer_organization_exam_note_22_crop_7.jpg	top = move top down one pos
crop_img/computer_organization_exam_note_22_crop_8.jpg	Frame pointer: A ptr used for
crop_img/computer_organization_exam_note_22_crop_9.jpg	R4
crop_img/computer_organization_exam_note_22_crop_10.jpg	←R6
crop_img/computer_organization_exam_note_22_crop_11.jpg	…
crop_img/computer_organization_exam_note_22_crop_12.jpg	 Accessing local vars from the stack
crop_img/computer_organization_exam_note_22_crop_13.jpg	Callee's
crop_img/computer_organization_exam_note_22_crop_14.jpg	Role
crop_img/computer_organization_exam_note_22_crop_15.jpg	. Saving the return value
crop_img/computer_organization_exam_note_22_crop_16.jpg	duties
crop_img/computer_organization_exam_note_22_crop_17.jpg	local var n
crop_img/computer_organization_exam_note_22_crop_18.jpg	：
crop_img/computer_organization_exam_note_22_crop_19.jpg	• Accessing arguments from the stack
crop_img/computer_organization_exam_note_22_crop_20.jpg	local var1
crop_img/computer_organization_exam_note_22_crop_21.jpg	R5
crop_img/computer_organization_exam_note_22_crop_22.jpg	Old R5
crop_img/computer_organization_exam_note_22_crop_23.jpg	(Frame
crop_img/computer_organization_exam_note_22_crop_24.jpg	R7
crop_img/computer_organization_exam_note_22_crop_25.jpg	Pointer)
crop_img/computer_organization_exam_note_22_crop_26.jpg	return val
crop_img/computer_organization_exam_note_22_crop_27.jpg	1st arg
crop_img/computer_organization_exam_note_22_crop_28.jpg	Caller's
crop_img/computer_organization_exam_note_22_crop_29.jpg	.
crop_img/computer_organization_exam_note_22_crop_30.jpg	duties
crop_img/computer_organization_exam_note_22_crop_31.jpg	last arg
crop_img/computer_organization_exam_note_22_crop_32.jpg	) Memory - mapped Io: Io devices and memory share the same addr space
crop_img/computer_organization_exam_note_22_crop_33.jpg	)synchronous (a things happen at the same time)
crop_img/computer_organization_exam_note_22_crop_34.jpg	. Data supplied at a fixed, predictable rate
crop_img/computer_organization_exam_note_22_crop_35.jpg	. cpu reads/writes every × cycles (consistently check)
crop_img/computer_organization_exam_note_22_crop_36.jpg	) Asynchronous (a things don't happen at the same time)
crop_img/computer_organization_exam_note_22_crop_37.jpg	. Data rate unpredictable
crop_img/computer_organization_exam_note_22_crop_38.jpg	. cpu must synchronize with device, so that it doesn't miss data
crop_img/computer_organization_exam_note_22_crop_39.jpg	or write too quickly (I/o device controls the interaction)
crop_img/computer_organization_exam_note_22_crop_40.jpg	 Note : We focus on asynchronous I/0
crop_img/computer_organization_exam_note_23_crop_0.jpg	Data register: Used for actual transfer of data(eg.char)
crop_img/computer_organization_exam_note_23_crop_1.jpg	) Status register: What the device is telling the cpu
crop_img/computer_organization_exam_note_23_crop_2.jpg	) Control register: Allow us to set changeable device characteristic
crop_img/computer_organization_exam_note_23_crop_3.jpg	) Device register: can be memory mapped or have special Io insts
crop_img/computer_organization_exam_note_23_crop_4.jpg	. We focus on memory mapped Io
crop_img/computer_organization_exam_note_23_crop_5.jpg	(KBSR)
crop_img/computer_organization_exam_note_23_crop_6.jpg	Keyboard status Reg (×FE00):Bit 15 is k when the keyboard
crop_img/computer_organization_exam_note_23_crop_7.jpg	has received a new char
crop_img/computer_organization_exam_note_23_crop_8.jpg	(KBDR)
crop_img/computer_organization_exam_note_23_crop_9.jpg	keyboard Data Reg(e):it[7:0] contain the last char typed
crop_img/computer_organization_exam_note_23_crop_10.jpg	on the keyboard
crop_img/computer_organization_exam_note_23_crop_11.jpg	(DSR)
crop_img/computer_organization_exam_note_23_crop_12.jpg	Display Status Reg (xFE04): Bit 15 is set when device ready to
crop_img/computer_organization_exam_note_23_crop_13.jpg	display another char on screen
crop_img/computer_organization_exam_note_23_crop_14.jpg	(DDR)
crop_img/computer_organization_exam_note_23_crop_15.jpg	Display Data Reg (×FE06): char written on bits [7:0] will be
crop_img/computer_organization_exam_note_23_crop_16.jpg	displayed on screen
crop_img/computer_organization_exam_note_23_crop_17.jpg	) Input from keyboard: When a char is typed, KBDR and KBSR react
crop_img/computer_organization_exam_note_23_crop_18.jpg	and the keyboard is disabled. After KBDR is read, KBSR [15] is cleared
crop_img/computer_organization_exam_note_23_crop_19.jpg	and keyboard is enabled
crop_img/computer_organization_exam_note_23_crop_20.jpg	) output to monitor : When the monitor is ready to display, DSR react.
crop_img/computer_organization_exam_note_23_crop_21.jpg	After the char is written to DDR monitor displays the char and DSR[15]
crop_img/computer_organization_exam_note_23_crop_22.jpg	is cleared
crop_img/computer_organization_exam_note_23_crop_23.jpg	 purpose of os : sharing
crop_img/computer_organization_exam_note_23_crop_24.jpg	resources and protecting user from themselves
crop_img/computer_organization_exam_note_24_crop_0.jpg	and others
crop_img/computer_organization_exam_note_24_crop_1.jpg	) Interrupt: An unscripted subroutine call triggered by an external event
crop_img/computer_organization_exam_note_24_crop_2.jpg	Ex: Io device reports a completion error
crop_img/computer_organization_exam_note_24_crop_3.jpg	Type of privilege :
crop_img/computer_organization_exam_note_24_crop_4.jpg	. Supervisor privilege (privileged):
crop_img/computer_organization_exam_note_24_crop_5.jpg	. Access to all areas in mem and can execute all instructions
crop_img/computer_organization_exam_note_24_crop_6.jpg	. Usually data structures or programs that are part of the
crop_img/computer_organization_exam_note_24_crop_7.jpg	operating system
crop_img/computer_organization_exam_note_24_crop_8.jpg	.User privilege (unprivileged):
crop_img/computer_organization_exam_note_24_crop_9.jpg	. Access to some areas in mem and can execute some inst
crop_img/computer_organization_exam_note_24_crop_10.jpg	 processor State: represented by 3 items
crop_img/computer_organization_exam_note_24_crop_11.jpg	①
crop_img/computer_organization_exam_note_24_crop_12.jpg	processor Status Reg: privilege [15],priority level [10:8], Condition
crop_img/computer_organization_exam_note_24_crop_13.jpg	code [2:0]
crop_img/computer_organization_exam_note_24_crop_14.jpg	. Doesn't really exist ) the format is pushed to stack
crop_img/computer_organization_exam_note_24_crop_15.jpg	privilege = 1: Unprivileged
crop_img/computer_organization_exam_note_24_crop_16.jpg	=0 : Privileged
crop_img/computer_organization_exam_note_24_crop_17.jpg	2
crop_img/computer_organization_exam_note_24_crop_18.jpg	program counter
crop_img/computer_organization_exam_note_24_crop_19.jpg	3
crop_img/computer_organization_exam_note_24_crop_20.jpg	General registers
crop_img/computer_organization_exam_note_24_crop_21.jpg	) Raise Interruption : Device Status Reg set its bit 1 to raise an interrupt
crop_img/computer_organization_exam_note_24_crop_22.jpg	signal
crop_img/computer_organization_note_116_crop_0.jpg	) signed magnitude: The 1st bit represents the sign
crop_img/computer_organization_note_116_crop_1.jpg	，人：
crop_img/computer_organization_note_116_crop_2.jpg	一
crop_img/computer_organization_note_116_crop_3.jpg	.0： +
crop_img/computer_organization_note_116_crop_4.jpg	Ex:1→3
crop_img/computer_organization_note_116_crop_5.jpg	11→-3
crop_img/computer_organization_note_116_crop_6.jpg	n-1
crop_img/computer_organization_note_116_crop_7.jpg	n-1
crop_img/computer_organization_note_116_crop_8.jpg	arithmetic because addition/subtraction are done differently
crop_img/computer_organization_note_116_crop_9.jpg	n- n-
crop_img/computer_organization_note_116_crop_10.jpg	) Two complement: n bits cover [-2^(n-1), 2^(n-1)-1]
crop_img/computer_organization_note_116_crop_11.jpg	Ex: 3 bits represent E [-4,3]
crop_img/computer_organization_note_116_crop_12.jpg	negative int is 1st
crop_img/computer_organization_note_116_crop_13.jpg	100 100 10 1 000 001 010 01
crop_img/computer_organization_note_116_crop_14.jpg	bit is still d!
crop_img/computer_organization_note_116_crop_15.jpg	→
crop_img/computer_organization_note_116_crop_16.jpg	-4-3-2-10123
crop_img/computer_organization_note_116_crop_17.jpg	4567
crop_img/computer_organization_note_116_crop_18.jpg	Addition might result in overflow
crop_img/computer_organization_note_116_crop_19.jpg	into sign and the rest to decimal
crop_img/computer_organization_note_116_crop_20.jpg	010
crop_img/computer_organization_note_116_crop_21.jpg	001
crop_img/computer_organization_note_116_crop_22.jpg	1
crop_img/computer_organization_note_116_crop_23.jpg	d
crop_img/computer_organization_note_116_crop_24.jpg	+
crop_img/computer_organization_note_116_crop_25.jpg	+
crop_img/computer_organization_note_116_crop_26.jpg	+
crop_img/computer_organization_note_116_crop_27.jpg	+
crop_img/computer_organization_note_116_crop_28.jpg	101
crop_img/computer_organization_note_116_crop_29.jpg	11
crop_img/computer_organization_note_116_crop_30.jpg	-3
crop_img/computer_organization_note_116_crop_31.jpg	1
crop_img/computer_organization_note_116_crop_32.jpg	001
crop_img/computer_organization_note_116_crop_33.jpg	110
crop_img/computer_organization_note_116_crop_34.jpg	2
crop_img/computer_organization_note_116_crop_35.jpg	1
crop_img/computer_organization_note_116_crop_36.jpg	• Addition in a-complement:
crop_img/computer_organization_note_116_crop_37.jpg	Add like normal
crop_img/computer_organization_note_116_crop_38.jpg	Ex :
crop_img/computer_organization_note_116_crop_39.jpg	010
crop_img/computer_organization_note_116_crop_40.jpg	010
crop_img/computer_organization_note_116_crop_41.jpg	2
crop_img/computer_organization_note_116_crop_42.jpg	001
crop_img/computer_organization_note_116_crop_43.jpg	1
crop_img/computer_organization_note_116_crop_44.jpg	十
crop_img/computer_organization_note_116_crop_45.jpg	+
crop_img/computer_organization_note_116_crop_46.jpg	+
crop_img/computer_organization_note_116_crop_47.jpg	001
crop_img/computer_organization_note_116_crop_48.jpg	101
crop_img/computer_organization_note_116_crop_49.jpg	1
crop_img/computer_organization_note_116_crop_50.jpg	-3
crop_img/computer_organization_note_116_crop_51.jpg	1
crop_img/computer_organization_note_116_crop_52.jpg	-
crop_img/computer_organization_note_116_crop_53.jpg	011
crop_img/computer_organization_note_116_crop_54.jpg	3
crop_img/computer_organization_note_116_crop_55.jpg	111
crop_img/computer_organization_note_116_crop_56.jpg	-1
crop_img/computer_organization_note_116_crop_57.jpg	000
crop_img/computer_organization_note_116_crop_58.jpg	0
crop_img/computer_organization_note_116_crop_59.jpg	7
crop_img/computer_organization_note_116_crop_60.jpg	2
crop_img/computer_organization_note_116_crop_61.jpg	1
crop_img/computer_organization_note_116_crop_62.jpg	1
crop_img/computer_organization_note_116_crop_63.jpg	0
crop_img/computer_organization_note_116_crop_64.jpg	0
crop_img/computer_organization_note_116_crop_65.jpg	1
crop_img/computer_organization_note_116_crop_66.jpg	1
crop_img/computer_organization_note_116_crop_67.jpg	0
crop_img/computer_organization_note_116_crop_68.jpg	0
crop_img/computer_organization_note_116_crop_69.jpg	0
crop_img/computer_organization_note_116_crop_70.jpg	563
crop_img/computer_organization_note_116_crop_71.jpg	→
crop_img/computer_organization_note_116_crop_72.jpg	281
crop_img/computer_organization_note_116_crop_73.jpg	→140→70
crop_img/computer_organization_note_116_crop_74.jpg	35
crop_img/computer_organization_note_116_crop_75.jpg	17
crop_img/computer_organization_note_116_crop_76.jpg	→
crop_img/computer_organization_note_116_crop_77.jpg	8
crop_img/computer_organization_note_116_crop_78.jpg	→
crop_img/computer_organization_note_116_crop_79.jpg	4→a→
crop_img/computer_organization_note_116_crop_80.jpg	→
crop_img/computer_organization_note_116_crop_81.jpg	J
crop_img/computer_organization_note_117_crop_0.jpg	→ 563
crop_img/computer_organization_note_117_crop_1.jpg	=1000110011
crop_img/computer_organization_note_117_crop_2.jpg	10
crop_img/computer_organization_note_117_crop_3.jpg	2
crop_img/computer_organization_note_117_crop_4.jpg	.
crop_img/computer_organization_note_117_crop_5.jpg	43
crop_img/computer_organization_note_117_crop_6.jpg	101011
crop_img/computer_organization_note_117_crop_7.jpg	10
crop_img/computer_organization_note_117_crop_8.jpg	2
crop_img/computer_organization_note_117_crop_9.jpg	14
crop_img/computer_organization_note_117_crop_10.jpg	1110
crop_img/computer_organization_note_117_crop_11.jpg	二
crop_img/computer_organization_note_117_crop_12.jpg	10
crop_img/computer_organization_note_117_crop_13.jpg	2
crop_img/computer_organization_note_117_crop_14.jpg	101011
crop_img/computer_organization_note_117_crop_15.jpg	43
crop_img/computer_organization_note_117_crop_16.jpg	10
crop_img/computer_organization_note_117_crop_17.jpg	2
crop_img/computer_organization_note_117_crop_18.jpg	十
crop_img/computer_organization_note_117_crop_19.jpg	→
crop_img/computer_organization_note_117_crop_20.jpg	+
crop_img/computer_organization_note_117_crop_21.jpg	入4
crop_img/computer_organization_note_117_crop_22.jpg	001110
crop_img/computer_organization_note_117_crop_23.jpg	10
crop_img/computer_organization_note_117_crop_24.jpg	2
crop_img/computer_organization_note_117_crop_25.jpg	57
crop_img/computer_organization_note_117_crop_26.jpg	10
crop_img/computer_organization_note_117_crop_27.jpg	| 1 f 00 1
crop_img/computer_organization_note_117_crop_28.jpg	32+.16 +8+0+0+1 =57
crop_img/computer_organization_note_117_crop_29.jpg	2
crop_img/computer_organization_note_117_crop_30.jpg	43
crop_img/computer_organization_note_117_crop_31.jpg	10
crop_img/computer_organization_note_117_crop_32.jpg	1
crop_img/computer_organization_note_117_crop_33.jpg	011
crop_img/computer_organization_note_117_crop_34.jpg	10
crop_img/computer_organization_note_117_crop_35.jpg	2
crop_img/computer_organization_note_117_crop_36.jpg	→
crop_img/computer_organization_note_117_crop_37.jpg	1410
crop_img/computer_organization_note_117_crop_38.jpg	1011
crop_img/computer_organization_note_117_crop_39.jpg	10
crop_img/computer_organization_note_117_crop_40.jpg	2
crop_img/computer_organization_note_117_crop_41.jpg	29
crop_img/computer_organization_note_117_crop_42.jpg	10
crop_img/computer_organization_note_117_crop_43.jpg	0 11101
crop_img/computer_organization_note_117_crop_44.jpg	16+ 8+4 + 0+ 1 = 29
crop_img/computer_organization_note_117_crop_45.jpg	2
crop_img/computer_organization_note_117_crop_46.jpg	c
crop_img/computer_organization_note_117_crop_47.jpg	)How to convert negative int into -mpment:flip&inc
crop_img/computer_organization_note_117_crop_48.jpg	1416=
crop_img/computer_organization_note_117_crop_49.jpg	00110
crop_img/computer_organization_note_117_crop_50.jpg	2
crop_img/computer_organization_note_117_crop_51.jpg	flip
crop_img/computer_organization_note_117_crop_52.jpg	-14。
crop_img/computer_organization_note_117_crop_53.jpg	110001+1=110010
crop_img/computer_organization_note_117_crop_54.jpg	=
crop_img/computer_organization_note_117_crop_55.jpg	2
crop_img/computer_organization_note_117_crop_56.jpg	2
crop_img/computer_organization_note_117_crop_57.jpg	α
crop_img/computer_organization_note_117_crop_58.jpg	2
crop_img/computer_organization_note_117_crop_59.jpg	inc
crop_img/computer_organization_note_117_crop_60.jpg	.Then we can perform 43x-4 using addition in a-C:
crop_img/computer_organization_note_117_crop_61.jpg	101011。
crop_img/computer_organization_note_117_crop_62.jpg	2
crop_img/computer_organization_note_117_crop_63.jpg	+
crop_img/computer_organization_note_117_crop_64.jpg	110010
crop_img/computer_organization_note_117_crop_65.jpg	d
crop_img/computer_organization_note_117_crop_66.jpg	101× 101
crop_img/computer_organization_note_117_crop_67.jpg	2
crop_img/computer_organization_note_117_crop_68.jpg	excluded
crop_img/computer_organization_note_117_crop_69.jpg	because the addition is positive
crop_img/computer_organization_note_118_crop_0.jpg	) overflow : Out of bit to repre numbers
crop_img/computer_organization_note_118_crop_1.jpg	Adding a too big positive #
crop_img/computer_organization_note_118_crop_2.jpg	Amall negative #
crop_img/computer_organization_note_118_crop_3.jpg	carryin
crop_img/computer_organization_note_118_crop_4.jpg	sign :
crop_img/computer_organization_note_118_crop_5.jpg	:. A carry in into a sign bit but no carry out
crop_img/computer_organization_note_118_crop_6.jpg	≠ carry out
crop_img/computer_organization_note_118_crop_7.jpg	A carry out of a sign bit but no carry in
crop_img/computer_organization_note_118_crop_8.jpg	sign extension : To extend from m-bit → n-bit for -comp
crop_img/computer_organization_note_118_crop_9.jpg	.For positive int, add 0 in front
crop_img/computer_organization_note_118_crop_10.jpg	— negative int, add 
crop_img/computer_organization_note_118_crop_11.jpg	Fractionary Binary Number :
crop_img/computer_organization_note_118_crop_12.jpg	-2
crop_img/computer_organization_note_118_crop_13.jpg	-3
crop_img/computer_organization_note_118_crop_14.jpg	1.1010..=1 +1.2 +0.2+1.2+…
crop_img/computer_organization_note_118_crop_15.jpg	floating point numbers
crop_img/computer_organization_note_118_crop_16.jpg	E-127
crop_img/computer_organization_note_118_crop_17.jpg	·IEEE-754:
crop_img/computer_organization_note_118_crop_18.jpg	*
crop_img/computer_organization_note_118_crop_19.jpg	1.M *2
crop_img/computer_organization_note_118_crop_20.jpg	·18. sign - bit
crop_img/computer_organization_note_118_crop_21.jpg	→sign
crop_img/computer_organization_note_118_crop_22.jpg	magnitude sy
crop_img/computer_organization_note_118_crop_23.jpg	.E: exponent -8 bits
crop_img/computer_organization_note_118_crop_24.jpg	→(E-27)E[-127，129]
crop_img/computer_organization_note_118_crop_25.jpg	. M: mantissa -a3bits
crop_img/computer_organization_note_118_crop_26.jpg	Drawbacks : Big value
crop_img/computer_organization_note_118_crop_27.jpg	sacrifices precision
crop_img/computer_organization_note_118_crop_28.jpg	.It is because big value requires big E→ shifting the
crop_img/computer_organization_note_118_crop_29.jpg	floating point to the right
crop_img/computer_organization_note_119_crop_0.jpg	1
crop_img/computer_organization_note_119_crop_1.jpg	0
crop_img/computer_organization_note_119_crop_2.jpg	0
crop_img/computer_organization_note_119_crop_3.jpg	0
crop_img/computer_organization_note_119_crop_4.jpg	0
crop_img/computer_organization_note_119_crop_5.jpg	一
crop_img/computer_organization_note_119_crop_6.jpg	一
crop_img/computer_organization_note_119_crop_7.jpg	0
crop_img/computer_organization_note_119_crop_8.jpg	1
crop_img/computer_organization_note_119_crop_9.jpg	一
crop_img/computer_organization_note_119_crop_10.jpg	.OR
crop_img/computer_organization_note_119_crop_11.jpg	°NAND : NOT AND
crop_img/computer_organization_note_119_crop_12.jpg	. NOT
crop_img/computer_organization_note_119_crop_13.jpg	XOR:
crop_img/computer_organization_note_119_crop_14.jpg	A
crop_img/computer_organization_note_119_crop_15.jpg	B
crop_img/computer_organization_note_119_crop_16.jpg	A
crop_img/computer_organization_note_119_crop_17.jpg	XORB
crop_img/computer_organization_note_119_crop_18.jpg	0→0
crop_img/computer_organization_note_119_crop_19.jpg	0
crop_img/computer_organization_note_119_crop_20.jpg	0
crop_img/computer_organization_note_119_crop_21.jpg	。
crop_img/computer_organization_note_119_crop_22.jpg	1
crop_img/computer_organization_note_119_crop_23.jpg	一
crop_img/computer_organization_note_119_crop_24.jpg	0
crop_img/computer_organization_note_119_crop_25.jpg	一
crop_img/computer_organization_note_119_crop_26.jpg	一
crop_img/computer_organization_note_119_crop_27.jpg	)Given two
crop_img/computer_organization_note_119_crop_28.jpg	junctions
crop_img/computer_organization_note_120_crop_0.jpg	=7
crop_img/computer_organization_note_120_crop_1.jpg	α
crop_img/computer_organization_note_120_crop_2.jpg	二
crop_img/computer_organization_note_120_crop_3.jpg	trash
crop_img/computer_organization_note_120_crop_4.jpg	Bit vect ons : packed 10 into a vector
crop_img/computer_organization_note_120_crop_5.jpg	Ex：
crop_img/computer_organization_note_120_crop_6.jpg	v=
crop_img/computer_organization_note_120_crop_7.jpg	0b10101010
crop_img/computer_organization_note_120_crop_8.jpg	binary
crop_img/computer_organization_note_120_crop_9.jpg	v=0b10000000
crop_img/computer_organization_note_120_crop_10.jpg	—
crop_img/computer_organization_note_120_crop_11.jpg	W=0=
crop_img/computer_organization_note_120_crop_12.jpg	00□00000
crop_img/computer_organization_note_120_crop_13.jpg	1111
crop_img/computer_organization_note_120_crop_14.jpg	⇒7
crop_img/computer_organization_note_120_crop_15.jpg	NW=
crop_img/computer_organization_note_121_crop_0.jpg	？
crop_img/computer_organization_note_121_crop_1.jpg	16
crop_img/computer_organization_note_121_crop_2.jpg	2
crop_img/computer_organization_note_121_crop_3.jpg	1
crop_img/computer_organization_note_121_crop_4.jpg	+
crop_img/computer_organization_note_121_crop_5.jpg	2
crop_img/computer_organization_note_121_crop_6.jpg	4
crop_img/computer_organization_note_121_crop_7.jpg	111
crop_img/computer_organization_note_121_crop_8.jpg	010
crop_img/computer_organization_note_121_crop_9.jpg	001
crop_img/computer_organization_note_121_crop_10.jpg	010
crop_img/computer_organization_note_121_crop_11.jpg	100
crop_img/computer_organization_note_121_crop_12.jpg	0111
crop_img/computer_organization_note_121_crop_13.jpg	0100
crop_img/computer_organization_note_121_crop_14.jpg	01010100
crop_img/computer_organization_note_121_crop_15.jpg	4
crop_img/computer_organization_note_121_crop_16.jpg	4
crop_img/computer_organization_note_121_crop_17.jpg	5
crop_img/computer_organization_note_121_crop_18.jpg	7
crop_img/computer_organization_note_121_crop_19.jpg	7454
crop_img/computer_organization_note_121_crop_20.jpg	16
crop_img/computer_organization_note_121_crop_21.jpg	.) ASCII : Repre words/ numx/symbols with bits
crop_img/computer_organization_note_121_crop_22.jpg	upper case → lowercase : SET bit5
crop_img/computer_organization_note_121_crop_23.jpg	lowercase → uppercase : CLEAR bit 5
crop_img/computer_organization_note_121_crop_24.jpg	65 536
crop_img/computer_organization_note_121_crop_25.jpg	. Transition :
crop_img/computer_organization_note_121_crop_26.jpg	we want to understand the behavior of transistor os
crop_img/computer_organization_note_121_crop_27.jpg	a switch
crop_img/computer_organization_note_122_crop_0.jpg	NOT Gate
crop_img/computer_organization_note_122_crop_1.jpg	2.9
crop_img/computer_organization_note_122_crop_2.jpg	O
crop_img/computer_organization_note_122_crop_3.jpg	A
crop_img/computer_organization_note_122_crop_4.jpg	→
crop_img/computer_organization_note_122_crop_5.jpg	1B
crop_img/computer_organization_note_122_crop_6.jpg	C
crop_img/computer_organization_note_124_crop_0.jpg	219
crop_img/computer_organization_note_124_crop_1.jpg	0
crop_img/computer_organization_note_124_crop_2.jpg	A
crop_img/computer_organization_note_124_crop_3.jpg	1
crop_img/computer_organization_note_124_crop_4.jpg	B
crop_img/computer_organization_note_124_crop_5.jpg	→ 1
crop_img/computer_organization_note_124_crop_6.jpg	C
crop_img/computer_organization_note_124_crop_7.jpg	7
crop_img/computer_organization_note_124_crop_8.jpg	(Not OR)
crop_img/computer_organization_note_124_crop_9.jpg	B
crop_img/computer_organization_note_124_crop_10.jpg	A
crop_img/computer_organization_note_124_crop_11.jpg	NOR
crop_img/computer_organization_note_124_crop_12.jpg	A
crop_img/computer_organization_note_124_crop_13.jpg	B
crop_img/computer_organization_note_124_crop_14.jpg	NOR
crop_img/computer_organization_note_124_crop_15.jpg	Gate
crop_img/computer_organization_note_124_crop_16.jpg	⇒
crop_img/computer_organization_note_124_crop_17.jpg	人
crop_img/computer_organization_note_124_crop_18.jpg	1
crop_img/computer_organization_note_124_crop_19.jpg	0
crop_img/computer_organization_note_124_crop_20.jpg	1 0
crop_img/computer_organization_note_124_crop_21.jpg	0
crop_img/computer_organization_note_124_crop_22.jpg	一
crop_img/computer_organization_note_124_crop_23.jpg	0
crop_img/computer_organization_note_124_crop_24.jpg	0 0
crop_img/computer_organization_note_124_crop_25.jpg	一
crop_img/computer_organization_note_124_crop_26.jpg	NOR
crop_img/computer_organization_note_124_crop_27.jpg	NOT(NOR)
crop_img/computer_organization_note_124_crop_28.jpg	NOT
crop_img/computer_organization_note_124_crop_29.jpg	=OR
crop_img/computer_organization_note_124_crop_30.jpg	A
crop_img/computer_organization_note_124_crop_31.jpg	B
crop_img/computer_organization_note_124_crop_32.jpg	C
crop_img/computer_organization_note_124_crop_33.jpg	D
crop_img/computer_organization_note_125_crop_0.jpg	NOT
crop_img/computer_organization_note_125_crop_1.jpg	1
crop_img/computer_organization_note_125_crop_2.jpg	1
crop_img/computer_organization_note_125_crop_3.jpg	1
crop_img/computer_organization_note_125_crop_4.jpg	1
crop_img/computer_organization_note_125_crop_5.jpg	1
crop_img/computer_organization_note_125_crop_6.jpg	AND
crop_img/computer_organization_note_125_crop_7.jpg	1
crop_img/computer_organization_note_125_crop_8.jpg	D
crop_img/computer_organization_note_125_crop_9.jpg	1
crop_img/computer_organization_note_125_crop_10.jpg	Gate
crop_img/computer_organization_note_125_crop_11.jpg	1
crop_img/computer_organization_note_125_crop_12.jpg	1
crop_img/computer_organization_note_125_crop_13.jpg	1
crop_img/computer_organization_note_125_crop_14.jpg	1
crop_img/computer_organization_note_125_crop_15.jpg	1
crop_img/computer_organization_note_125_crop_16.jpg	1
crop_img/computer_organization_note_125_crop_17.jpg	1
crop_img/computer_organization_note_125_crop_18.jpg	1
crop_img/computer_organization_note_125_crop_19.jpg	1
crop_img/computer_organization_note_125_crop_20.jpg	1
crop_img/computer_organization_note_125_crop_21.jpg	1
crop_img/computer_organization_note_125_crop_22.jpg	1
crop_img/computer_organization_note_125_crop_23.jpg	1
crop_img/computer_organization_note_125_crop_24.jpg	1
crop_img/computer_organization_note_125_crop_25.jpg	1
crop_img/computer_organization_note_125_crop_26.jpg	1
crop_img/computer_organization_note_125_crop_27.jpg	1
crop_img/computer_organization_note_125_crop_28.jpg	NAND
crop_img/computer_organization_note_125_crop_29.jpg	1
crop_img/computer_organization_note_125_crop_30.jpg	Note: Don't connect N-type transistor to power
crop_img/computer_organization_note_125_crop_31.jpg	because they
crop_img/computer_organization_note_125_crop_32.jpg	P-type
crop_img/computer_organization_note_125_crop_33.jpg	ground
crop_img/computer_organization_note_125_crop_34.jpg	will cause
crop_img/computer_organization_note_125_crop_35.jpg	floating voltage across the transistor
crop_img/computer_organization_note_125_crop_36.jpg	(CLC)
crop_img/computer_organization_note_125_crop_37.jpg	Combinational Logic circuits: output depends only on the inputs
crop_img/computer_organization_note_125_crop_38.jpg	Decoder: The output has exactly one 1 and the rest is
crop_img/computer_organization_note_125_crop_39.jpg	n inputs
crop_img/computer_organization_note_125_crop_40.jpg	a outputs
crop_img/computer_organization_note_125_crop_41.jpg	Mux: select one of the inputs and connect it to the output
crop_img/computer_organization_note_125_crop_42.jpg	A
crop_img/computer_organization_note_125_crop_43.jpg	B
crop_img/computer_organization_note_125_crop_44.jpg	I input line
crop_img/computer_organization_note_125_crop_45.jpg	√
crop_img/computer_organization_note_125_crop_46.jpg	S
crop_img/computer_organization_note_125_crop_47.jpg	c (the same as A on B
crop_img/computer_organization_note_125_crop_48.jpg	depends on s)
crop_img/computer_organization_note_126_crop_0.jpg	n input line
crop_img/computer_organization_note_126_crop_1.jpg	2 inputs
crop_img/computer_organization_note_126_crop_2.jpg	One Bit Adder: form A + b
crop_img/computer_organization_note_126_crop_3.jpg	where A, b are n-bits numbers
crop_img/computer_organization_note_126_crop_4.jpg	one bit output
crop_img/computer_organization_note_126_crop_5.jpg	Input: 3 n-bits numbers (A, B) and
crop_img/computer_organization_note_126_crop_6.jpg	carry
crop_img/computer_organization_note_126_crop_7.jpg	carry's
crop_img/computer_organization_note_126_crop_8.jpg	output: an-bits
crop_img/computer_organization_note_126_crop_9.jpg	carry
crop_img/computer_organization_note_126_crop_10.jpg	result
crop_img/computer_organization_note_126_crop_11.jpg	to next
crop_img/computer_organization_note_126_crop_12.jpg	column
crop_img/computer_organization_note_126_crop_13.jpg	circuit Sim:
crop_img/computer_organization_note_126_crop_14.jpg	Wine color:
crop_img/computer_organization_note_126_crop_15.jpg	Dark green: wire with value 0
crop_img/computer_organization_note_126_crop_16.jpg	Light green:
crop_img/computer_organization_note_126_crop_17.jpg	1
crop_img/computer_organization_note_126_crop_18.jpg	Blue
crop_img/computer_organization_note_126_crop_19.jpg	uninitialized wire
crop_img/computer_organization_note_126_crop_20.jpg	V
crop_img/computer_organization_note_126_crop_21.jpg	Connected to power is considered initialized
crop_img/computer_organization_note_126_crop_22.jpg	I tran: parallel
crop_img/computer_organization_note_126_crop_23.jpg	whose results are
crop_img/computer_organization_note_126_crop_24.jpg	广
crop_img/computer_organization_note_126_crop_25.jpg	For boolean circuit √
crop_img/computer_organization_note_126_crop_26.jpg	three 1s and one 0
crop_img/computer_organization_note_126_crop_27.jpg	N tran: sequential
crop_img/computer_organization_note_126_crop_28.jpg	I tran: sequential
crop_img/computer_organization_note_126_crop_29.jpg	Symbols:
crop_img/computer_organization_note_126_crop_30.jpg	N tran: parallel
crop_img/computer_organization_note_126_crop_31.jpg	NOT
crop_img/computer_organization_note_126_crop_32.jpg	D0
crop_img/computer_organization_note_126_crop_33.jpg	——
crop_img/computer_organization_note_126_crop_34.jpg	——D
crop_img/computer_organization_note_126_crop_35.jpg	OR
crop_img/computer_organization_note_126_crop_36.jpg	AND
crop_img/computer_organization_note_126_crop_37.jpg	NOR
crop_img/computer_organization_note_126_crop_38.jpg	—0
crop_img/computer_organization_note_126_crop_39.jpg	NAND
crop_img/computer_organization_note_126_crop_40.jpg	□
crop_img/computer_organization_note_127_crop_0.jpg	A + B
crop_img/computer_organization_note_127_crop_1.jpg	三A ∨ B
crop_img/computer_organization_note_127_crop_2.jpg	A′
crop_img/computer_organization_note_127_crop_3.jpg	= ¬A
crop_img/computer_organization_note_127_crop_4.jpg	AB
crop_img/computer_organization_note_127_crop_5.jpg	三A ∧ B
crop_img/computer_organization_note_127_crop_6.jpg	Boolean algebra:
crop_img/computer_organization_note_127_crop_7.jpg	Additive: A + B = B + A
crop_img/computer_organization_note_127_crop_8.jpg	Multiplicative: AB = BA
crop_img/computer_organization_note_127_crop_9.jpg	A(BC) = (AB)C
crop_img/computer_organization_note_127_crop_10.jpg	Basic Identities: A + 0 = A
crop_img/computer_organization_note_127_crop_11.jpg	0A
crop_img/computer_organization_note_127_crop_12.jpg	= 0
crop_img/computer_organization_note_127_crop_13.jpg	1A = A
crop_img/computer_organization_note_127_crop_14.jpg	A+1=1
crop_img/computer_organization_note_127_crop_15.jpg	A+A=A
crop_img/computer_organization_note_127_crop_16.jpg	AA=A
crop_img/computer_organization_note_127_crop_17.jpg	A+A=1
crop_img/computer_organization_note_127_crop_18.jpg	AA=0
crop_img/computer_organization_note_127_crop_19.jpg	Useful equation: A + AB =A
crop_img/computer_organization_note_127_crop_20.jpg	A+AB=A+B
crop_img/computer_organization_note_127_crop_21.jpg	(A+B)(A+C)=A+BC
crop_img/computer_organization_note_127_crop_22.jpg	Truth table to circuit:
crop_img/computer_organization_note_127_crop_23.jpg	Each And gate sep one row of the true table
crop_img/computer_organization_note_127_crop_24.jpg	Each or gate rep one col of the true table
crop_img/computer_organization_note_128_crop_0.jpg	可
crop_img/computer_organization_note_128_crop_1.jpg	k-map:
crop_img/computer_organization_note_128_crop_2.jpg	B
crop_img/computer_organization_note_128_crop_3.jpg	B
crop_img/computer_organization_note_128_crop_4.jpg	What is the
crop_img/computer_organization_note_128_crop_5.jpg	What is the
crop_img/computer_organization_note_128_crop_6.jpg	A'
crop_img/computer_organization_note_128_crop_7.jpg	output if both A
crop_img/computer_organization_note_128_crop_8.jpg	output if A is
crop_img/computer_organization_note_128_crop_9.jpg	and B are
crop_img/computer_organization_note_128_crop_10.jpg	false and B is
crop_img/computer_organization_note_128_crop_11.jpg	false?
crop_img/computer_organization_note_128_crop_12.jpg	true?
crop_img/computer_organization_note_128_crop_13.jpg	What is the
crop_img/computer_organization_note_128_crop_14.jpg	A
crop_img/computer_organization_note_128_crop_15.jpg	What is the
crop_img/computer_organization_note_128_crop_16.jpg	output if A is
crop_img/computer_organization_note_128_crop_17.jpg	output if both A
crop_img/computer_organization_note_128_crop_18.jpg	true and B is
crop_img/computer_organization_note_128_crop_19.jpg	and B are true?
crop_img/computer_organization_note_128_crop_20.jpg	false?
crop_img/computer_organization_note_128_crop_21.jpg	.valid grycoe:on entityhage fomoe tetotnext
crop_img/computer_organization_note_128_crop_22.jpg	) Basic storage:
crop_img/computer_organization_note_128_crop_23.jpg	) R/S Latch:
crop_img/computer_organization_note_128_crop_24.jpg	1
crop_img/computer_organization_note_128_crop_25.jpg	"
crop_img/computer_organization_note_128_crop_26.jpg	.
crop_img/computer_organization_note_128_crop_27.jpg	.
crop_img/computer_organization_note_128_crop_28.jpg	0
crop_img/computer_organization_note_128_crop_29.jpg	U
crop_img/computer_organization_note_128_crop_30.jpg	R
crop_img/computer_organization_note_128_crop_31.jpg	1
crop_img/computer_organization_note_128_crop_32.jpg	①
crop_img/computer_organization_note_128_crop_33.jpg	S
crop_img/computer_organization_note_128_crop_34.jpg	1
crop_img/computer_organization_note_128_crop_35.jpg	.
crop_img/computer_organization_note_128_crop_36.jpg	(regardless of s)
crop_img/computer_organization_note_128_crop_37.jpg	R=1
crop_img/computer_organization_note_128_crop_38.jpg	→U=0)0=1
crop_img/computer_organization_note_128_crop_39.jpg	→ U= 1，0=0
crop_img/computer_organization_note_128_crop_40.jpg	_R)
crop_img/computer_organization_note_128_crop_41.jpg	S=1
crop_img/computer_organization_note_128_crop_42.jpg	→ Stable → The circuit has memory
crop_img/computer_organization_note_129_crop_0.jpg	·
crop_img/computer_organization_note_129_crop_1.jpg	R=S=O → U=D=
crop_img/computer_organization_note_129_crop_2.jpg	Not stable
crop_img/computer_organization_note_129_crop_3.jpg	If we want stable and don't want an input=1 all the time
crop_img/computer_organization_note_129_crop_4.jpg	→ ①-latch
crop_img/computer_organization_note_129_crop_5.jpg	clock: control the pace the circuit does things
crop_img/computer_organization_note_129_crop_6.jpg	) State machine: control system with a finite # states
crop_img/computer_organization_note_129_crop_7.jpg	0
crop_img/computer_organization_note_129_crop_8.jpg	1
crop_img/computer_organization_note_129_crop_9.jpg	0
crop_img/computer_organization_note_129_crop_10.jpg	S
crop_img/computer_organization_note_129_crop_11.jpg	S1
crop_img/computer_organization_note_129_crop_12.jpg	0
crop_img/computer_organization_note_129_crop_13.jpg	the state We gonna ended at or is Not 3
crop_img/computer_organization_note_129_crop_14.jpg	Maintaining state in memory
crop_img/computer_organization_note_129_crop_15.jpg	. Make sure we have efficient states for our machine
crop_img/computer_organization_note_129_crop_16.jpg	. Make sure at a state, the machine knows what state to
crop_img/computer_organization_note_129_crop_17.jpg	go to next.
crop_img/computer_organization_note_129_crop_18.jpg	Moore machine: output determined by current state
crop_img/computer_organization_note_129_crop_19.jpg	.) one Hot: a method to encode state
crop_img/computer_organization_note_129_crop_20.jpg	0001→state 1
crop_img/computer_organization_note_129_crop_21.jpg	0010
crop_img/computer_organization_note_129_crop_22.jpg	a
crop_img/computer_organization_note_129_crop_23.jpg	0100
crop_img/computer_organization_note_129_crop_24.jpg	3
crop_img/computer_organization_note_129_crop_25.jpg	1000
crop_img/computer_organization_note_129_crop_26.jpg	4
crop_img/computer_organization_note_130_crop_0.jpg	84210
crop_img/computer_organization_note_130_crop_1.jpg	Binary encoder:
crop_img/computer_organization_note_130_crop_2.jpg	another method to encode state
crop_img/computer_organization_note_130_crop_3.jpg	)Reading state machine true table: pay attention to the state bit
crop_img/computer_organization_note_130_crop_4.jpg	combination
crop_img/computer_organization_note_130_crop_5.jpg	. State
crop_img/computer_organization_note_130_crop_6.jpg	input bit x & state bit
crop_img/computer_organization_note_130_crop_7.jpg	) Von Neumann Model: A fundamental model of a computer for processing comp
crop_img/computer_organization_note_130_crop_8.jpg	programs, consisting of:
crop_img/computer_organization_note_130_crop_9.jpg	. Memory
crop_img/computer_organization_note_130_crop_10.jpg	A processing unit
crop_img/computer_organization_note_130_crop_11.jpg	Input
crop_img/computer_organization_note_130_crop_12.jpg	output
crop_img/computer_organization_note_130_crop_13.jpg	0
crop_img/computer_organization_note_130_crop_14.jpg	A control unit
crop_img/computer_organization_note_130_crop_15.jpg	→ We ω
crop_img/computer_organization_note_130_crop_16.jpg	Comp program: set of instructions contained in memory
crop_img/computer_organization_note_130_crop_17.jpg	,The data the program needs is either in input or mem
crop_img/computer_organization_note_130_crop_18.jpg	) Addressability & Address space:
crop_img/computer_organization_note_130_crop_19.jpg	• Address space : distinct memory locations
crop_img/computer_organization_note_130_crop_20.jpg	• Addressability: capability of each location
crop_img/computer_organization_note_130_crop_21.jpg	) Reading from a mem location:
crop_img/computer_organization_note_131_crop_0.jpg	addressing ind
crop_img/computer_organization_note_131_crop_1.jpg	个
crop_img/computer_organization_note_131_crop_2.jpg	→ The info in the location then got into mem data reg (MDR)
crop_img/computer_organization_note_131_crop_3.jpg	V
crop_img/computer_organization_note_131_crop_4.jpg	hold the content
crop_img/computer_organization_note_131_crop_5.jpg	) Writing to a mem location:
crop_img/computer_organization_note_131_crop_6.jpg	of a mem location
crop_img/computer_organization_note_131_crop_7.jpg	. Place the addr
crop_img/computer_organization_note_131_crop_8.jpg	Place the value need to write into MDR
crop_img/computer_organization_note_131_crop_9.jpg	A
crop_img/computer_organization_note_131_crop_10.jpg	. Turn on Write Enable signal
crop_img/computer_organization_note_131_crop_11.jpg	GLR
crop_img/computer_organization_note_131_crop_12.jpg	) Processing Unit : ALU + 8 general purpose
crop_img/computer_organization_note_131_crop_13.jpg	registers(R0→R7)
crop_img/computer_organization_note_131_crop_14.jpg	) Input, Output : keyboard/ monitor
crop_img/computer_organization_note_131_crop_15.jpg	) Control Unit : keep track of both where we are in the process of
crop_img/computer_organization_note_131_crop_16.jpg	executing the program and executing each instruction
crop_img/computer_organization_note_131_crop_17.jpg	Instruction Processing: The computer processes one instruction at a
crop_img/computer_organization_note_131_crop_18.jpg	time
crop_img/computer_organization_note_131_crop_19.jpg	Instruction : opcode
crop_img/computer_organization_note_131_crop_20.jpg	+
crop_img/computer_organization_note_131_crop_21.jpg	operands
crop_img/computer_organization_note_131_crop_22.jpg	( what instruction is it)
crop_img/computer_organization_note_131_crop_23.jpg	. 8 kinds of instructions :
crop_img/computer_organization_note_131_crop_24.jpg	. Operates: operate on data (ADD, AND, NOT)
crop_img/computer_organization_note_131_crop_25.jpg	. Data Movement : move info from processing unit to and from
crop_img/computer_organization_note_131_crop_26.jpg	memory and to and from I/O devices
crop_img/computer_organization_note_131_crop_27.jpg	Control:
crop_img/computer_organization_note_131_crop_28.jpg	Altering
crop_img/computer_organization_note_131_crop_29.jpg	order of instructions (normally the
crop_img/computer_organization_note_131_crop_30.jpg	instruction in the next mem location will be processed)
crop_img/computer_organization_note_132_crop_0.jpg	ADD : 2 source operands + 1 destination operand
crop_img/computer_organization_note_132_crop_1.jpg	stored in
crop_img/computer_organization_note_132_crop_2.jpg	requires 1 operand
crop_img/computer_organization_note_132_crop_3.jpg	Stored in the processing unit
crop_img/computer_organization_note_132_crop_4.jpg	the processing unit
crop_img/computer_organization_note_132_crop_5.jpg	Note: 3 bits is required to identify
crop_img/computer_organization_note_132_crop_6.jpg	a register
crop_img/computer_organization_note_132_crop_7.jpg	1101010|100|110
crop_img/computer_organization_note_132_crop_8.jpg	Ex:
crop_img/computer_organization_note_132_crop_9.jpg	0001
crop_img/computer_organization_note_132_crop_10.jpg	opcode for
crop_img/computer_organization_note_132_crop_11.jpg	R6
crop_img/computer_organization_note_132_crop_12.jpg	R6
crop_img/computer_organization_note_132_crop_13.jpg	R2
crop_img/computer_organization_note_132_crop_14.jpg	add
crop_img/computer_organization_note_132_crop_15.jpg	↓
crop_img/computer_organization_note_132_crop_16.jpg	destination
crop_img/computer_organization_note_132_crop_17.jpg	operand
crop_img/computer_organization_note_132_crop_18.jpg	content in ks
crop_img/computer_organization_note_132_crop_19.jpg	ay
crop_img/computer_organization_note_132_crop_20.jpg	Q
crop_img/computer_organization_note_132_crop_21.jpg	→
crop_img/computer_organization_note_132_crop_22.jpg	R6<“R2+RC
crop_img/computer_organization_note_132_crop_23.jpg	0001| 110010|①|00110
crop_img/computer_organization_note_132_crop_24.jpg	R6
crop_img/computer_organization_note_132_crop_25.jpg	R
crop_img/computer_organization_note_132_crop_26.jpg	6→ immediate
crop_img/computer_organization_note_132_crop_27.jpg	val
crop_img/computer_organization_note_132_crop_28.jpg	u
crop_img/computer_organization_note_132_crop_29.jpg	2
crop_img/computer_organization_note_132_crop_30.jpg	→R6≤R2+6
crop_img/computer_organization_note_132_crop_31.jpg	AND : Similar to ADD
crop_img/computer_organization_note_132_crop_32.jpg	) Addressing mode :A formula to calculate the address of a mem location to
crop_img/computer_organization_note_132_crop_33.jpg	be read
crop_img/computer_organization_note_132_crop_34.jpg	. LO (load):
crop_img/computer_organization_note_132_crop_35.jpg	go into a mem location, read the value in there, and store
crop_img/computer_organization_note_132_crop_36.jpg	it in one of the register
crop_img/computer_organization_note_132_crop_37.jpg	Ex:0010010011 0 00110
crop_img/computer_organization_note_132_crop_38.jpg	LO
crop_img/computer_organization_note_132_crop_39.jpg	Ra
crop_img/computer_organization_note_132_crop_40.jpg	8
crop_img/computer_organization_note_132_crop_41.jpg	destination operand
crop_img/computer_organization_note_132_crop_42.jpg	operand used to calc
crop_img/computer_organization_note_132_crop_43.jpg	the mem addr to read from
crop_img/computer_organization_note_132_crop_44.jpg	T (w/ sign extension)
crop_img/computer_organization_note_132_crop_45.jpg	. Use PC-relative addressing mode : mem = [PC+ offset]
crop_img/computer_organization_note_133_crop_0.jpg	) Instruction cycle : 6 phases
crop_img/computer_organization_note_133_crop_1.jpg	Fetch : obtain the next instruction from memory and loads it into
crop_img/computer_organization_note_133_crop_2.jpg	the instruction register (IR). At the same time, increment PC
crop_img/computer_organization_note_133_crop_3.jpg	Decode : 4-to-16 decoder (taking in op code) output the line out to
crop_img/computer_organization_note_133_crop_4.jpg	that opcode
crop_img/computer_organization_note_133_crop_5.jpg	Evaluate address : computes the address of mem location that is needed
crop_img/computer_organization_note_133_crop_6.jpg	for the instruction
crop_img/computer_organization_note_133_crop_7.jpg	Fetch Operands : loading MAR w/ the addr calculated in "Evaluate
crop_img/computer_organization_note_133_crop_8.jpg	Address"
crop_img/computer_organization_note_133_crop_9.jpg	Execute : executing the instruction
crop_img/computer_organization_note_133_crop_10.jpg	a
crop_img/computer_organization_note_133_crop_11.jpg	Store result : Storing the result
crop_img/computer_organization_note_133_crop_12.jpg	* Note : Not all instruction require 6 phases
crop_img/computer_organization_note_133_crop_13.jpg	) GBR;
crop_img/computer_organization_note_133_crop_14.jpg	temporary storage location that can be accessed in a single clock
crop_img/computer_organization_note_133_crop_15.jpg	cycle Used by ADD, AND, NOT, LD, LDI, LDR
crop_img/computer_organization_note_133_crop_16.jpg	Instruction set :The LC-3 ISA instruction set has 15 instructions (not
crop_img/computer_organization_note_133_crop_17.jpg	16 since the code 16 is reserved for future use)
crop_img/computer_organization_note_133_crop_18.jpg	operand : An operand can be found in 3 places
crop_img/computer_organization_note_133_crop_19.jpg	. Part of the instruction → immediate operand
crop_img/computer_organization_note_133_crop_20.jpg	Registor
crop_img/computer_organization_note_133_crop_21.jpg	Memory
crop_img/computer_organization_note_134_crop_0.jpg	Thire are addr modes : immedi ate) register, and 3 memory addr
crop_img/computer_organization_note_134_crop_1.jpg	. Imme diate
crop_img/computer_organization_note_134_crop_2.jpg	Register
crop_img/computer_organization_note_134_crop_3.jpg	. pc-relative
crop_img/computer_organization_note_134_crop_4.jpg	Memory
crop_img/computer_organization_note_134_crop_5.jpg	. Indired
crop_img/computer_organization_note_134_crop_6.jpg	) Condition Codes : Thee are 3 single-bit reg N,Z,P that are
crop_img/computer_organization_note_134_crop_7.jpg	individually set each time one of the 8 GPR is written:
crop_img/computer_organization_note_134_crop_8.jpg	3cres
crop_img/computer_organization_note_134_crop_9.jpg	100
crop_img/computer_organization_note_134_crop_10.jpg	010
crop_img/computer_organization_note_134_crop_11.jpg	001
crop_img/computer_organization_note_134_crop_12.jpg	· 100 : negative data written into GPR
crop_img/computer_organization_note_134_crop_13.jpg	. 010 :200
crop_img/computer_organization_note_134_crop_14.jpg	· 001 :positive
crop_img/computer_organization_note_134_crop_15.jpg	Load Effitivre Addr
crop_img/computer_organization_note_134_crop_16.jpg	) LEA instauction: load a GPR with an addres
crop_img/computer_organization_note_134_crop_17.jpg	Ex； A人0|101|11 1 11 1 01
crop_img/computer_organization_note_134_crop_18.jpg	LEA
crop_img/computer_organization_note_134_crop_19.jpg	R5
crop_img/computer_organization_note_134_crop_20.jpg	-3
crop_img/computer_organization_note_134_crop_21.jpg	*
crop_img/computer_organization_note_134_crop_22.jpg	→
crop_img/computer_organization_note_134_crop_23.jpg	PC+(-3)
crop_img/computer_organization_note_134_crop_24.jpg	R5≤
crop_img/computer_organization_note_134_crop_25.jpg	incremented
crop_img/computer_organization_note_134_crop_26.jpg	Pc
crop_img/computer_organization_note_134_crop_27.jpg	Load : the process of moving info from mem to a registor
crop_img/computer_organization_note_134_crop_28.jpg	 The info in mem is still there
crop_img/computer_organization_note_134_crop_29.jpg	 Store:
crop_img/computer_organization_note_134_crop_30.jpg	a regirter to memory
crop_img/computer_organization_note_134_crop_31.jpg	.The info in registor is still there
crop_img/computer_organization_note_135_crop_0.jpg	Format for load / store:
crop_img/computer_organization_note_135_crop_1.jpg	3 bit
crop_img/computer_organization_note_135_crop_2.jpg	4bit
crop_img/computer_organization_note_135_crop_3.jpg	opcode
crop_img/computer_organization_note_135_crop_4.jpg	DR o SR
crop_img/computer_organization_note_135_crop_5.jpg	Addr Gen bits
crop_img/computer_organization_note_135_crop_6.jpg	V
crop_img/computer_organization_note_135_crop_7.jpg	register
crop_img/computer_organization_note_135_crop_8.jpg	destination
crop_img/computer_organization_note_135_crop_9.jpg	register
crop_img/computer_organization_note_135_crop_10.jpg	whose value will be
crop_img/computer_organization_note_135_crop_11.jpg	stored in mem
crop_img/computer_organization_note_135_crop_12.jpg	 LOAD
crop_img/computer_organization_note_135_crop_13.jpg	→) STORE
crop_img/computer_organization_note_135_crop_14.jpg	8bit
crop_img/computer_organization_note_135_crop_15.jpg	pc* +offset
crop_img/computer_organization_note_135_crop_16.jpg	)pc-relative : mem
crop_img/computer_organization_note_135_crop_17.jpg	mem location
crop_img/computer_organization_note_135_crop_18.jpg	. LD,St
crop_img/computer_organization_note_135_crop_19.jpg	8bit
crop_img/computer_organization_note_135_crop_20.jpg	Indirect Mode mm=[pc*+offset])prand=[[coffset]]
crop_img/computer_organization_note_135_crop_21.jpg	 The addr of the operand can be any where in mem
crop_img/computer_organization_note_135_crop_22.jpg	. LDI,STI
crop_img/computer_organization_note_135_crop_23.jpg	6lt
crop_img/computer_organization_note_135_crop_24.jpg	) Base+ off set Mode : mem = content of base register
crop_img/computer_organization_note_135_crop_25.jpg	off set
crop_img/computer_organization_note_135_crop_26.jpg	+
crop_img/computer_organization_note_135_crop_27.jpg	↓
crop_img/computer_organization_note_135_crop_28.jpg	aGPR
crop_img/computer_organization_note_135_crop_29.jpg	. LDR, STR
crop_img/computer_organization_note_135_crop_30.jpg	) BR: If (condition…)→ do this Branch condition
crop_img/computer_organization_note_135_crop_31.jpg	Formats
crop_img/computer_organization_note_135_crop_32.jpg	.mem location of the next instruction
crop_img/computer_organization_note_135_crop_33.jpg	. pc Relative
crop_img/computer_organization_note_135_crop_34.jpg	nt) p crpd to N,Z,P set by the previous instruction
crop_img/computer_organization_note_135_crop_35.jpg	tf n /z/=1: check the bit N/z/p ,if it is 1→
crop_img/computer_organization_note_135_crop_36.jpg	change the incremented pc addr from EVALUATE Aes phase
crop_img/computer_organization_note_136_crop_0.jpg	)JMP: change the content of pc→ Content in Base R (a GPR)
crop_img/computer_organization_note_136_crop_1.jpg	.This rules qvaching mem location out side  offset ls range
crop_img/computer_organization_note_136_crop_2.jpg	Format:1 10 0| 0 00 010 000000
crop_img/computer_organization_note_136_crop_3.jpg	BaseR
crop_img/computer_organization_note_136_crop_4.jpg	Systematic decom sition: decompose complex program into small manageable
crop_img/computer_organization_note_136_crop_5.jpg	unit
crop_img/computer_organization_note_136_crop_6.jpg	They contut to build the large unit of work are sequential conditional
crop_img/computer_organization_note_136_crop_7.jpg	and iterative
crop_img/computer_organization_note_136_crop_8.jpg	)subtasks : component& of a large task
crop_img/computer_organization_note_136_crop_9.jpg	addr of instruction
crop_img/computer_organization_note_136_crop_10.jpg	Control flow:
crop_img/computer_organization_note_136_crop_11.jpg	A 1st task
crop_img/computer_organization_note_136_crop_12.jpg	sequential
crop_img/computer_organization_note_136_crop_13.jpg	↓
crop_img/computer_organization_note_136_crop_14.jpg	B1 2nd task
crop_img/computer_organization_note_136_crop_15.jpg	V
crop_img/computer_organization_note_136_crop_16.jpg	B{t$
crop_img/computer_organization_note_136_crop_17.jpg	PC+=1
crop_img/computer_organization_note_136_crop_18.jpg	↓
crop_img/computer_organization_note_136_crop_19.jpg	01
crop_img/computer_organization_note_136_crop_20.jpg	Conditional
crop_img/computer_organization_note_136_crop_21.jpg	A generate condition
crop_img/computer_organization_note_136_crop_22.jpg	conditional BR check
crop_img/computer_organization_note_136_crop_23.jpg	2
crop_img/computer_organization_note_136_crop_24.jpg	true
crop_img/computer_organization_note_136_crop_25.jpg	Sub se
crop_img/computer_organization_note_136_crop_26.jpg	I
crop_img/computer_organization_note_136_crop_27.jpg	$B_{2}1$
crop_img/computer_organization_note_136_crop_28.jpg	sub task2
crop_img/computer_organization_note_136_crop_29.jpg	subtask1 C2+1
crop_img/computer_organization_note_136_crop_30.jpg	一
crop_img/computer_organization_note_136_crop_31.jpg	V
crop_img/computer_organization_note_136_crop_32.jpg	Ca BR that unconditionally blan che
crop_img/computer_organization_note_136_crop_33.jpg	Da
crop_img/computer_organization_note_136_crop_34.jpg	to 0a
crop_img/computer_organization_note_136_crop_35.jpg	+
crop_img/computer_organization_note_136_crop_36.jpg	→
crop_img/computer_organization_note_136_crop_37.jpg	${2+$
crop_img/computer_organization_note_137_crop_0.jpg	) Iterative:
crop_img/computer_organization_note_137_crop_1.jpg	generate condition
crop_img/computer_organization_note_137_crop_2.jpg	A
crop_img/computer_organization_note_137_crop_3.jpg	→
crop_img/computer_organization_note_137_crop_4.jpg	conditional Br check
crop_img/computer_organization_note_137_crop_5.jpg	B
crop_img/computer_organization_note_137_crop_6.jpg	3
crop_img/computer_organization_note_137_crop_7.jpg	true
crop_img/computer_organization_note_137_crop_8.jpg	f alu
crop_img/computer_organization_note_137_crop_9.jpg	0{3}+1$
crop_img/computer_organization_note_137_crop_10.jpg	↓
crop_img/computer_organization_note_137_crop_11.jpg	BR that unconiayban
crop_img/computer_organization_note_137_crop_12.jpg	3
crop_img/computer_organization_note_137_crop_13.jpg	to A
crop_img/computer_organization_note_137_crop_14.jpg	) Assembly language : lows level
crop_img/computer_organization_note_137_crop_15.jpg	) HALT : stop running the program
crop_img/computer_organization_note_137_crop_16.jpg	) Instruction : label
crop_img/computer_organization_note_137_crop_17.jpg	Opcode
crop_img/computer_organization_note_137_crop_18.jpg	operand's
crop_img/computer_organization_note_137_crop_19.jpg	comment
crop_img/computer_organization_note_137_crop_20.jpg	optional
crop_img/computer_organization_note_137_crop_21.jpg	optional
crop_img/computer_organization_note_137_crop_22.jpg	) Labels : symbolic names assigned to the memory location
crop_img/computer_organization_note_137_crop_23.jpg	. A location can contain an instruction /value
crop_img/computer_organization_note_137_crop_24.jpg	) Pseudo-op (Assembler directive) :a message from programmer
crop_img/computer_organization_note_137_crop_25.jpg	to the assembler to help it rocr
crop_img/computer_organization_note_137_crop_26.jpg	translate program in
crop_img/computer_organization_note_137_crop_27.jpg	assembly ISA of the Lc-3
crop_img/computer_organization_note_137_crop_28.jpg	①.ORIG: tell the assembler where in the mem to place the program
crop_img/computer_organization_note_137_crop_29.jpg	Ex :.ORIG×3050
crop_img/computer_organization_note_137_crop_30.jpg	②.FILL: set aside the next location in the program and initialize it
crop_img/computer_organization_note_138_crop_0.jpg	with a value /label
crop_img/computer_organization_note_138_crop_1.jpg	③
crop_img/computer_organization_note_138_crop_2.jpg	.BLKW: set aside a number of sequential mem location
crop_img/computer_organization_note_138_crop_3.jpg	Ex:LOC.BLKW2
crop_img/computer_organization_note_138_crop_4.jpg	last loc contain
crop_img/computer_organization_note_138_crop_5.jpg	×0000
crop_img/computer_organization_note_138_crop_6.jpg	9
crop_img/computer_organization_note_138_crop_7.jpg	④
crop_img/computer_organization_note_138_crop_8.jpg	.STRINGZ:Initialize a sequence of n+1 mem location, where
crop_img/computer_organization_note_138_crop_9.jpg	a sequence of n characters is the operand . Each location holds a
crop_img/computer_organization_note_138_crop_10.jpg	zero-extended ASCII code for the capd char
crop_img/computer_organization_note_138_crop_11.jpg	Ex:.ORIG ×3010
crop_img/computer_organization_note_138_crop_12.jpg	"ello. World!
crop_img/computer_organization_note_138_crop_13.jpg	21
crop_img/computer_organization_note_138_crop_14.jpg	STRINGZ
crop_img/computer_organization_note_138_crop_15.jpg	⑤.END: tell assembler that it reached the end of the program
crop_img/computer_organization_note_138_crop_16.jpg	don t process any after
crop_img/computer_organization_note_138_crop_17.jpg	) Assembly language : d complete parse
crop_img/computer_organization_note_138_crop_18.jpg	① Identify the actual binary addr used to the symbolic labels
crop_img/computer_organization_note_138_crop_19.jpg	→This forms a symbol table
crop_img/computer_organization_note_138_crop_20.jpg	2
crop_img/computer_organization_note_138_crop_21.jpg	Translate assembly instructions into cred machine language instructions
crop_img/computer_organization_note_138_crop_22.jpg	) 1st pass: examines instructions in sequence and increment the Lc once
crop_img/computer_organization_note_138_crop_23.jpg	for each inst
crop_img/computer_organization_note_138_crop_24.jpg	If an inst has a label a symbol entry is made in the table
crop_img/computer_organization_note_138_crop_25.jpg	) 2nd pass: translate the program into Lc-3 machine language int
crop_img/computer_organization_note_139_crop_0.jpg	×3013
crop_img/computer_organization_note_139_crop_1.jpg	R3，PTR
crop_img/computer_organization_note_139_crop_2.jpg	. Ex :L0
crop_img/computer_organization_note_139_crop_3.jpg	→ load R3 with content in x3013
crop_img/computer_organization_note_139_crop_4.jpg	Have lc{*=×3002
crop_img/computer_organization_note_139_crop_5.jpg	We need offset to create binary string repre the inst
crop_img/computer_organization_note_139_crop_6.jpg	Note : because
crop_img/computer_organization_note_139_crop_7.jpg	Executable image: the entity being executed by a computer, created
crop_img/computer_organization_note_139_crop_8.jpg	from module
crop_img/computer_organization_note_139_crop_9.jpg	Each module is translated into an object file containing the instructions
crop_img/computer_organization_note_139_crop_10.jpg	in the computer used for that module
crop_img/computer_organization_note_139_crop_11.jpg	Multiple object Files: Ex: the program are one module and the input data
crop_img/computer_organization_note_139_crop_12.jpg	file are another
crop_img/computer_organization_note_139_crop_13.jpg	beginning addr of the input file
crop_img/computer_organization_note_139_crop_14.jpg	(pseudo-op)
crop_img/computer_organization_note_139_crop_15.jpg	↓
crop_img/computer_organization_note_139_crop_16.jpg	• .EXTERNAL : identify
crop_img/computer_organization_note_139_crop_17.jpg	the START of FILE a not known yet, will
crop_img/computer_organization_note_139_crop_18.jpg	be known when translating the other module
crop_img/computer_organization_note_139_crop_19.jpg	) Sub-routines: function for Assembly
crop_img/computer_organization_note_139_crop_20.jpg	call/return mechanism; the user makes a call instruction to code A
crop_img/computer_organization_note_139_crop_21.jpg	and after the computer execute code A, it makes a return instruction
crop_img/computer_organization_note_139_crop_22.jpg	to the next instruction in the program
crop_img/computer_organization_note_139_crop_23.jpg	.Caller: the program that contains the call inst
crop_img/computer_organization_note_139_crop_24.jpg	callee : the function
crop_img/computer_organization_note_139_crop_25.jpg	JSR(R): loads lc with the starting addr of the subroutine, and loads
crop_img/computer_organization_note_139_crop_26.jpg	R7 with the addr immediately after the JSR(R) inst
crop_img/computer_organization_note_140_crop_0.jpg	where to come back after finishing the subroutine
crop_img/computer_organization_note_140_crop_1.jpg	→ return linkage
crop_img/computer_organization_note_140_crop_2.jpg	. JSR : use PC-relative addr mode
crop_img/computer_organization_note_140_crop_3.jpg	Format: opcode |1 I offset 11
crop_img/computer_organization_note_140_crop_4.jpg	. JSRR : use Base Register addr mode
crop_img/computer_organization_note_140_crop_5.jpg	Format opcode 0000 BaseR 000000
crop_img/computer_organization_note_140_crop_6.jpg	Saving and Restoring Registers: the subroutines may return values by
crop_img/computer_organization_note_140_crop_7.jpg	routing into Mem that already had some values in them
crop_img/computer_organization_note_140_crop_8.jpg	→ The subroutine & have to store those existing values into memories
crop_img/computer_organization_note_140_crop_9.jpg	before overwrite them
crop_img/computer_organization_note_140_crop_10.jpg	callee Save
crop_img/computer_organization_note_140_crop_11.jpg	. Caller Save : the caller does the storing for Rt which will be
crop_img/computer_organization_note_140_crop_12.jpg	destroyed by JSR(R)
crop_img/computer_organization_note_140_crop_13.jpg	) Stack: last thing we stored in a stack is the first thing we removed
crop_img/computer_organization_note_140_crop_14.jpg	from it
crop_img/computer_organization_note_140_crop_15.jpg	.push () pop()
crop_img/computer_organization_note_140_crop_16.jpg	.top:
crop_img/computer_organization_note_140_crop_17.jpg	top
crop_img/computer_organization_note_140_crop_18.jpg	Memory implementation: we change the top pos instead of moving around
crop_img/computer_organization_note_140_crop_19.jpg	the contents of mem locations
crop_img/computer_organization_note_140_crop_20.jpg	. R6 stores the addr of the top stack > stack pointer
crop_img/computer_organization_note_140_crop_21.jpg	. data are stored in mem locations whose addr is decreasing
crop_img/computer_organization_note_140_crop_22.jpg	.) Underflow : pop() when the stack is empty
crop_img/computer_organization_note_140_crop_23.jpg	→85=1 if underflow
crop_img/computer_organization_note_140_crop_24.jpg	O otherwise
crop_img/computer_organization_note_141_crop_0.jpg	full
crop_img/computer_organization_note_141_crop_1.jpg	) overflow : push l)
crop_img/computer_organization_note_141_crop_2.jpg	→ R5=1 is overflow
crop_img/computer_organization_note_141_crop_3.jpg	o otherwise
crop_img/computer_organization_note_141_crop_4.jpg	)How a subroutine can get argument&, return value, as well as
crop_img/computer_organization_note_141_crop_5.jpg	restore register values (including Rt)?→ Stack!
crop_img/computer_organization_note_141_crop_6.jpg	RO-RH
crop_img/computer_organization_note_141_crop_7.jpg	≤R6
crop_img/computer_organization_note_141_crop_8.jpg	3
crop_img/computer_organization_note_141_crop_9.jpg	local var
crop_img/computer_organization_note_141_crop_10.jpg	2
crop_img/computer_organization_note_141_crop_11.jpg	) Frame pointer : a ptr used for
crop_img/computer_organization_note_141_crop_12.jpg	Callee's
crop_img/computer_organization_note_141_crop_13.jpg	:
crop_img/computer_organization_note_141_crop_14.jpg	A
crop_img/computer_organization_note_141_crop_15.jpg	local var
crop_img/computer_organization_note_141_crop_16.jpg	≤R5
crop_img/computer_organization_note_141_crop_17.jpg	Accessing local var from the stack
crop_img/computer_organization_note_141_crop_18.jpg	duties
crop_img/computer_organization_note_141_crop_19.jpg	Old R5
crop_img/computer_organization_note_141_crop_20.jpg	R7
crop_img/computer_organization_note_141_crop_21.jpg	l
crop_img/computer_organization_note_141_crop_22.jpg	Saving the return value
crop_img/computer_organization_note_141_crop_23.jpg	return val
crop_img/computer_organization_note_141_crop_24.jpg	1
crop_img/computer_organization_note_141_crop_25.jpg	Accessing argument from the stack
crop_img/computer_organization_note_141_crop_26.jpg	int arg
crop_img/computer_organization_note_141_crop_27.jpg	2
crop_img/computer_organization_note_141_crop_28.jpg	Caller's
crop_img/computer_organization_note_141_crop_29.jpg	J4
crop_img/computer_organization_note_141_crop_30.jpg	last wig
crop_img/computer_organization_note_141_crop_31.jpg	duties
crop_img/computer_organization_note_141_crop_32.jpg	) C-language : overall
crop_img/computer_organization_note_141_crop_33.jpg	Designed for writing os, other languages, low-level hard drivers)
crop_img/computer_organization_note_141_crop_34.jpg	cryptography)…
crop_img/computer_organization_note_141_crop_35.jpg	Easily compiled and to produce compact efficient code
crop_img/computer_organization_note_141_crop_36.jpg	Don't check runtime error → need to be careful
crop_img/computer_organization_note_141_crop_37.jpg	language compiled directly into machine
crop_img/computer_organization_note_141_crop_38.jpg	C provides some features with c library
crop_img/computer_organization_note_141_crop_39.jpg	. C is procedural, no objects/classes
crop_img/computer_organization_note_141_crop_40.jpg	use struct instead
crop_img/computer_organization_note_141_crop_41.jpg	Pointers are used in place of object ref
crop_img/computer_organization_note_142_crop_0.jpg	Each func must have a unique name
crop_img/computer_organization_note_142_crop_1.jpg	) Data types:
crop_img/computer_organization_note_142_crop_2.jpg	It depends on your platform
crop_img/computer_organization_note_142_crop_3.jpg	char-exactly 8bits
crop_img/computer_organization_note_142_crop_4.jpg	7
crop_img/computer_organization_note_142_crop_5.jpg	short int-at least 16bits
crop_img/computer_organization_note_142_crop_6.jpg	7
crop_img/computer_organization_note_142_crop_7.jpg	int-at least 16bits
crop_img/computer_organization_note_142_crop_8.jpg	7
crop_img/computer_organization_note_142_crop_9.jpg	long int-at least 32bits
crop_img/computer_organization_note_142_crop_10.jpg	7
crop_img/computer_organization_note_142_crop_11.jpg	You can tell with sizeof
crop_img/computer_organization_note_142_crop_12.jpg	sizeof is a compile-time constant reflecting the number of
crop_img/computer_organization_note_142_crop_13.jpg	bytes held by a data type or instance
crop_img/computer_organization_note_142_crop_14.jpg	7
crop_img/computer_organization_note_142_crop_15.jpg	sizeof(char)<= sizeof(short)<= sizeof(int) <= sizeof(long)
crop_img/computer_organization_note_142_crop_16.jpg	×00
crop_img/computer_organization_note_142_crop_17.jpg	7
crop_img/computer_organization_note_142_crop_18.jpg	sizeof char is 1.
crop_img/computer_organization_note_142_crop_19.jpg	↓
crop_img/computer_organization_note_142_crop_20.jpg	Doesn't have boolean type: 0 = false
crop_img/computer_organization_note_142_crop_21.jpg	(meaning 0 = false
crop_img/computer_organization_note_142_crop_22.jpg	any non-zero integer = true
crop_img/computer_organization_note_142_crop_23.jpg	) string : array of chars ends with 0
crop_img/computer_organization_note_142_crop_24.jpg	Ex：char s[]=“abc”
crop_img/computer_organization_note_142_crop_25.jpg	char *s=“abc”
crop_img/computer_organization_note_142_crop_26.jpg	n
crop_img/computer_organization_note_142_crop_27.jpg	. Use strlen to get array's length
crop_img/computer_organization_note_142_crop_28.jpg	cannot modify
crop_img/computer_organization_note_142_crop_29.jpg	#include <string.h>
crop_img/computer_organization_note_142_crop_30.jpg	) Escaped characters :
crop_img/computer_organization_note_142_crop_31.jpg	.\n : new line
crop_img/computer_organization_note_142_crop_32.jpg	·\t: tab
crop_img/computer_organization_note_142_crop_33.jpg	ハん：
crop_img/computer_organization_note_142_crop_34.jpg	carriage return
crop_img/computer_organization_note_142_crop_35.jpg	· \OO0: ASCII 0
crop_img/computer_organization_note_142_crop_36.jpg	.：
crop_img/computer_organization_note_142_crop_37.jpg	(el)
crop_img/computer_organization_note_142_crop_38.jpg	) C preprocessor: a separated entity (not inc), but can be executed by
crop_img/computer_organization_note_142_crop_39.jpg	C-compiler
crop_img/computer_organization_note_143_crop_0.jpg	.Macro: reusable snippet of codeCreated by#define MACRO-NAME
crop_img/computer_organization_note_143_crop_1.jpg	code
crop_img/computer_organization_note_143_crop_2.jpg	→ Take the code snippet defined applied to the macro name
crop_img/computer_organization_note_143_crop_3.jpg	→Include the content of one source file into another file
crop_img/computer_organization_note_143_crop_4.jpg	→Provide additional direction to the compiler for compiling code
crop_img/computer_organization_note_143_crop_5.jpg	) #include
crop_img/computer_organization_note_143_crop_6.jpg	Convention: we only include files that end in ".h"
crop_img/computer_organization_note_143_crop_7.jpg	. Surrounding the file name with "": ll will look in the curr
crop_img/computer_organization_note_143_crop_8.jpg	directory → sys directory
crop_img/computer_organization_note_143_crop_9.jpg	 <> : ll only look in sys dir
crop_img/computer_organization_note_143_crop_10.jpg	(~ cluster)
crop_img/computer_organization_note_143_crop_11.jpg	struct :a composite data type to group related vars into one place
crop_img/computer_organization_note_143_crop_12.jpg	.Contain no methods ,and all members are publicly visible
crop_img/computer_organization_note_143_crop_13.jpg	. Names following the struct tag define instances of the struct
crop_img/computer_organization_note_143_crop_14.jpg	• Identifier/ function names and struct tags occupy
crop_img/computer_organization_note_143_crop_15.jpg	diff name space
crop_img/computer_organization_note_143_crop_16.jpg	→An identifier /function name can be the same as a struct tag
crop_img/computer_organization_note_143_crop_17.jpg	Ex : struct car
crop_img/computer_organization_note_143_crop_18.jpg	char mfg[30];
crop_img/computer_organization_note_143_crop_19.jpg	a struct car
crop_img/computer_organization_note_143_crop_20.jpg	type is
crop_img/computer_organization_note_143_crop_21.jpg	y
crop_img/computer_organization_note_143_crop_22.jpg	char model[30]
crop_img/computer_organization_note_143_crop_23.jpg	int year;
crop_img/computer_organization_note_143_crop_24.jpg	5;
crop_img/computer_organization_note_143_crop_25.jpg	struct car this_car;
crop_img/computer_organization_note_143_crop_26.jpg	type name
crop_img/computer_organization_note_143_crop_27.jpg	struct tag
crop_img/computer_organization_note_143_crop_28.jpg	( not just car)
crop_img/computer_organization_note_143_crop_29.jpg	. Refer a struct member: Ex:
crop_img/computer_organization_note_143_crop_30.jpg	this_car.model
crop_img/computer_organization_note_144_crop_0.jpg	var
crop_img/computer_organization_note_144_crop_1.jpg	Ex: try (mike-car.model, amy-4)
crop_img/computer_organization_note_144_crop_2.jpg	V
crop_img/computer_organization_note_144_crop_3.jpg	should have enough room
crop_img/computer_organization_note_144_crop_4.jpg	pointer: contain &s memory addr of another var
crop_img/computer_organization_note_144_crop_5.jpg	Ex: int b = 20;
crop_img/computer_organization_note_144_crop_6.jpg	mem location “b" holds 20
crop_img/computer_organization_note_144_crop_7.jpg	mem location "baddr holds addr of b
crop_img/computer_organization_note_144_crop_8.jpg	int *p addr =&b
crop_img/computer_organization_note_144_crop_9.jpg	.&{:=addr
crop_img/computer_organization_note_144_crop_10.jpg	（*）
crop_img/computer_organization_note_144_crop_11.jpg	has a meaning:
crop_img/computer_organization_note_144_crop_12.jpg	①In type declaration: Ex:int *px=&
crop_img/computer_organization_note_144_crop_13.jpg	→* :=pointer to
crop_img/computer_organization_note_144_crop_14.jpg	2
crop_img/computer_organization_note_144_crop_15.jpg	In an expression : Ex : px = i
crop_img/computer_organization_note_144_crop_16.jpg	→can be used to read and change the value stored at a known
crop_img/computer_organization_note_144_crop_17.jpg	addr of a mem location
crop_img/computer_organization_note_144_crop_18.jpg	. For an array, the identifier is the pointer to the first element
crop_img/computer_organization_note_144_crop_19.jpg	Ex:int a[10]
crop_img/computer_organization_note_144_crop_20.jpg	Note: a is a const ptr
crop_img/computer_organization_note_144_crop_21.jpg	a =(int *p =  a[0])
crop_img/computer_organization_note_144_crop_22.jpg	it
crop_img/computer_organization_note_144_crop_23.jpg	We can also do arithmetic with pointer to get new pointers
crop_img/computer_organization_note_144_crop_24.jpg	Ex：
crop_img/computer_organization_note_144_crop_25.jpg	 deref
crop_img/computer_organization_note_144_crop_26.jpg	三 β=p+1× size of（*p）
crop_img/computer_organization_note_144_crop_27.jpg	p =p + 1
crop_img/computer_organization_note_145_crop_0.jpg	→If in an int pointer p+ is the address of the next int
crop_img/computer_organization_note_145_crop_1.jpg	*
crop_img/computer_organization_note_145_crop_2.jpg	Ex: a[5]
crop_img/computer_organization_note_145_crop_3.jpg	(a+5)
crop_img/computer_organization_note_145_crop_4.jpg	三
crop_img/computer_organization_note_145_crop_5.jpg	)Operation
crop_img/computer_organization_note_145_crop_6.jpg	a
crop_img/computer_organization_note_145_crop_7.jpg	ptr to a struct → a struct member
crop_img/computer_organization_note_145_crop_8.jpg	Ex:
crop_img/computer_organization_note_145_crop_9.jpg	struct myStruct {
crop_img/computer_organization_note_145_crop_10.jpg	int a, b;
crop_img/computer_organization_note_145_crop_11.jpg	} *p; // p is a pointer to struct myStruct
crop_img/computer_organization_note_145_crop_12.jpg	(*p).a =(*p).b;←
crop_img/computer_organization_note_145_crop_13.jpg	Same
crop_img/computer_organization_note_145_crop_14.jpg	meaning
crop_img/computer_organization_note_145_crop_15.jpg	p->a =p->b;
crop_img/computer_organization_note_145_crop_16.jpg	个
crop_img/computer_organization_note_145_crop_17.jpg	)typedef:a shortcut to create a new alias for a type
crop_img/computer_organization_note_145_crop_18.jpg	struct a b[5]
crop_img/computer_organization_note_145_crop_19.jpg	→ b is an array of 5 struct a
crop_img/computer_organization_note_145_crop_20.jpg	typedef struct a sas[5]
crop_img/computer_organization_note_145_crop_21.jpg	ta5C
crop_img/computer_organization_note_145_crop_22.jpg	struct a c[5]
crop_img/computer_organization_note_145_crop_23.jpg	function name ( para-type para)
crop_img/computer_organization_note_145_crop_24.jpg	-)
crop_img/computer_organization_note_145_crop_25.jpg	function:
crop_img/computer_organization_note_145_crop_26.jpg	type-returned
crop_img/computer_organization_note_145_crop_27.jpg	Define function prototypes before main()
crop_img/computer_organization_note_145_crop_28.jpg	type-returned := void mean the function doesn't return
crop_img/computer_organization_note_145_crop_29.jpg	para-type
crop_img/computer_organization_note_145_crop_30.jpg	i= void
crop_img/computer_organization_note_145_crop_31.jpg	take arguments
crop_img/computer_organization_note_145_crop_32.jpg	main () return an 8-bit value:
crop_img/computer_organization_note_145_crop_33.jpg	.0 means okay everything else means problem
crop_img/computer_organization_note_145_crop_34.jpg	Any function can exit and return value using exit(gtval)
crop_img/computer_organization_note_145_crop_35.jpg	Ex: exit(99)
crop_img/computer_organization_note_145_crop_36.jpg	We can see the value on command line with echo ?
crop_img/computer_organization_note_145_crop_37.jpg	•
crop_img/computer_organization_note_146_crop_0.jpg	) local var : var inside a func, where another func changes its value
crop_img/computer_organization_note_146_crop_1.jpg	won't affect its original value in the host func
crop_img/computer_organization_note_146_crop_2.jpg	 Global var: var outside functions, where another func changes its value
crop_img/computer_organization_note_146_crop_3.jpg	will also change it for other functions
crop_img/computer_organization_note_146_crop_4.jpg	) main():int main(int argc, char *argv[]){
crop_img/computer_organization_note_146_crop_5.jpg	return 0
crop_img/computer_organization_note_146_crop_6.jpg	3
crop_img/computer_organization_note_146_crop_7.jpg	.The first function invoked when running the program
crop_img/computer_organization_note_146_crop_8.jpg	int argc := argument counter
crop_img/computer_organization_note_146_crop_9.jpg	char *argv[] := array of pointers to a char
crop_img/computer_organization_note_146_crop_10.jpg	) const: a type qualifier indicates that a var after initialized cannot
crop_img/computer_organization_note_146_crop_11.jpg	be changed
crop_img/computer_organization_note_146_crop_12.jpg	Ex: const int n=5
crop_img/computer_organization_note_146_crop_13.jpg	sizeof: display the number of bytes held by a data type or an
crop_img/computer_organization_note_146_crop_14.jpg	instance
crop_img/computer_organization_note_146_crop_15.jpg	) GDB: an utility for debugging and executing programs
crop_img/computer_organization_note_146_crop_16.jpg	) C preprocessor: programs that modifies before compilation begins
crop_img/computer_organization_note_146_crop_17.jpg	) C compiler : translate C code into machine code
crop_img/computer_organization_note_146_crop_18.jpg	Including: Source code Analysis, Target Code Synthesis, and Symbol
crop_img/computer_organization_note_146_crop_19.jpg	Table
crop_img/computer_organization_note_146_crop_20.jpg	) Clinker : combine various object modules into a single executable
crop_img/computer_organization_note_147_crop_0.jpg	image
crop_img/computer_organization_note_147_crop_1.jpg	Storage Class: tells where the data will be stored and who can see it
crop_img/computer_organization_note_147_crop_2.jpg	Outside a function definition
crop_img/computer_organization_note_147_crop_3.jpg	Inside a function definition
crop_img/computer_organization_note_147_crop_4.jpg	scope: external definition
crop_img/computer_organization_note_147_crop_5.jpg	scope: within the function
crop_img/computer_organization_note_147_crop_6.jpg	a promise that
crop_img/computer_organization_note_147_crop_7.jpg	<none>
crop_img/computer_organization_note_147_crop_8.jpg	storage: static address
crop_img/computer_organization_note_147_crop_9.jpg	storage: on the stack
crop_img/computer_organization_note_147_crop_10.jpg	same
crop_img/computer_organization_note_147_crop_11.jpg	scope: within the function
crop_img/computer_organization_note_147_crop_12.jpg	9
crop_img/computer_organization_note_147_crop_13.jpg	the var will be
crop_img/computer_organization_note_147_crop_14.jpg	auto
crop_img/computer_organization_note_147_crop_15.jpg	N/A
crop_img/computer_organization_note_147_crop_16.jpg	storage: on the stack
crop_img/computer_organization_note_147_crop_17.jpg	scope: within the file only
crop_img/computer_organization_note_147_crop_18.jpg	scope: within the function
crop_img/computer_organization_note_147_crop_19.jpg	initialized when the
crop_img/computer_organization_note_147_crop_20.jpg	static
crop_img/computer_organization_note_147_crop_21.jpg	storage: static address
crop_img/computer_organization_note_147_crop_22.jpg	storage: static address
crop_img/computer_organization_note_147_crop_23.jpg	program run
crop_img/computer_organization_note_147_crop_24.jpg	scope: external reference
crop_img/computer_organization_note_147_crop_25.jpg	scope: external reference
crop_img/computer_organization_note_147_crop_26.jpg	storage: static address; location
crop_img/computer_organization_note_147_crop_27.jpg	storage: static address; location
crop_img/computer_organization_note_147_crop_28.jpg	determined by file containing the
crop_img/computer_organization_note_147_crop_29.jpg	determined by file containing the
crop_img/computer_organization_note_147_crop_30.jpg	external definition (can't have
crop_img/computer_organization_note_147_crop_31.jpg	external definition (can't have
crop_img/computer_organization_note_147_crop_32.jpg	an extern var
crop_img/computer_organization_note_147_crop_33.jpg	extern
crop_img/computer_organization_note_147_crop_34.jpg	initializer either)
crop_img/computer_organization_note_147_crop_35.jpg	initializer either)
crop_img/computer_organization_note_147_crop_36.jpg	scope: within the function
crop_img/computer_organization_note_147_crop_37.jpg	can also take data
crop_img/computer_organization_note_147_crop_38.jpg	storage: register or stack
crop_img/computer_organization_note_147_crop_39.jpg	(hint to compiler; use of & not
crop_img/computer_organization_note_147_crop_40.jpg	register |N/A
crop_img/computer_organization_note_147_crop_41.jpg	allowed; seldom used)
crop_img/computer_organization_note_147_crop_42.jpg	from other files
crop_img/computer_organization_note_147_crop_43.jpg	Note.
crop_img/computer_organization_note_147_crop_44.jpg	static var only initialized once at the program load
crop_img/computer_organization_note_147_crop_45.jpg	type qualifier: it is part of the object's type
crop_img/computer_organization_note_147_crop_46.jpg	① Const: the value of this var can't be changed after initialization
crop_img/computer_organization_note_147_crop_47.jpg	volatile : the compiler may not optimize ref to this var
crop_img/computer_organization_note_147_crop_48.jpg	2
crop_img/computer_organization_note_147_crop_49.jpg	③
crop_img/computer_organization_note_147_crop_50.jpg	Restrict:
crop_img/computer_organization_note_147_crop_51.jpg	for the lifetime of a ptr, only it or a value
crop_img/computer_organization_note_147_crop_52.jpg	directly derived from it can be used to access the object pointed
crop_img/computer_organization_note_147_crop_53.jpg	by the ptr
crop_img/computer_organization_note_147_crop_54.jpg	void : unspecified type
crop_img/computer_organization_note_148_crop_0.jpg	context
crop_img/computer_organization_note_148_crop_1.jpg	Memory Layout: 4 major memory regions: data, stack, de
crop_img/computer_organization_note_148_crop_2.jpg	related
crop_img/computer_organization_note_148_crop_3.jpg	to mem
crop_img/computer_organization_note_148_crop_4.jpg	allocating
crop_img/computer_organization_note_148_crop_5.jpg	function
crop_img/computer_organization_note_148_crop_6.jpg	) extern ( storage class):
crop_img/computer_organization_note_148_crop_7.jpg	definition
crop_img/computer_organization_note_148_crop_8.jpg	Another c file allocates storage ) not current file
crop_img/computer_organization_note_148_crop_9.jpg	A typical way to link global variables between C files
crop_img/computer_organization_note_148_crop_10.jpg	Declaration: introduce an identifier and its type (array
crop_img/computer_organization_note_148_crop_11.jpg	struct/ function)
crop_img/computer_organization_note_148_crop_12.jpg	) Definition : instantiate the identifier
crop_img/computer_organization_note_148_crop_13.jpg	Base Type:
crop_img/computer_organization_note_148_crop_14.jpg	the type optionally a storage class and /or a type
crop_img/computer_organization_note_148_crop_15.jpg	2
crop_img/computer_organization_note_148_crop_16.jpg	qualifier
crop_img/computer_organization_note_148_crop_17.jpg	Applies to all names up until the
crop_img/computer_organization_note_148_crop_18.jpg	Ex: static volatile long int i *j,k[10
crop_img/computer_organization_note_148_crop_19.jpg	V
crop_img/computer_organization_note_148_crop_20.jpg	√
crop_img/computer_organization_note_148_crop_21.jpg	Base type
crop_img/computer_organization_note_148_crop_22.jpg	Declarator
crop_img/computer_organization_note_148_crop_23.jpg	a function
crop_img/computer_organization_note_148_crop_24.jpg	Reading type:
crop_img/computer_organization_note_148_crop_25.jpg	①
crop_img/computer_organization_note_148_crop_26.jpg	Start at the identifier
crop_img/computer_organization_note_148_crop_27.jpg	)
crop_img/computer_organization_note_148_crop_28.jpg	Go nighat untilmeting a (/)/end
crop_img/computer_organization_note_148_crop_29.jpg	α
crop_img/computer_organization_note_148_crop_30.jpg	③ Go left
crop_img/computer_organization_note_148_crop_31.jpg	Ex: int *(**)()
crop_img/computer_organization_note_148_crop_32.jpg	1. to tight :
crop_img/computer_organization_note_148_crop_33.jpg	f) just f
crop_img/computer_organization_note_149_crop_0.jpg	pointer to a pointer
crop_img/computer_organization_note_149_crop_1.jpg	3. Go right:
crop_img/computer_organization_note_149_crop_2.jpg	that returns a pointer to an int
crop_img/computer_organization_note_149_crop_3.jpg	Unwind a type:jt apply the operator in the order theyaremed
crop_img/computer_organization_note_149_crop_4.jpg	2
crop_img/computer_organization_note_149_crop_5.jpg	3
crop_img/computer_organization_note_149_crop_6.jpg	1
crop_img/computer_organization_note_149_crop_7.jpg	1.add *
crop_img/computer_organization_note_149_crop_8.jpg	a.add *
crop_img/computer_organization_note_149_crop_9.jpg	pointer to a pointer to a function
crop_img/computer_organization_note_149_crop_10.jpg	*
crop_img/computer_organization_note_149_crop_11.jpg	*)
crop_img/computer_organization_note_149_crop_12.jpg	3
crop_img/computer_organization_note_149_crop_13.jpg	8
crop_img/computer_organization_note_149_crop_14.jpg	→
crop_img/computer_organization_note_149_crop_15.jpg	4
crop_img/computer_organization_note_149_crop_16.jpg	that returns a pointer to an int
crop_img/computer_organization_note_149_crop_17.jpg	(deres)
crop_img/computer_organization_note_149_crop_18.jpg	3. call func
crop_img/computer_organization_note_149_crop_19.jpg	*
crop_img/computer_organization_note_149_crop_20.jpg	4. add
crop_img/computer_organization_note_149_crop_21.jpg	*
crop_img/computer_organization_note_149_crop_22.jpg	**
crop_img/computer_organization_note_149_crop_23.jpg	f)（)
crop_img/computer_organization_note_149_crop_24.jpg	mtvrn
crop_img/computer_organization_note_149_crop_25.jpg	return an int
crop_img/computer_organization_note_149_crop_26.jpg	Ith to int
crop_img/computer_organization_note_149_crop_27.jpg	GBA Programming
crop_img/computer_organization_note_149_crop_28.jpg	programming on bare metals)no operating system
crop_img/computer_organization_note_149_crop_29.jpg	Data types:
crop_img/computer_organization_note_149_crop_30.jpg	.Integers (signed/ default /unsigned)
crop_img/computer_organization_note_149_crop_31.jpg	char
crop_img/computer_organization_note_149_crop_32.jpg	(1 byte)
crop_img/computer_organization_note_149_crop_33.jpg	. short int or short (2 bytes)
crop_img/computer_organization_note_149_crop_34.jpg	. int (4 bytes)
crop_img/computer_organization_note_149_crop_35.jpg	long (8 bytes)
crop_img/computer_organization_note_149_crop_36.jpg	享
crop_img/computer_organization_note_149_crop_37.jpg	.Floating Point (to be avoided because they're software emulated)
crop_img/computer_organization_note_149_crop_38.jpg	Float
crop_img/computer_organization_note_149_crop_39.jpg	double
crop_img/computer_organization_note_150_crop_0.jpg	Address space : 32 bit
crop_img/computer_organization_note_150_crop_1.jpg	Display screen : 240 × 160 pixel color video display screen
crop_img/computer_organization_note_150_crop_2.jpg	.hardware supports: video memory → video controller→ display
crop_img/computer_organization_note_150_crop_3.jpg	Device register: Specific memory locations that control various hardware
crop_img/computer_organization_note_150_crop_4.jpg	。
crop_img/computer_organization_note_150_crop_5.jpg	functionalities like the displaying out, and and
crop_img/computer_organization_note_150_crop_6.jpg	REG_DISPCNT : a device register that controls many video modes on the
crop_img/computer_organization_note_150_crop_7.jpg	.
crop_img/computer_organization_note_150_crop_8.jpg	GBA) its address is at 0x04000000
crop_img/computer_organization_note_150_crop_9.jpg	. Access it by using
crop_img/computer_organization_note_150_crop_10.jpg	(unsigned short *) 0x04000000
crop_img/computer_organization_note_150_crop_11.jpg	·OF OE OD OC DB OA 09 08 07 06 05 04 03 02 01 00
crop_img/computer_organization_note_150_crop_12.jpg	Bit mapped graphic
crop_img/computer_organization_note_150_crop_13.jpg	Mode
crop_img/computer_organization_note_150_crop_14.jpg	(BG)
crop_img/computer_organization_note_150_crop_15.jpg	tile Mode: 0,1, 2
crop_img/computer_organization_note_150_crop_16.jpg	Mode :
crop_img/computer_organization_note_150_crop_17.jpg	Bit map Modes: 3, 4, 5
crop_img/computer_organization_note_150_crop_18.jpg	. Use Base for bitmapped graphics
crop_img/computer_organization_note_150_crop_19.jpg	) Video Memory : Use mode 3, and to show the screen, use mode 4
crop_img/computer_organization_note_150_crop_20.jpg	. Starts at 0x06000000
crop_img/computer_organization_note_150_crop_21.jpg	.Consists of 160 × 240 16-bit unsigned shorts
crop_img/computer_organization_note_150_crop_22.jpg	represent colors
crop_img/computer_organization_note_150_crop_23.jpg	Mem lock store colors of pixels going
crop_img/computer_organization_note_150_crop_24.jpg	left-to-right
crop_img/computer_organization_note_150_crop_25.jpg	up-to-down
crop_img/computer_organization_note_151_crop_0.jpg	and mem addr T
crop_img/computer_organization_note_151_crop_1.jpg	addr(row,col)=row*240+col
crop_img/computer_organization_note_151_crop_2.jpg	Addr
crop_img/computer_organization_note_151_crop_3.jpg	.
crop_img/computer_organization_note_151_crop_4.jpg	→
crop_img/computer_organization_note_151_crop_5.jpg	..
crop_img/computer_organization_note_151_crop_6.jpg	) Screen buffer: a portion of video memory that stores the data representing
crop_img/computer_organization_note_151_crop_7.jpg	all the pixels of a complete video frame
crop_img/computer_organization_note_151_crop_8.jpg	)Colors: color of pixel is Represented by a 16-bit unsigned short
crop_img/computer_organization_note_151_crop_9.jpg	0|000000000000
crop_img/computer_organization_note_151_crop_10.jpg	red
crop_img/computer_organization_note_151_crop_11.jpg	not used
crop_img/computer_organization_note_151_crop_12.jpg	blue
crop_img/computer_organization_note_151_crop_13.jpg	green
crop_img/computer_organization_note_151_crop_14.jpg	) Blanking :
crop_img/computer_organization_note_151_crop_15.jpg	240
crop_img/computer_organization_note_151_crop_16.jpg	68
crop_img/computer_organization_note_151_crop_17.jpg	. Hblank : 68 pixels
crop_img/computer_organization_note_151_crop_18.jpg	scanline
crop_img/computer_organization_note_151_crop_19.jpg	, VBlank: 68 scanlines
crop_img/computer_organization_note_151_crop_20.jpg	vdraw
crop_img/computer_organization_note_151_crop_21.jpg	hbl
crop_img/computer_organization_note_151_crop_22.jpg	160
crop_img/computer_organization_note_151_crop_23.jpg	68
crop_img/computer_organization_note_151_crop_24.jpg	vblank
crop_img/computer_organization_note_151_crop_25.jpg	Fig 4.1: vdraw, vblank and hblank
crop_img/computer_organization_note_151_crop_26.jpg	periods.
crop_img/computer_organization_note_151_crop_27.jpg	subject
crop_img/computer_organization_note_151_crop_28.jpg	length
crop_img/computer_organization_note_151_crop_29.jpg	cycles
crop_img/computer_organization_note_151_crop_30.jpg	) Display timing:
crop_img/computer_organization_note_151_crop_31.jpg	pixel
crop_img/computer_organization_note_151_crop_32.jpg	1
crop_img/computer_organization_note_151_crop_33.jpg	4
crop_img/computer_organization_note_151_crop_34.jpg	HDraw
crop_img/computer_organization_note_151_crop_35.jpg	240px
crop_img/computer_organization_note_151_crop_36.jpg	960
crop_img/computer_organization_note_151_crop_37.jpg	HBlank
crop_img/computer_organization_note_151_crop_38.jpg	68px
crop_img/computer_organization_note_151_crop_39.jpg	272
crop_img/computer_organization_note_151_crop_40.jpg	scanline
crop_img/computer_organization_note_151_crop_41.jpg	Hdraw+Hbl
crop_img/computer_organization_note_151_crop_42.jpg	1232
crop_img/computer_organization_note_151_crop_43.jpg	VDraw
crop_img/computer_organization_note_151_crop_44.jpg	160*scanline
crop_img/computer_organization_note_151_crop_45.jpg	197120
crop_img/computer_organization_note_151_crop_46.jpg	VBlank
crop_img/computer_organization_note_151_crop_47.jpg	68*scanline
crop_img/computer_organization_note_151_crop_48.jpg	83776
crop_img/computer_organization_note_151_crop_49.jpg	refresh
crop_img/computer_organization_note_151_crop_50.jpg	VDraw+Vbl
crop_img/computer_organization_note_151_crop_51.jpg	280896
crop_img/computer_organization_note_151_crop_52.jpg	60 Hz
crop_img/computer_organization_note_151_crop_53.jpg	√
crop_img/computer_organization_note_151_crop_54.jpg	Table 4.1: Display timing details
crop_img/computer_organization_note_151_crop_55.jpg	-) Draw and blank periods:
crop_img/computer_organization_note_151_crop_56.jpg	After a scan line has been drawn (the
crop_img/computer_organization_note_152_crop_0.jpg	Hdraw period) there is a HBlank period (68 pixels) before
crop_img/computer_organization_note_152_crop_1.jpg	it starts drawing another scanline
crop_img/computer_organization_note_152_crop_2.jpg	.After 160 scan lines (VDraw) have been drawn, there will be
crop_img/computer_organization_note_152_crop_3.jpg	68 scan lines blank (VBlank) before starting over again
crop_img/computer_organization_note_152_crop_4.jpg	Tearing: change pixel input in the middle of VDraw
crop_img/computer_organization_note_152_crop_5.jpg	output: half this screen, half another screen
crop_img/computer_organization_note_152_crop_6.jpg	• To avoid tearing, update data during VBlank
crop_img/computer_organization_note_152_crop_7.jpg	palette: 2 palettes, one for sprites (objects), one for
crop_img/computer_organization_note_152_crop_8.jpg	background
crop_img/computer_organization_note_152_crop_9.jpg	Both contain 256 entries of 16-bit color
crop_img/computer_organization_note_152_crop_10.jpg	There are 2 ways to use palettes:
crop_img/computer_organization_note_152_crop_11.jpg	. consider it as a single palette with 256 colors
crop_img/computer_organization_note_152_crop_12.jpg	Consider it as a collection of 16 sub-palettes of 16 colors
crop_img/computer_organization_note_152_crop_13.jpg	Index 0 is the transparency index. In palette mode, pixels with
crop_img/computer_organization_note_152_crop_14.jpg	value 0 are transparent
crop_img/computer_organization_note_152_crop_15.jpg	) DMA (Direct Memory Access): A fast way of copying data from
crop_img/computer_organization_note_152_crop_16.jpg	one location to another
crop_img/computer_organization_note_152_crop_17.jpg	) DMA Channels: 4 channels
crop_img/computer_organization_note_152_crop_18.jpg	0: highest priority used for time-critical operations and
crop_img/computer_organization_note_152_crop_19.jpg	can only be used with internal RAM
crop_img/computer_organization_note_152_crop_20.jpg	.1,2: used to transfer sound data
crop_img/computer_organization_note_153_crop_0.jpg	general-purpose copies, can be used for loading in new
crop_img/computer_organization_note_153_crop_1.jpg	3:
crop_img/computer_organization_note_153_crop_2.jpg	bitmap or tile data
crop_img/computer_organization_note_153_crop_3.jpg	) back to C
crop_img/computer_organization_note_153_crop_4.jpg	one dim array: ex: int ia[6]
crop_img/computer_organization_note_153_crop_5.jpg	Address: ia = &ia[0]
crop_img/computer_organization_note_153_crop_6.jpg	) Two dim array: ex: int ia[3][6]
crop_img/computer_organization_note_153_crop_7.jpg	Addr: ia = &ia[0]
crop_img/computer_organization_note_153_crop_8.jpg	ia[0] = &ia[0][0]
crop_img/computer_organization_note_153_crop_9.jpg	Addr of a row 
crop_img/computer_organization_note_153_crop_10.jpg	ia[1] = &ia[1] Addr of row
crop_img/computer_organization_note_153_crop_11.jpg	) Pointer calculations: let char ar[SIZE]
crop_img/computer_organization_note_153_crop_12.jpg	sizeof(char) = 1
crop_img/computer_organization_note_153_crop_13.jpg	Calculate pointer to arr Exy
crop_img/computer_organization_note_153_crop_14.jpg	int offset = (x*row+y) * sizeof(int)
crop_img/computer_organization_note_153_crop_15.jpg	int *p = (int*)((char *) ar + offset)
crop_img/computer_organization_note_153_crop_16.jpg	for 3D array and ijk be the indices)
crop_img/computer_organization_note_153_crop_17.jpg	Note:
crop_img/computer_organization_note_153_crop_18.jpg	offset = i*row*cols + j*cols + k
crop_img/computer_organization_note_153_crop_19.jpg	J8
crop_img/computer_organization_note_153_crop_20.jpg	Why declaring
crop_img/computer_organization_note_153_crop_21.jpg	arr C[J][2] works, but a C[] doesn't?
crop_img/computer_organization_note_153_crop_22.jpg	.Because when calculating to [i][j] we only need to know # cols
crop_img/computer_organization_note_153_crop_23.jpg	Declaring arr C[] is also fine since we don't need to move to
crop_img/computer_organization_note_154_crop_0.jpg	another row (multiplying with # rows is used to move to different
crop_img/computer_organization_note_154_crop_1.jpg	row)
crop_img/computer_organization_note_154_crop_2.jpg	Can "Hello" be
crop_img/computer_organization_note_154_crop_3.jpg	.
crop_img/computer_organization_note_154_crop_4.jpg	Can ptr value
crop_img/computer_organization_note_154_crop_5.jpg	be changed?
crop_img/computer_organization_note_154_crop_6.jpg	changed?
crop_img/computer_organization_note_154_crop_7.jpg	char *cp = "Hell"
crop_img/computer_organization_note_154_crop_8.jpg	or
crop_img/computer_organization_note_154_crop_9.jpg	No
crop_img/computer_organization_note_154_crop_10.jpg	Yes
crop_img/computer_organization_note_154_crop_11.jpg	char ca[] = "Hello"
crop_img/computer_organization_note_154_crop_12.jpg	No
crop_img/computer_organization_note_154_crop_13.jpg	sizeof
crop_img/computer_organization_note_154_crop_14.jpg	char c1[] = "hell."
crop_img/computer_organization_note_154_crop_15.jpg	char *ca = "hello"
crop_img/computer_organization_note_154_crop_16.jpg	sizeof(c) = (including null terminator)
crop_img/computer_organization_note_154_crop_17.jpg	sizeof(ca) = 8 (size of a pointer on your system)
crop_img/computer_organization_note_154_crop_18.jpg	strlen(c) = strlen(ca) = 5
crop_img/computer_organization_note_154_crop_19.jpg	Fun fact: ia[3] = *(ia+3) = *(3+ia) = 3[ia]
crop_img/computer_organization_note_154_crop_20.jpg	Array of pointers: ex: static char *name[] = Illegal name
crop_img/computer_organization_note_154_crop_21.jpg	.
crop_img/computer_organization_note_154_crop_22.jpg	"name1", "name2", "name3"
crop_img/computer_organization_note_154_crop_23.jpg	.
crop_img/computer_organization_note_154_crop_24.jpg	.Also called Originally Indexed Array
crop_img/computer_organization_note_154_crop_25.jpg	Size of struct : size of struct = 2 size of element + filler
crop_img/computer_organization_note_154_crop_26.jpg	小
crop_img/computer_organization_note_154_crop_27.jpg	Filler helps align elements in memory
crop_img/computer_organization_note_154_crop_28.jpg	Align means data types memory address has to be a multiple of
crop_img/computer_organization_note_154_crop_29.jpg	their size
crop_img/computer_organization_note_154_crop_30.jpg	Tip: always use sizeof
crop_img/computer_organization_note_155_crop_0.jpg	Memory allocation: what if we need some space for use to enter data
crop_img/computer_organization_note_155_crop_1.jpg	Malloc(size): reserve a block of memory of size and return
crop_img/computer_organization_note_155_crop_2.jpg	a pointer to it
crop_img/computer_organization_note_155_crop_3.jpg	return a generic ptr of type void * ptr to generic type
crop_img/computer_organization_note_155_crop_4.jpg	share the heap with other library functions that request storage
crop_img/computer_organization_note_155_crop_5.jpg	directly from os
crop_img/computer_organization_note_155_crop_6.jpg	Stack
crop_img/computer_organization_note_155_crop_7.jpg	Unallocated memory
crop_img/computer_organization_note_155_crop_8.jpg	Heap
crop_img/computer_organization_note_155_crop_9.jpg	Data
crop_img/computer_organization_note_155_crop_10.jpg	code
crop_img/computer_organization_note_155_crop_11.jpg	Based on brk() and sbrk()
crop_img/computer_organization_note_155_crop_12.jpg	program break: the mem location that represents the end of heap
crop_img/computer_organization_note_155_crop_14.jpg	memory and the start of unallocated memory
crop_img/computer_organization_note_155_crop_15.jpg	default is on top of the heap
crop_img/computer_organization_note_155_crop_16.jpg	We can move the program break into unallocated mem to get some
crop_img/computer_organization_note_155_crop_17.jpg	extra mem
crop_img/computer_organization_note_155_crop_18.jpg	brk(void end-data-segment): sets the program break to the location
crop_img/computer_organization_note_155_crop_19.jpg	specified by end-data-segment
crop_img/computer_organization_note_155_crop_20.jpg	brk(int increment): increment the size of the program break
crop_img/computer_organization_note_155_crop_21.jpg	by increment
crop_img/computer_organization_note_155_crop_22.jpg	ptr = malloc(size of struct r)
crop_img/computer_organization_note_156_crop_0.jpg	if (np == NULL) wrong
crop_img/computer_organization_note_156_crop_1.jpg	Using ptr before checking → crash
crop_img/computer_organization_note_156_crop_2.jpg	Correct: if ((p=malloc(size of struct ))==NULL)
crop_img/computer_organization_note_156_crop_3.jpg	handle error here
crop_img/computer_organization_note_156_crop_4.jpg	2
crop_img/computer_organization_note_156_crop_5.jpg	09
crop_img/computer_organization_note_156_crop_6.jpg	2
crop_img/computer_organization_note_156_crop_7.jpg	if (!(np= malloc(size of struct )))
crop_img/computer_organization_note_156_crop_8.jpg	handle error here
crop_img/computer_organization_note_156_crop_9.jpg	2
crop_img/computer_organization_note_156_crop_10.jpg	should cast the returned generic-type ptr of malloc to its correct
crop_img/computer_organization_note_156_crop_11.jpg	type by casting
crop_img/computer_organization_note_156_crop_12.jpg	If not the compiler will silently cast it to any type of t
crop_img/computer_organization_note_156_crop_13.jpg	free(): free the allocated memory back to the heap
crop_img/computer_organization_note_156_crop_14.jpg	After free() garbage data will be in the place even though the
crop_img/computer_organization_note_156_crop_15.jpg	ptr still exists
crop_img/computer_organization_note_156_crop_16.jpg	void* calloc (size_t num, size_t size): allocate ≥ num * size
crop_img/computer_organization_note_156_crop_17.jpg	bytes of the memory on the heap, zero-out them and returns a
crop_img/computer_organization_note_156_crop_18.jpg	ptr to it
crop_img/computer_organization_note_156_crop_19.jpg	void* realloc (void* ptr, size_t n): reallocates ≥ n bytes of
crop_img/computer_organization_note_156_crop_20.jpg	mem on the heap, return a ptr to it
crop_img/computer_organization_note_156_crop_21.jpg	Copies the data starting at ptr that was previously allocated
crop_img/computer_organization_note_156_crop_22.jpg	often used to expand the mem size for an existing object on the heap
crop_img/data_structure_algorithm_note_30_crop_0.jpg	Total cost of operations
crop_img/data_structure_algorithm_note_30_crop_1.jpg	Amortized Cost
crop_img/data_structure_algorithm_note_30_crop_2.jpg	#operations
crop_img/data_structure_algorithm_note_30_crop_3.jpg	Pointer: a variable that stores the memory address of an object
crop_img/data_structure_algorithm_note_30_crop_4.jpg	Hard removal: The data removed is completely removed from the
crop_img/data_structure_algorithm_note_30_crop_5.jpg	backing structure
crop_img/data_structure_algorithm_note_30_crop_6.jpg	Set a position to null is a hard removal method
crop_img/data_structure_algorithm_note_30_crop_7.jpg	soft removal: The data is still inside the backing data structure, but
crop_img/data_structure_algorithm_note_30_crop_8.jpg	cannot be accessed by user
crop_img/data_structure_algorithm_note_30_crop_9.jpg	DATA STRUCTURE
crop_img/data_structure_algorithm_note_30_crop_10.jpg	List: An ordered, aligned contiguous collection of data
crop_img/data_structure_algorithm_note_30_crop_11.jpg	no gaps
crop_img/data_structure_algorithm_note_30_crop_12.jpg	start from
crop_img/data_structure_algorithm_note_30_crop_13.jpg	0
crop_img/data_structure_algorithm_note_30_crop_14.jpg	2 standard implementation list: Array list, Linked list
crop_img/data_structure_algorithm_note_30_crop_15.jpg	Array List:
crop_img/data_structure_algorithm_note_30_crop_16.jpg	CS133a lecture note
crop_img/data_structure_algorithm_note_30_crop_17.jpg	Linked list: 3 different implementations: Singly-Linked List
crop_img/data_structure_algorithm_note_30_crop_18.jpg	Doubly-Linked List
crop_img/data_structure_algorithm_note_30_crop_19.jpg	circularly Linked List
crop_img/data_structure_algorithm_note_30_crop_20.jpg	Singly-Linked List: CS133a lecture
crop_img/data_structure_algorithm_note_30_crop_21.jpg	Methods that require going to the end of the list takes o(n)
crop_img/data_structure_algorithm_note_30_crop_22.jpg	AddBack() → tackled using tail pointer
crop_img/data_structure_algorithm_note_30_crop_23.jpg	6
crop_img/data_structure_algorithm_note_30_crop_24.jpg	Remove back() → a problem where it's impossible to assign
crop_img/data_structure_algorithm_note_30_crop_25.jpg	a
crop_img/data_structure_algorithm_note_30_crop_26.jpg	tail to end-to-last node
crop_img/data_structure_algorithm_note_30_crop_27.jpg	→ cannot go backwards
crop_img/data_structure_algorithm_note_31_crop_0.jpg	Note on removeLast(): cannot directly set the data of tail to null
crop_img/data_structure_algorithm_note_31_crop_1.jpg	because the node itself still there meaning the end-to-last
crop_img/data_structure_algorithm_note_31_crop_2.jpg	node is not pointing to null
crop_img/data_structure_algorithm_note_31_crop_3.jpg	Instead, has to traverse the list to the end-to-last node,
crop_img/data_structure_algorithm_note_31_crop_4.jpg	then set its pointer to point to null
crop_img/data_structure_algorithm_note_31_crop_5.jpg	Doubly linked list: Can do all methods in o(1) (except
crop_img/data_structure_algorithm_note_31_crop_6.jpg	addAtIndex()) but costs memory and more complex
crop_img/data_structure_algorithm_note_31_crop_7.jpg	circular singly Linked list: like a singly linked list but the
crop_img/data_structure_algorithm_note_31_crop_8.jpg	last node points to the first node
crop_img/data_structure_algorithm_note_31_crop_9.jpg	"tail" is not needed
crop_img/data_structure_algorithm_note_31_crop_10.jpg	Add Front():
crop_img/data_structure_algorithm_note_31_crop_11.jpg	Move old head's data
crop_img/data_structure_algorithm_note_31_crop_12.jpg	3
crop_img/data_structure_algorithm_note_31_crop_13.jpg	③
crop_img/data_structure_algorithm_note_31_crop_14.jpg	new node
crop_img/data_structure_algorithm_note_31_crop_15.jpg	to new node
crop_img/data_structure_algorithm_note_31_crop_16.jpg	2
crop_img/data_structure_algorithm_note_31_crop_17.jpg	①
crop_img/data_structure_algorithm_note_31_crop_18.jpg	head
crop_img/data_structure_algorithm_note_31_crop_19.jpg	Move new head's data
crop_img/data_structure_algorithm_note_31_crop_20.jpg	a
crop_img/data_structure_algorithm_note_31_crop_21.jpg	to old head
crop_img/data_structure_algorithm_note_31_crop_22.jpg	•Add Back ():
crop_img/data_structure_algorithm_note_31_crop_23.jpg	① Add Front (data)
crop_img/data_structure_algorithm_note_31_crop_24.jpg	② Move Front To Back ()
crop_img/data_structure_algorithm_note_32_crop_0.jpg	Remove Back (): iterate to the and-to-last node
crop_img/data_structure_algorithm_note_33_crop_0.jpg	(Recursion)
crop_img/data_structure_algorithm_note_33_crop_1.jpg	Pointer Reinforcement : each node determine whether it remains in the list
crop_img/data_structure_algorithm_note_33_crop_2.jpg	Et: remove duplicates in a linked List
crop_img/data_structure_algorithm_note_33_crop_3.jpg	1→22→0
crop_img/data_structure_algorithm_note_33_crop_4.jpg	2
crop_img/data_structure_algorithm_note_33_crop_5.jpg	1
crop_img/data_structure_algorithm_note_33_crop_6.jpg	1
crop_img/data_structure_algorithm_note_33_crop_7.jpg	public void removeDuplicates(){
crop_img/data_structure_algorithm_note_33_crop_8.jpg	2
crop_img/data_structure_algorithm_note_33_crop_9.jpg	head = rRemove(head);
crop_img/data_structure_algorithm_note_33_crop_10.jpg	return
crop_img/data_structure_algorithm_note_33_crop_11.jpg	the node that replaces you in the list
crop_img/data_structure_algorithm_note_33_crop_12.jpg	}
crop_img/data_structure_algorithm_note_33_crop_13.jpg	3
crop_img/data_structure_algorithm_note_33_crop_14.jpg	3
crop_img/data_structure_algorithm_note_33_crop_15.jpg	4
crop_img/data_structure_algorithm_note_33_crop_16.jpg	private Node<T>(rRemoveNode<T> curr) {
crop_img/data_structure_algorithm_note_33_crop_17.jpg	5
crop_img/data_structure_algorithm_note_33_crop_18.jpg	6
crop_img/data_structure_algorithm_note_33_crop_19.jpg	if(curr == null){
crop_img/data_structure_algorithm_note_33_crop_20.jpg	Base case
crop_img/data_structure_algorithm_note_33_crop_21.jpg	7
crop_img/data_structure_algorithm_note_33_crop_22.jpg	return null;
crop_img/data_structure_algorithm_note_33_crop_23.jpg	return the node that replaces curr.next
crop_img/data_structure_algorithm_note_33_crop_24.jpg	}
crop_img/data_structure_algorithm_note_33_crop_25.jpg	8
crop_img/data_structure_algorithm_note_33_crop_26.jpg	in the list (recursive step)
crop_img/data_structure_algorithm_note_33_crop_27.jpg	9
crop_img/data_structure_algorithm_note_33_crop_28.jpg	curr.next = rRemove(curr.next);
crop_img/data_structure_algorithm_note_33_crop_29.jpg	10
crop_img/data_structure_algorithm_note_33_crop_30.jpg	if (curr.next != null
crop_img/data_structure_algorithm_note_33_crop_31.jpg	11
crop_img/data_structure_algorithm_note_33_crop_32.jpg	&& curr.data.equals(curr.next.data) {
crop_img/data_structure_algorithm_note_33_crop_33.jpg	12
crop_img/data_structure_algorithm_note_33_crop_34.jpg	return curr.next;
crop_img/data_structure_algorithm_note_33_crop_35.jpg	condition for curr to be in the list
crop_img/data_structure_algorithm_note_33_crop_36.jpg	13
crop_img/data_structure_algorithm_note_33_crop_37.jpg	}
crop_img/data_structure_algorithm_note_33_crop_38.jpg	14
crop_img/data_structure_algorithm_note_33_crop_39.jpg	return curr;
crop_img/data_structure_algorithm_note_33_crop_40.jpg	15
crop_img/data_structure_algorithm_note_33_crop_41.jpg	}
crop_img/data_structure_algorithm_note_33_crop_42.jpg	only remove / add from top
crop_img/data_structure_algorithm_note_33_crop_43.jpg	0
crop_img/data_structure_algorithm_note_33_crop_44.jpg	) Stack :
crop_img/data_structure_algorithm_note_33_crop_45.jpg	。
crop_img/data_structure_algorithm_note_33_crop_46.jpg	0
crop_img/data_structure_algorithm_note_33_crop_47.jpg	0
crop_img/data_structure_algorithm_note_33_crop_48.jpg	0。0
crop_img/data_structure_algorithm_note_33_crop_49.jpg	. Data at the bottom stay in the stack the longest (Last In First
crop_img/data_structure_algorithm_note_33_crop_50.jpg	Out - LIFO)
crop_img/data_structure_algorithm_note_33_crop_51.jpg	push () := addTop ()
crop_img/data_structure_algorithm_note_33_crop_52.jpg	pop()
crop_img/data_structure_algorithm_note_33_crop_53.jpg	=remove Top()
crop_img/data_structure_algorithm_note_33_crop_54.jpg	peek () : = get Top
crop_img/data_structure_algorithm_note_33_crop_55.jpg	Problem : don't have add Index () and rem Index()
crop_img/data_structure_algorithm_note_34_crop_0.jpg	head
crop_img/data_structure_algorithm_note_34_crop_1.jpg	tail
crop_img/data_structure_algorithm_note_34_crop_2.jpg	back:
crop_img/data_structure_algorithm_note_34_crop_3.jpg	backing Linked list is tail
crop_img/data_structure_algorithm_note_34_crop_4.jpg	front:
crop_img/data_structure_algorithm_note_34_crop_5.jpg	backing linked list is head
crop_img/data_structure_algorithm_note_34_crop_6.jpg	enqueue () := add Back With Tail ()
crop_img/data_structure_algorithm_note_34_crop_7.jpg	dequeue () := rem Front ()
crop_img/data_structure_algorithm_note_35_crop_0.jpg	(circular Array)
crop_img/data_structure_algorithm_note_35_crop_1.jpg	Array Queue
crop_img/data_structure_algorithm_note_35_crop_2.jpg	个
crop_img/data_structure_algorithm_note_35_crop_3.jpg	front
crop_img/data_structure_algorithm_note_35_crop_4.jpg	Backing DS is circular Array with front index
crop_img/data_structure_algorithm_note_35_crop_5.jpg	.back=(front + size-1)% backing Arr.length
crop_img/data_structure_algorithm_note_35_crop_6.jpg	When resize backing Arr set front back to 0
crop_img/data_structure_algorithm_note_35_crop_7.jpg	enqueue (index(front+size)%backingArr.length)
crop_img/data_structure_algorithm_note_35_crop_8.jpg	dequeue():
crop_img/data_structure_algorithm_note_35_crop_9.jpg	Set front's data to null
crop_img/data_structure_algorithm_note_35_crop_10.jpg	front :=(front +1)% backing Arr.length
crop_img/data_structure_algorithm_note_35_crop_11.jpg	addBack()
crop_img/data_structure_algorithm_note_35_crop_12.jpg	add Front ()
crop_img/data_structure_algorithm_note_35_crop_13.jpg	Deque:
crop_img/data_structure_algorithm_note_35_crop_14.jpg	remFront()
crop_img/data_structure_algorithm_note_35_crop_15.jpg	rem Back ()
crop_img/data_structure_algorithm_note_35_crop_16.jpg	) linked Deque: Have to deal with o(n) method (remove back())
crop_img/data_structure_algorithm_note_35_crop_17.jpg	using sLL
crop_img/data_structure_algorithm_note_35_crop_18.jpg	→ Use as the backing DS
crop_img/data_structure_algorithm_note_35_crop_19.jpg	) Array Deque : Use circular Array as the backing DS
crop_img/data_structure_algorithm_note_35_crop_20.jpg	) Trees : Fix a tree if it is loop-free and has no cycles
crop_img/data_structure_algorithm_note_35_crop_21.jpg	parent
crop_img/data_structure_algorithm_note_35_crop_22.jpg	0
crop_img/data_structure_algorithm_note_35_crop_23.jpg	parent & child.
crop_img/data_structure_algorithm_note_35_crop_24.jpg	8 child
crop_img/data_structure_algorithm_note_35_crop_25.jpg	. A node can have any # of children
crop_img/data_structure_algorithm_note_35_crop_26.jpg	Exactly 1 node with no parent
crop_img/data_structure_algorithm_note_36_crop_0.jpg	) leaf: Node that has 0 children
crop_img/data_structure_algorithm_note_36_crop_1.jpg	(BT)
crop_img/data_structure_algorithm_note_36_crop_2.jpg	Binary Tree: Each node has at most 2 children: "left" and “right"
crop_img/data_structure_algorithm_note_36_crop_3.jpg	.Full bT: each node has exactly 0 or 2 children
crop_img/data_structure_algorithm_note_36_crop_4.jpg	. Complete BT: satisfy 2 conditions:
crop_img/data_structure_algorithm_note_36_crop_5.jpg	① Each depth of the tree except the lowest depth must have
crop_img/data_structure_algorithm_note_36_crop_6.jpg	maximum # nodes
crop_img/data_structure_algorithm_note_36_crop_7.jpg	2 lowest depth must be filled from left→right
crop_img/data_structure_algorithm_note_36_crop_8.jpg	For each n there is exactly one shape a complete tree has
crop_img/data_structure_algorithm_note_36_crop_9.jpg	Balanced bT: A node is balanced if its children have height that
crop_img/data_structure_algorithm_note_36_crop_10.jpg	differ by 0 or 1. A tree is balanced if every node is balanced
crop_img/data_structure_algorithm_note_36_crop_11.jpg	) binary search Tree (bst) :A binary tree where for a node with
crop_img/data_structure_algorithm_note_36_crop_12.jpg	data x, all the data in the left subtree <x and all the data
crop_img/data_structure_algorithm_note_36_crop_13.jpg	in the right subtree >x.
crop_img/data_structure_algorithm_note_36_crop_14.jpg	0) pre-order traversal: parent → left sub-tree→right sub-tree
crop_img/data_structure_algorithm_note_36_crop_15.jpg	4
crop_img/data_structure_algorithm_note_36_crop_16.jpg	Ex :
crop_img/data_structure_algorithm_note_36_crop_17.jpg	→（4，2，13，6，5，7）
crop_img/data_structure_algorithm_note_36_crop_18.jpg	α
crop_img/data_structure_algorithm_note_36_crop_19.jpg	6
crop_img/data_structure_algorithm_note_36_crop_20.jpg	>
crop_img/data_structure_algorithm_note_36_crop_21.jpg	/
crop_img/data_structure_algorithm_note_36_crop_22.jpg	V
crop_img/data_structure_algorithm_note_36_crop_23.jpg	3
crop_img/data_structure_algorithm_note_36_crop_24.jpg	5
crop_img/data_structure_algorithm_note_36_crop_25.jpg	7
crop_img/data_structure_algorithm_note_36_crop_26.jpg	In-order traversal is unique
crop_img/data_structure_algorithm_note_36_crop_27.jpg	.
crop_img/data_structure_algorithm_note_36_crop_28.jpg	In-order traversal: left sub-tree → parent → right sub-tree
crop_img/data_structure_algorithm_note_37_crop_0.jpg	→（1，2，3，4，5，6，7）
crop_img/data_structure_algorithm_note_37_crop_1.jpg	Ex:
crop_img/data_structure_algorithm_note_37_crop_2.jpg	\
crop_img/data_structure_algorithm_note_37_crop_3.jpg	×
crop_img/data_structure_algorithm_note_37_crop_4.jpg	2
crop_img/data_structure_algorithm_note_37_crop_5.jpg	6
crop_img/data_structure_algorithm_note_37_crop_6.jpg	ordered
crop_img/data_structure_algorithm_note_37_crop_7.jpg	7
crop_img/data_structure_algorithm_note_37_crop_8.jpg	5
crop_img/data_structure_algorithm_note_37_crop_9.jpg	→This outputs ordered list of data
crop_img/data_structure_algorithm_note_37_crop_10.jpg	) post-order traversal: left sub-tree→right sub-tree → parent
crop_img/data_structure_algorithm_note_37_crop_11.jpg	Ex :
crop_img/data_structure_algorithm_note_37_crop_12.jpg	→(1,3，2,5,7,6,4)
crop_img/data_structure_algorithm_note_37_crop_13.jpg	4
crop_img/data_structure_algorithm_note_37_crop_14.jpg	2
crop_img/data_structure_algorithm_note_37_crop_15.jpg	6
crop_img/data_structure_algorithm_note_37_crop_16.jpg	一
crop_img/data_structure_algorithm_note_37_crop_17.jpg	5
crop_img/data_structure_algorithm_note_37_crop_18.jpg	7
crop_img/data_structure_algorithm_note_37_crop_19.jpg	)The Operations:
crop_img/data_structure_algorithm_note_37_crop_20.jpg	contains():
crop_img/data_structure_algorithm_note_37_crop_21.jpg	.If data > curr Node.data : search right
crop_img/data_structure_algorithm_note_37_crop_22.jpg	data < curr Node.data : search left
crop_img/data_structure_algorithm_note_37_crop_23.jpg	If
crop_img/data_structure_algorithm_note_37_crop_24.jpg	9
crop_img/data_structure_algorithm_note_37_crop_25.jpg	Worst case:
crop_img/data_structure_algorithm_note_37_crop_26.jpg	V
crop_img/data_structure_algorithm_note_37_crop_27.jpg	→O(n)
crop_img/data_structure_algorithm_note_37_crop_28.jpg	Generally runtime is O(log n)
crop_img/data_structure_algorithm_note_37_crop_29.jpg	. add() : Any data can be added to leaf position
crop_img/data_structure_algorithm_note_38_crop_0.jpg	.If data > curr Node.data: go right
crop_img/data_structure_algorithm_note_38_crop_1.jpg	If data < curr Node.data ; go left
crop_img/data_structure_algorithm_note_38_crop_2.jpg	public void Add(T data)
crop_img/data_structure_algorithm_note_38_crop_3.jpg	(caution note replaces curr
crop_img/data_structure_algorithm_note_38_crop_4.jpg	root = addH(root, data)
crop_img/data_structure_algorithm_note_38_crop_5.jpg	path reinforcement
crop_img/data_structure_algorithm_note_38_crop_6.jpg	private Node addH(Node curr,T data):
crop_img/data_structure_algorithm_note_38_crop_7.jpg	if curr == null:
crop_img/data_structure_algorithm_note_38_crop_8.jpg	Node newNode = new Node(data)
crop_img/data_structure_algorithm_note_38_crop_9.jpg	replace null w/ new Node
crop_img/data_structure_algorithm_note_38_crop_10.jpg	return newNode
crop_img/data_structure_algorithm_note_38_crop_11.jpg	if curr.data == data:
crop_img/data_structure_algorithm_note_38_crop_12.jpg	//do nothing, data already in tree
crop_img/data_structure_algorithm_note_38_crop_13.jpg	if curr.data < data:
crop_img/data_structure_algorithm_note_38_crop_14.jpg	//recurse right
crop_img/data_structure_algorithm_note_38_crop_15.jpg	curr.right = addH(curr.right, data)
crop_img/data_structure_algorithm_note_38_crop_16.jpg	if curr.data > data:
crop_img/data_structure_algorithm_note_38_crop_17.jpg	//recurse left
crop_img/data_structure_algorithm_note_38_crop_18.jpg	curr.left = addH(curr.left, data)
crop_img/data_structure_algorithm_note_38_crop_19.jpg	return curr
crop_img/data_structure_algorithm_note_38_crop_20.jpg	• remove(): There are 3 cases:
crop_img/data_structure_algorithm_note_38_crop_21.jpg	. Case 1: The removed data has no children:
crop_img/data_structure_algorithm_note_38_crop_22.jpg	. Path reinforcement:
crop_img/data_structure_algorithm_note_38_crop_23.jpg	currNode.data == data : return null
crop_img/data_structure_algorithm_note_38_crop_24.jpg	1 child
crop_img/data_structure_algorithm_note_38_crop_25.jpg	Case 2: The
crop_img/data_structure_algorithm_note_38_crop_26.jpg	. Path reinforcement:
crop_img/data_structure_algorithm_note_38_crop_27.jpg	if currNode.data == data: return currNode.nextNode
crop_img/data_structure_algorithm_note_38_crop_28.jpg	.Case 3: The
crop_img/data_structure_algorithm_note_38_crop_29.jpg	2 children:
crop_img/data_structure_algorithm_note_38_crop_30.jpg	Find the node containing the data using path reinforcement
crop_img/data_structure_algorithm_note_38_crop_31.jpg	. Delete the node's data
crop_img/data_structure_algorithm_note_38_crop_32.jpg	Replace with its successor
crop_img/data_structure_algorithm_note_38_crop_33.jpg	predecessor
crop_img/data_structure_algorithm_note_38_crop_34.jpg	smallest
crop_img/data_structure_algorithm_note_38_crop_35.jpg	largest
crop_img/data_structure_algorithm_note_38_crop_36.jpg	data >
crop_img/data_structure_algorithm_note_38_crop_37.jpg	data < curr.data
crop_img/data_structure_algorithm_note_38_crop_38.jpg	curr.data
crop_img/data_structure_algorithm_note_38_crop_39.jpg	Remove the sides (left or right child this time)
crop_img/data_structure_algorithm_note_39_crop_0.jpg	action node
crop_img/data_structure_algorithm_note_39_crop_1.jpg	public T remove(T data):
crop_img/data_structure_algorithm_note_39_crop_2.jpg	Node dummy = new Node(null)
crop_img/data_structure_algorithm_note_39_crop_3.jpg	root = removeH(root, data, dummy)
crop_img/data_structure_algorithm_note_39_crop_4.jpg	replies cur
crop_img/data_structure_algorithm_note_39_crop_5.jpg	return dummy.data
crop_img/data_structure_algorithm_note_39_crop_6.jpg	private Node removeH(Node curr, T data, Node dummy):
crop_img/data_structure_algorithm_note_39_crop_7.jpg	if curr == null:
crop_img/data_structure_algorithm_note_39_crop_8.jpg	//data not in tree
crop_img/data_structure_algorithm_note_39_crop_9.jpg	throw exception
crop_img/data_structure_algorithm_note_39_crop_10.jpg	if curr.data < data:
crop_img/data_structure_algorithm_note_39_crop_11.jpg	//recurse right
crop_img/data_structure_algorithm_note_39_crop_12.jpg	if curr.data > data:
crop_img/data_structure_algorithm_note_39_crop_13.jpg	//recurse left
crop_img/data_structure_algorithm_note_39_crop_14.jpg	if curr.data == data:
crop_img/data_structure_algorithm_note_39_crop_15.jpg	dummy.data = curr.data
crop_img/data_structure_algorithm_note_39_crop_16.jpg	if curr has 0 kids:
crop_img/data_structure_algorithm_note_39_crop_17.jpg	return null
crop_img/data_structure_algorithm_note_39_crop_18.jpg	if curr has 1 kid:
crop_img/data_structure_algorithm_note_39_crop_19.jpg	return curr.kid
crop_img/data_structure_algorithm_note_39_crop_20.jpg	if curr has 2 kids:
crop_img/data_structure_algorithm_note_39_crop_21.jpg	//get predecessor
crop_img/data_structure_algorithm_note_39_crop_22.jpg	1L++
crop_img/data_structure_algorithm_note_39_crop_23.jpg	Node dummy2 = new Node(null)
crop_img/data_structure_algorithm_note_39_crop_24.jpg	curr.left = trecor(curr.left, dummy2)
crop_img/data_structure_algorithm_note_39_crop_25.jpg	PO
crop_img/data_structure_algorithm_note_39_crop_26.jpg	to Remove
crop_img/data_structure_algorithm_note_39_crop_27.jpg	of
crop_img/data_structure_algorithm_note_39_crop_28.jpg	curr.data = dummy2.data
crop_img/data_structure_algorithm_note_39_crop_29.jpg	return curr
crop_img/data_structure_algorithm_note_39_crop_30.jpg	as Ras possible
crop_img/data_structure_algorithm_note_39_crop_31.jpg	return the node replacing curr
crop_img/data_structure_algorithm_note_39_crop_32.jpg	private Node getPredecessor(Node curr, Node dummy):
crop_img/data_structure_algorithm_note_39_crop_33.jpg	ptn reinforcement
crop_img/data_structure_algorithm_note_39_crop_34.jpg	//find the rightmost descendant
crop_img/data_structure_algorithm_note_39_crop_35.jpg	if curr.right = null: atr iN
crop_img/data_structure_algorithm_note_39_crop_36.jpg	//found predecessor
crop_img/data_structure_algorithm_note_39_crop_37.jpg	as well
crop_img/data_structure_algorithm_note_39_crop_38.jpg	dummy.data = curr.data
crop_img/data_structure_algorithm_note_39_crop_39.jpg	return curr.left
crop_img/data_structure_algorithm_note_39_crop_40.jpg	cever trich to return more
crop_img/data_structure_algorithm_note_39_crop_41.jpg	else:
crop_img/data_structure_algorithm_note_39_crop_42.jpg	curr.right = getPredecessor(curr.right, dummy)
crop_img/data_structure_algorithm_note_39_crop_43.jpg	than one value
crop_img/data_structure_algorithm_note_39_crop_44.jpg	return curr
crop_img/data_structure_algorithm_note_39_crop_45.jpg	PD
crop_img/data_structure_algorithm_note_39_crop_46.jpg	L
crop_img/data_structure_algorithm_note_39_crop_47.jpg	Base case of get fre deeor ( : we want to remove the PD as well)
crop_img/data_structure_algorithm_note_39_crop_48.jpg	therefore the parent of the eo will point to the left (L) node
crop_img/data_structure_algorithm_note_39_crop_49.jpg	instead
crop_img/data_structure_algorithm_note_39_crop_50.jpg	get predecessor will reconnect the path it took through to t
crop_img/data_structure_algorithm_note_39_crop_51.jpg	to the eo of to Remove.
crop_img/data_structure_algorithm_note_39_crop_52.jpg	Reading recursion:
crop_img/data_structure_algorithm_note_39_crop_53.jpg	checking the base case n = b, then check
crop_img/data_structure_algorithm_note_39_crop_54.jpg	the case n = b+ …, until you get the concept
crop_img/data_structure_algorithm_note_40_crop_0.jpg	Heap : A tree data structure where for every node, the value of it
crop_img/data_structure_algorithm_note_40_crop_1.jpg	children is greater or smaller than its own value
crop_img/data_structure_algorithm_note_40_crop_2.jpg	root
crop_img/data_structure_algorithm_note_40_crop_3.jpg	root
crop_img/data_structure_algorithm_note_40_crop_4.jpg	Max Heap:
crop_img/data_structure_algorithm_note_40_crop_5.jpg	decreasing
crop_img/data_structure_algorithm_note_40_crop_6.jpg	Min Heap:
crop_img/data_structure_algorithm_note_40_crop_7.jpg	increasing
crop_img/data_structure_algorithm_note_40_crop_8.jpg	8
crop_img/data_structure_algorithm_note_40_crop_9.jpg	八
crop_img/data_structure_algorithm_note_40_crop_10.jpg	Heap is a complete tree
crop_img/data_structure_algorithm_note_40_crop_11.jpg	order: for a max heap node with greater value has higher order
crop_img/data_structure_algorithm_note_40_crop_12.jpg	min heap)
crop_img/data_structure_algorithm_note_40_crop_13.jpg	smaller
crop_img/data_structure_algorithm_note_40_crop_14.jpg	parent has higher order than children
crop_img/data_structure_algorithm_note_40_crop_15.jpg	Backing os : array (because there is no gaps between data)
crop_img/data_structure_algorithm_note_40_crop_16.jpg	Storing data of a heap into array : use level-order traversal
crop_img/data_structure_algorithm_note_40_crop_17.jpg	the 0-index element is null
crop_img/data_structure_algorithm_note_40_crop_18.jpg	let A be the backing array
crop_img/data_structure_algorithm_note_40_crop_19.jpg	add ( ):
crop_img/data_structure_algorithm_note_40_crop_20.jpg	① A. add Back() → now heap may be out-of-order
crop_img/data_structure_algorithm_note_40_crop_21.jpg	② Up heap:
crop_img/data_structure_algorithm_note_40_crop_22.jpg	while new Node has higher order than parent
crop_img/data_structure_algorithm_note_40_crop_23.jpg	swap (new Node, parent)
crop_img/data_structure_algorithm_note_40_crop_24.jpg	if new Node is root:
crop_img/data_structure_algorithm_note_40_crop_25.jpg	break
crop_img/data_structure_algorithm_note_40_crop_26.jpg	remove (): remove root (highest order)
crop_img/data_structure_algorithm_note_40_crop_27.jpg	① remove 
crop_img/data_structure_algorithm_note_40_crop_28.jpg	② move A [exit]
crop_img/data_structure_algorithm_note_40_crop_29.jpg	to index I → new Node
crop_img/data_structure_algorithm_note_41_crop_0.jpg	③
crop_img/data_structure_algorithm_note_41_crop_1.jpg	Down heap:
crop_img/data_structure_algorithm_note_41_crop_2.jpg	while new Node has lower order than its children
crop_img/data_structure_algorithm_note_41_crop_3.jpg	if only 1 bad child :
crop_img/data_structure_algorithm_note_41_crop_4.jpg	swap (new Node, bad child)
crop_img/data_structure_algorithm_note_41_crop_5.jpg	if 2 bad children :
crop_img/data_structure_algorithm_note_41_crop_6.jpg	swap (new Node, bad child with higher order
crop_img/data_structure_algorithm_note_41_crop_7.jpg	if new Node is leaf (have 0 children):
crop_img/data_structure_algorithm_note_41_crop_8.jpg	break
crop_img/data_structure_algorithm_note_41_crop_9.jpg	starting from right → left
crop_img/data_structure_algorithm_note_41_crop_10.jpg	build heap() :
crop_img/data_structure_algorithm_note_41_crop_11.jpg	V
crop_img/data_structure_algorithm_note_41_crop_12.jpg	for each internal node in reverse order level:
crop_img/data_structure_algorithm_note_41_crop_13.jpg	down Heap (V)
crop_img/data_structure_algorithm_note_41_crop_14.jpg	Runtime : O(n)
crop_img/data_structure_algorithm_note_41_crop_15.jpg	HashMap: A data structure that stores (key, value) pairs
crop_img/data_structure_algorithm_note_41_crop_16.jpg	let M be a hashmap
crop_img/data_structure_algorithm_note_41_crop_17.jpg	Rules: keys must be unique and immutable
crop_img/data_structure_algorithm_note_41_crop_18.jpg	put (key, val) : t (key, value) pair into M if y ready
crop_img/data_structure_algorithm_note_41_crop_19.jpg	existed, replace old value with new input value
crop_img/data_structure_algorithm_note_41_crop_20.jpg	get (key)
crop_img/data_structure_algorithm_note_41_crop_21.jpg	): return a associated value
crop_img/data_structure_algorithm_note_41_crop_22.jpg	We want put () and get() to be o(1) hash model and backing array
crop_img/data_structure_algorithm_note_41_crop_23.jpg	hash value
crop_img/data_structure_algorithm_note_41_crop_24.jpg	hashcode(): map data of arbitrary size to a fixed-size value
crop_img/data_structure_algorithm_note_41_crop_25.jpg	Two objects are equal if they have the same hash value
crop_img/data_structure_algorithm_note_41_crop_26.jpg	Reference: a diff object have diff hash code
crop_img/data_structure_algorithm_note_41_crop_27.jpg	,index=/object . hashCode() l。 A,len 1
crop_img/data_structure_algorithm_note_42_crop_0.jpg	. collision: put a diff
crop_img/data_structure_algorithm_note_42_crop_1.jpg	keys into the same spot of backing array
crop_img/data_structure_algorithm_note_42_crop_2.jpg	good hash code () can reduce this
crop_img/data_structure_algorithm_note_42_crop_3.jpg	increase size of backing array
crop_img/data_structure_algorithm_note_42_crop_4.jpg	# items
crop_img/data_structure_algorithm_note_42_crop_5.jpg	Load factor: a value indicate when to re size, i.e. when
crop_img/data_structure_algorithm_note_42_crop_6.jpg	A.len
crop_img/data_structure_algorithm_note_42_crop_7.jpg	≥load factor
crop_img/data_structure_algorithm_note_42_crop_8.jpg	. Resize: when doing resize, changes so indices of keys must
crop_img/data_structure_algorithm_note_42_crop_9.jpg	be recalculated
crop_img/data_structure_algorithm_note_42_crop_10.jpg	• Open addressing: 1 item per index → linear/Quadratic probing
crop_img/data_structure_algorithm_note_42_crop_11.jpg	Closed addressing: ≥a items per index → External chaining
crop_img/data_structure_algorithm_note_42_crop_12.jpg	no back ta
crop_img/data_structure_algorithm_note_42_crop_13.jpg	L
crop_img/data_structure_algorithm_note_42_crop_14.jpg	. External chaining: one index hold a linked list
crop_img/data_structure_algorithm_note_42_crop_15.jpg	put () → 0(n) (adding to back)
crop_img/data_structure_algorithm_note_42_crop_16.jpg	rebite cost ; o(n)
crop_img/data_structure_algorithm_note_42_crop_17.jpg	Linear/Quadratic probing: keep track of deleted items (De mark)
crop_img/data_structure_algorithm_note_42_crop_18.jpg	put (): stop when seeing non-removed entry
crop_img/data_structure_algorithm_note_42_crop_19.jpg	(*)
crop_img/data_structure_algorithm_note_42_crop_20.jpg	not meeting removed entry with key-value
crop_img/data_structure_algorithm_note_42_crop_21.jpg	① Compute id
crop_img/data_structure_algorithm_note_42_crop_22.jpg	2
crop_img/data_structure_algorithm_note_42_crop_23.jpg	At id:
crop_img/data_structure_algorithm_note_42_crop_24.jpg	if key already existed: update value
crop_img/data_structure_algorithm_note_42_crop_25.jpg	if diff keys
crop_img/data_structure_algorithm_note_42_crop_26.jpg	probe right (id +=1)
crop_img/data_structure_algorithm_note_42_crop_27.jpg	手
crop_img/data_structure_algorithm_note_42_crop_28.jpg	DEL
crop_img/data_structure_algorithm_note_42_crop_29.jpg	remember if it the last one
crop_img/data_structure_algorithm_note_42_crop_30.jpg	：
crop_img/data_structure_algorithm_note_42_crop_31.jpg	null
crop_img/data_structure_algorithm_note_42_crop_32.jpg	if int DEL =null : put key here
crop_img/data_structure_algorithm_note_42_crop_33.jpg	else: put key into last DEL
crop_img/data_structure_algorithm_note_43_crop_0.jpg	Runtime : Worst case O(n)
crop_img/data_structure_algorithm_note_43_crop_1.jpg	get () :(*)
crop_img/data_structure_algorithm_note_43_crop_2.jpg	④
crop_img/data_structure_algorithm_note_43_crop_3.jpg	Compute id
crop_img/data_structure_algorithm_note_43_crop_4.jpg	②
crop_img/data_structure_algorithm_note_43_crop_5.jpg	At id:
crop_img/data_structure_algorithm_note_43_crop_6.jpg	if keys are same : return key's value
crop_img/data_structure_algorithm_note_43_crop_7.jpg	if diff key: probe right
crop_img/data_structure_algorithm_note_43_crop_8.jpg	守
crop_img/data_structure_algorithm_note_43_crop_9.jpg	DEL : probe right
crop_img/data_structure_algorithm_note_43_crop_10.jpg	null : stop) not found
crop_img/data_structure_algorithm_note_43_crop_11.jpg	Runtime : Worst case o(n)
crop_img/data_structure_algorithm_note_43_crop_12.jpg	resize: everything can collide after resize→ o(n)
crop_img/data_structure_algorithm_note_43_crop_13.jpg	Quadratic probing can help reduce runtime by creating gap, but
crop_img/data_structure_algorithm_note_43_crop_14.jpg	this causes searching for empty space to put items in inefficient
crop_img/data_structure_algorithm_note_43_crop_15.jpg	·What do we do when we cannot find an empty space? resize (not once)
crop_img/data_structure_algorithm_note_43_crop_16.jpg	ara.len
crop_img/data_structure_algorithm_note_43_crop_17.jpg	? After that the indices
crop_img/data_structure_algorithm_note_43_crop_18.jpg	. Why the max # attempts in
crop_img/data_structure_algorithm_note_43_crop_19.jpg	2
crop_img/data_structure_algorithm_note_43_crop_20.jpg	will start repeating
crop_img/data_structure_algorithm_note_43_crop_21.jpg	the size once may not be enough
crop_img/data_structure_algorithm_note_43_crop_22.jpg	Skiplist: 2d linked list where a node has 4 ptrs : next, previous)
crop_img/data_structure_algorithm_note_43_crop_23.jpg	above, below
crop_img/data_structure_algorithm_note_43_crop_24.jpg	. Rules:
crop_img/data_structure_algorithm_note_43_crop_25.jpg	① All data must be in lowest level
crop_img/data_structure_algorithm_note_43_crop_26.jpg	② If in level, must be lower levels no data can fall between 
crop_img/data_structure_algorithm_note_43_crop_27.jpg	empty levels)
crop_img/data_structure_algorithm_note_43_crop_28.jpg	. contains()
crop_img/data_structure_algorithm_note_43_crop_29.jpg	if data > curr's data ; go right
crop_img/data_structure_algorithm_note_43_crop_30.jpg	else if data 
crop_img/data_structure_algorithm_note_43_crop_31.jpg	: go down
crop_img/data_structure_algorithm_note_44_crop_0.jpg	if hit null : not in list
crop_img/data_structure_algorithm_note_44_crop_1.jpg	add ( : most left word item is -a)most right full item is 
crop_img/data_structure_algorithm_note_44_crop_2.jpg	① Flip coin
crop_img/data_structure_algorithm_note_44_crop_3.jpg	② if head :# layers t=s (add on top)
crop_img/data_structure_algorithm_note_44_crop_4.jpg	if tail: start adding
crop_img/data_structure_algorithm_note_44_crop_5.jpg	Adding : if data > arr's data: go right
crop_img/data_structure_algorithm_note_44_crop_6.jpg	B
crop_img/data_structure_algorithm_note_44_crop_7.jpg	if data < arr's data:
crop_img/data_structure_algorithm_note_44_crop_8.jpg	add before arr
crop_img/data_structure_algorithm_note_44_crop_9.jpg	go up
crop_img/data_structure_algorithm_note_44_crop_10.jpg	continue until fall out of the list
crop_img/data_structure_algorithm_note_44_crop_11.jpg	remove (): similar to contains (), but after found and remove
crop_img/data_structure_algorithm_note_44_crop_12.jpg	the element at the current level, go down and repeat until fall
crop_img/data_structure_algorithm_note_44_crop_13.jpg	out of list
crop_img/data_structure_algorithm_note_44_crop_14.jpg	Runtime:
crop_img/data_structure_algorithm_note_44_crop_15.jpg	for add () : random
crop_img/data_structure_algorithm_note_44_crop_16.jpg	for contains():
crop_img/data_structure_algorithm_note_44_crop_17.jpg	. Best case is similar to BST → o(log n)
crop_img/data_structure_algorithm_note_44_crop_18.jpg	horizontal (all HEAD)
crop_img/data_structure_algorithm_note_44_crop_19.jpg	. Worst case: all data is in a single linked list
crop_img/data_structure_algorithm_note_44_crop_20.jpg	vertical (all TAILs)
crop_img/data_structure_algorithm_note_44_crop_21.jpg	0(n)
crop_img/data_structure_algorithm_note_44_crop_22.jpg	=7
crop_img/data_structure_algorithm_note_44_crop_23.jpg	for remove(): o(n)
crop_img/data_structure_algorithm_note_44_crop_24.jpg	)AVL: self-balancing binary search tree
crop_img/data_structure_algorithm_note_44_crop_25.jpg	.Balance: A node is balanced if its children have height diff by 0
crop_img/data_structure_algorithm_note_44_crop_26.jpg	or 1. A tree containing all balanced nodes is balanced
crop_img/data_structure_algorithm_note_44_crop_27.jpg	. null node
crop_img/data_structure_algorithm_note_44_crop_28.jpg	has height -1
crop_img/data_structure_algorithm_note_45_crop_0.jpg	BF
crop_img/data_structure_algorithm_note_45_crop_1.jpg	. Balance factor := node.left.height - node.right.height
crop_img/data_structure_algorithm_note_45_crop_2.jpg	.BF ∈ {-1, 0, 1}
crop_img/data_structure_algorithm_note_45_crop_3.jpg	root, bf = a → lean too much to the left
crop_img/data_structure_algorithm_note_45_crop_4.jpg	Ex:
crop_img/data_structure_algorithm_note_45_crop_5.jpg	Q
crop_img/data_structure_algorithm_note_45_crop_6.jpg	-1
crop_img/data_structure_algorithm_note_45_crop_7.jpg	心
crop_img/data_structure_algorithm_note_45_crop_8.jpg	Fixing unbalanced sub tree: Let A, B, C form a sub tree
crop_img/data_structure_algorithm_note_45_crop_9.jpg	we have 4 cases
crop_img/data_structure_algorithm_note_45_crop_10.jpg	① Rotate left:
crop_img/data_structure_algorithm_note_45_crop_11.jpg	A.BF = -∂
crop_img/data_structure_algorithm_note_45_crop_12.jpg	-2
crop_img/data_structure_algorithm_note_45_crop_13.jpg	A.right.BF = -1
crop_img/data_structure_algorithm_note_45_crop_14.jpg	A
crop_img/data_structure_algorithm_note_45_crop_15.jpg	-1
crop_img/data_structure_algorithm_note_45_crop_16.jpg	B
crop_img/data_structure_algorithm_note_45_crop_17.jpg	0
crop_img/data_structure_algorithm_note_45_crop_18.jpg	C
crop_img/data_structure_algorithm_note_45_crop_19.jpg	Note that height and BF of C
crop_img/data_structure_algorithm_note_45_crop_20.jpg	B
crop_img/data_structure_algorithm_note_45_crop_21.jpg	Q
crop_img/data_structure_algorithm_note_45_crop_22.jpg	Rotate left
crop_img/data_structure_algorithm_note_45_crop_23.jpg	doesn't change → only need to
crop_img/data_structure_algorithm_note_45_crop_24.jpg	C
crop_img/data_structure_algorithm_note_45_crop_25.jpg	A
crop_img/data_structure_algorithm_note_45_crop_26.jpg	O
crop_img/data_structure_algorithm_note_45_crop_27.jpg	update B and A
crop_img/data_structure_algorithm_note_45_crop_28.jpg	A
crop_img/data_structure_algorithm_note_45_crop_29.jpg	D
crop_img/data_structure_algorithm_note_45_crop_30.jpg	B
crop_img/data_structure_algorithm_note_45_crop_31.jpg	What if already had 2 children?
crop_img/data_structure_algorithm_note_45_crop_32.jpg	ó
crop_img/data_structure_algorithm_note_45_crop_33.jpg	E
crop_img/data_structure_algorithm_note_45_crop_34.jpg	C
crop_img/data_structure_algorithm_note_45_crop_35.jpg	O
crop_img/data_structure_algorithm_note_45_crop_36.jpg	'
crop_img/data_structure_algorithm_note_45_crop_37.jpg	B
crop_img/data_structure_algorithm_note_45_crop_38.jpg	F
crop_img/data_structure_algorithm_note_45_crop_39.jpg	G
crop_img/data_structure_algorithm_note_45_crop_40.jpg	O
crop_img/data_structure_algorithm_note_45_crop_41.jpg	—→
crop_img/data_structure_algorithm_note_45_crop_42.jpg	. attach left child to
crop_img/data_structure_algorithm_note_45_crop_43.jpg	A
crop_img/data_structure_algorithm_note_45_crop_44.jpg	old root as right child
crop_img/data_structure_algorithm_note_45_crop_45.jpg	E
crop_img/data_structure_algorithm_note_45_crop_46.jpg	D
crop_img/data_structure_algorithm_note_45_crop_47.jpg	F
crop_img/data_structure_algorithm_note_45_crop_48.jpg	tip when coding: Create temp node
crop_img/data_structure_algorithm_note_45_crop_49.jpg	point to B to keep track of what
crop_img/data_structure_algorithm_note_45_crop_50.jpg	2
crop_img/data_structure_algorithm_note_45_crop_51.jpg	Rotate right:
crop_img/data_structure_algorithm_note_45_crop_52.jpg	We want to get win
crop_img/data_structure_algorithm_note_45_crop_53.jpg	. What node need to update? A and B
crop_img/data_structure_algorithm_note_45_crop_54.jpg	A
crop_img/data_structure_algorithm_note_45_crop_55.jpg	2
crop_img/data_structure_algorithm_note_45_crop_56.jpg	O
crop_img/data_structure_algorithm_note_45_crop_57.jpg	B
crop_img/data_structure_algorithm_note_45_crop_58.jpg	1
crop_img/data_structure_algorithm_note_45_crop_59.jpg	A.BF = α
crop_img/data_structure_algorithm_note_45_crop_60.jpg	C
crop_img/data_structure_algorithm_note_45_crop_61.jpg	A.left.BF = 1
crop_img/data_structure_algorithm_note_46_crop_0.jpg	B
crop_img/data_structure_algorithm_note_46_crop_1.jpg	Rotate right
crop_img/data_structure_algorithm_note_46_crop_2.jpg	A
crop_img/data_structure_algorithm_note_46_crop_3.jpg	when B has 2 children:
crop_img/data_structure_algorithm_note_46_crop_4.jpg	B
crop_img/data_structure_algorithm_note_46_crop_5.jpg	D
crop_img/data_structure_algorithm_note_46_crop_6.jpg	C
crop_img/data_structure_algorithm_note_46_crop_7.jpg	F
crop_img/data_structure_algorithm_note_46_crop_8.jpg	6G
crop_img/data_structure_algorithm_note_46_crop_9.jpg	B
crop_img/data_structure_algorithm_note_46_crop_10.jpg	A
crop_img/data_structure_algorithm_note_46_crop_11.jpg	: attach right child to old root
crop_img/data_structure_algorithm_note_46_crop_12.jpg	C
crop_img/data_structure_algorithm_note_46_crop_13.jpg	E
crop_img/data_structure_algorithm_note_46_crop_14.jpg	as left child
crop_img/data_structure_algorithm_note_46_crop_15.jpg	0
crop_img/data_structure_algorithm_note_46_crop_16.jpg	F
crop_img/data_structure_algorithm_note_46_crop_17.jpg	0
crop_img/data_structure_algorithm_note_46_crop_18.jpg	C
crop_img/data_structure_algorithm_note_46_crop_19.jpg	Rotate left-right
crop_img/data_structure_algorithm_note_46_crop_20.jpg	G
crop_img/data_structure_algorithm_note_46_crop_21.jpg	2
crop_img/data_structure_algorithm_note_46_crop_22.jpg	A
crop_img/data_structure_algorithm_note_46_crop_23.jpg	A.BF = 2
crop_img/data_structure_algorithm_note_46_crop_24.jpg	-1B
crop_img/data_structure_algorithm_note_46_crop_25.jpg	A.left.BF = -1
crop_img/data_structure_algorithm_note_46_crop_26.jpg	O
crop_img/data_structure_algorithm_note_46_crop_27.jpg	E
crop_img/data_structure_algorithm_note_46_crop_28.jpg	8G
crop_img/data_structure_algorithm_note_46_crop_29.jpg	F
crop_img/data_structure_algorithm_note_46_crop_30.jpg	Rotate left-right:
crop_img/data_structure_algorithm_note_46_crop_31.jpg	rotate left for sub tree rooted with B, then
crop_img/data_structure_algorithm_note_46_crop_32.jpg	rotate right for sub tree rooted at
crop_img/data_structure_algorithm_note_46_crop_33.jpg	A
crop_img/data_structure_algorithm_note_46_crop_34.jpg	A
crop_img/data_structure_algorithm_note_46_crop_35.jpg	A
crop_img/data_structure_algorithm_note_46_crop_36.jpg	B
crop_img/data_structure_algorithm_note_46_crop_37.jpg	0
crop_img/data_structure_algorithm_note_46_crop_38.jpg	2
crop_img/data_structure_algorithm_note_46_crop_39.jpg	B
crop_img/data_structure_algorithm_note_46_crop_40.jpg	D
crop_img/data_structure_algorithm_note_46_crop_41.jpg	0
crop_img/data_structure_algorithm_note_46_crop_42.jpg	F
crop_img/data_structure_algorithm_note_46_crop_43.jpg	→
crop_img/data_structure_algorithm_note_46_crop_44.jpg	→
crop_img/data_structure_algorithm_note_46_crop_45.jpg	E
crop_img/data_structure_algorithm_note_46_crop_46.jpg	∂
crop_img/data_structure_algorithm_note_46_crop_47.jpg	0
crop_img/data_structure_algorithm_note_46_crop_48.jpg	G
crop_img/data_structure_algorithm_note_46_crop_49.jpg	B
crop_img/data_structure_algorithm_note_46_crop_50.jpg	A
crop_img/data_structure_algorithm_note_46_crop_51.jpg	G
crop_img/data_structure_algorithm_note_46_crop_52.jpg	F
crop_img/data_structure_algorithm_note_46_crop_53.jpg	E
crop_img/data_structure_algorithm_note_46_crop_54.jpg	E
crop_img/data_structure_algorithm_note_46_crop_55.jpg	F
crop_img/data_structure_algorithm_note_46_crop_56.jpg	8G
crop_img/data_structure_algorithm_note_46_crop_57.jpg	0
crop_img/data_structure_algorithm_note_46_crop_58.jpg	©
crop_img/data_structure_algorithm_note_47_crop_0.jpg	Rotate right-left :
crop_img/data_structure_algorithm_note_47_crop_1.jpg	A
crop_img/data_structure_algorithm_note_47_crop_2.jpg	B
crop_img/data_structure_algorithm_note_47_crop_3.jpg	C
crop_img/data_structure_algorithm_note_47_crop_4.jpg	E
crop_img/data_structure_algorithm_note_47_crop_5.jpg	F
crop_img/data_structure_algorithm_note_47_crop_6.jpg	G
crop_img/data_structure_algorithm_note_47_crop_7.jpg	8
crop_img/data_structure_algorithm_note_47_crop_8.jpg	Add( ):
crop_img/data_structure_algorithm_note_47_crop_9.jpg	?
crop_img/data_structure_algorithm_note_47_crop_10.jpg	BST.Add ()
crop_img/data_structure_algorithm_note_47_crop_11.jpg	2
crop_img/data_structure_algorithm_note_47_crop_12.jpg	Update height (from newly add node→ root) can be
crop_img/data_structure_algorithm_note_47_crop_13.jpg	grouped
crop_img/data_structure_algorithm_note_47_crop_14.jpg	Update BF
crop_img/data_structure_algorithm_note_47_crop_15.jpg	③
crop_img/data_structure_algorithm_note_47_crop_16.jpg	together
crop_img/data_structure_algorithm_note_47_crop_17.jpg	④
crop_img/data_structure_algorithm_note_47_crop_18.jpg	Fix unbalanced subtree
crop_img/data_structure_algorithm_note_47_crop_19.jpg	as update()
crop_img/data_structure_algorithm_note_47_crop_20.jpg	. Since the method to fix unbalanced subtree is used
crop_img/data_structure_algorithm_note_47_crop_21.jpg	together with reinforcement, it is more convenient
crop_img/data_structure_algorithm_note_47_crop_22.jpg	to design the method to retain the rebalanced root
crop_img/data_structure_algorithm_note_47_crop_23.jpg	Node rebalance (Node parent)
crop_img/data_structure_algorithm_note_47_crop_24.jpg	Where to put it? When we want to balance a subtree
crop_img/data_structure_algorithm_note_47_crop_25.jpg	rooted at parent where BF of parent = ±α
crop_img/data_structure_algorithm_note_47_crop_26.jpg	→ It makes sure that the children and grandchildren
crop_img/data_structure_algorithm_note_47_crop_27.jpg	node are balanced
crop_img/data_structure_algorithm_note_47_crop_28.jpg	Makes sure that parent's BF is always ±α
crop_img/data_structure_algorithm_note_47_crop_29.jpg	Remove()
crop_img/data_structure_algorithm_note_47_crop_30.jpg	need to remove the Successor/Predecessor
crop_img/data_structure_algorithm_note_47_crop_31.jpg	a
crop_img/data_structure_algorithm_note_47_crop_32.jpg	BST.Remove()
crop_img/data_structure_algorithm_note_47_crop_33.jpg	①
crop_img/data_structure_algorithm_note_47_crop_34.jpg	10 also need to update height/BF here
crop_img/data_structure_algorithm_note_47_crop_35.jpg	②
crop_img/data_structure_algorithm_note_47_crop_36.jpg	Update height (from newly add node→ root)
crop_img/data_structure_algorithm_note_47_crop_37.jpg	3
crop_img/data_structure_algorithm_note_47_crop_38.jpg	Update BF
crop_img/data_structure_algorithm_note_47_crop_39.jpg	④
crop_img/data_structure_algorithm_note_47_crop_40.jpg	Fix unbalanced node
crop_img/data_structure_algorithm_note_47_crop_41.jpg	Runtime: all O(logn)
crop_img/data_structure_algorithm_note_48_crop_0.jpg	2-4 tree: A tree where each node has 1, 2, or 3 data
crop_img/data_structure_algorithm_note_48_crop_1.jpg	# kids = # data + 1
crop_img/data_structure_algorithm_note_48_crop_2.jpg	Shape property: all leaves are at the same depth
crop_img/data_structure_algorithm_note_48_crop_3.jpg	$d1<d2<d3$
crop_img/data_structure_algorithm_note_48_crop_4.jpg	Order property
crop_img/data_structure_algorithm_note_48_crop_5.jpg	$d1$
crop_img/data_structure_algorithm_note_48_crop_6.jpg	d2
crop_img/data_structure_algorithm_note_48_crop_7.jpg	d3
crop_img/data_structure_algorithm_note_48_crop_8.jpg	/
crop_img/data_structure_algorithm_note_48_crop_9.jpg	<d1
crop_img/data_structure_algorithm_note_48_crop_10.jpg	d2<x<d3$
crop_img/data_structure_algorithm_note_48_crop_11.jpg	$d1<x<d2$
crop_img/data_structure_algorithm_note_48_crop_12.jpg	x
crop_img/data_structure_algorithm_note_48_crop_13.jpg	$d1<x<d2$
crop_img/data_structure_algorithm_note_48_crop_14.jpg	2
crop_img/data_structure_algorithm_note_48_crop_15.jpg	t
crop_img/data_structure_algorithm_note_48_crop_16.jpg	九
crop_img/data_structure_algorithm_note_48_crop_17.jpg	t
crop_img/data_structure_algorithm_note_48_crop_18.jpg	Contains ():
crop_img/data_structure_algorithm_note_48_crop_19.jpg	if data<d1: search t1
crop_img/data_structure_algorithm_note_48_crop_20.jpg	else if d1<data<d2: search t2
crop_img/data_structure_algorithm_note_48_crop_21.jpg	else if d2<data<d3: search t3
crop_img/data_structure_algorithm_note_48_crop_22.jpg	else if d3<data: search t4
crop_img/data_structure_algorithm_note_48_crop_23.jpg	Add ():
crop_img/data_structure_algorithm_note_48_crop_24.jpg	① Use contain () to find leaf node
crop_img/data_structure_algorithm_note_48_crop_25.jpg	Add to existing node
crop_img/data_structure_algorithm_note_48_crop_26.jpg	Case: leaf node is already full, adding to it causes overflow
crop_img/data_structure_algorithm_note_48_crop_27.jpg	→ still add, then push and send data to parent → promotion
crop_img/data_structure_algorithm_note_48_crop_28.jpg	→ Split leaf node into 2 new nodes
crop_img/data_structure_algorithm_note_48_crop_29.jpg	.What if parent is overflow? continue doing promotion for
crop_img/data_structure_algorithm_note_48_crop_30.jpg	parent node
crop_img/data_structure_algorithm_note_48_crop_31.jpg	Remove():
crop_img/data_structure_algorithm_note_49_crop_0.jpg	Use contain () to find node containing the data
crop_img/data_structure_algorithm_note_49_crop_1.jpg	Case 1 : data in leaf node with ≥ a data
crop_img/data_structure_algorithm_note_49_crop_2.jpg	→ Just remove
crop_img/data_structure_algorithm_note_49_crop_3.jpg	Case 2 : data in leaf node with only 1 data
crop_img/data_structure_algorithm_note_49_crop_4.jpg	look into sibling nodes to see if they have ≥ 2 data
crop_img/data_structure_algorithm_note_49_crop_5.jpg	If yes then after removing the data in leaf node, move
crop_img/data_structure_algorithm_note_49_crop_6.jpg	parent node to the now-empty leaf node, and push sibling
crop_img/data_structure_algorithm_note_49_crop_7.jpg	data to the place left over by parent
crop_img/data_structure_algorithm_note_49_crop_8.jpg	If no, then we encounter "underflow"
crop_img/data_structure_algorithm_note_49_crop_9.jpg	→ pull data from parent down to now-empty node, then
crop_img/data_structure_algorithm_note_49_crop_10.jpg	merge with sibling → fusion
crop_img/data_structure_algorithm_note_49_crop_11.jpg	What if parent is empty? 2. continuing to fusion in parent node
crop_img/data_structure_algorithm_note_49_crop_12.jpg	data have ≥ 2 data
crop_img/data_structure_algorithm_note_49_crop_13.jpg	Replace data with successor / predecessor
crop_img/data_structure_algorithm_note_49_crop_14.jpg	→ Remove the succ / pred (guaranteed to be in leaf node)
crop_img/data_structure_algorithm_note_49_crop_15.jpg	→ The rest is case 1
crop_img/data_structure_algorithm_note_49_crop_16.jpg	Case 4: data in internal node and succ/pred of data is alone
crop_img/data_structure_algorithm_note_49_crop_17.jpg	in its node
crop_img/data_structure_algorithm_note_49_crop_18.jpg	→ Replace data w/ succ/ pred
crop_img/data_structure_algorithm_note_49_crop_19.jpg	Remove the succ / pred the same way in case 2
crop_img/data_structure_algorithm_note_49_crop_20.jpg	Runtime:
crop_img/data_structure_algorithm_note_49_crop_21.jpg	Contain () : O(log n)
crop_img/data_structure_algorithm_note_49_crop_22.jpg	Add():
crop_img/data_structure_algorithm_note_49_crop_23.jpg	overflow: at most log n overflow → O(log n)
crop_img/data_structure_algorithm_note_51_crop_0.jpg	ALGORITHM
crop_img/data_structure_algorithm_note_51_crop_1.jpg	sorting : there are 3 criteria for sorting algo:
crop_img/data_structure_algorithm_note_51_crop_2.jpg	In-place: Doesn't need additional data structure to sort
crop_img/data_structure_algorithm_note_51_crop_3.jpg	Adaptability: If data is partially sorted, then runtime improves
crop_img/data_structure_algorithm_note_51_crop_4.jpg	Stability : Items with the same value will stay in the
crop_img/data_structure_algorithm_note_51_crop_5.jpg	same relative order after sorting
crop_img/data_structure_algorithm_note_51_crop_6.jpg	In-place and Adaptability are easy to detect
crop_img/data_structure_algorithm_note_51_crop_7.jpg	For Stability: swap only adjacent elements → probably stable
crop_img/data_structure_algorithm_note_51_crop_8.jpg	further apart → probably not stable
crop_img/data_structure_algorithm_note_51_crop_9.jpg	Bubble Sort: For each pair of adjacent items, if out of order, swap
crop_img/data_structure_algorithm_note_51_crop_10.jpg	After i-th iteration, the item in index size-i will be correct
crop_img/data_structure_algorithm_note_51_crop_11.jpg	Optimization:
crop_img/data_structure_algorithm_note_51_crop_12.jpg	keep track of the index of the last item that got swapped → k
crop_img/data_structure_algorithm_note_51_crop_13.jpg	→ For each following iteration, stop at k (indices from k →
crop_img/data_structure_algorithm_note_51_crop_14.jpg	and are correct)
crop_img/data_structure_algorithm_note_51_crop_15.jpg	If no swaps made during an iteration → finish
crop_img/data_structure_algorithm_note_51_crop_16.jpg	In-place, Adapt, and Stable
crop_img/data_structure_algorithm_note_51_crop_17.jpg	Runtime : ∂(n²)
crop_img/data_structure_algorithm_note_51_crop_18.jpg	Insertion Sort: In i-th iteration, put i-th element into the
crop_img/data_structure_algorithm_note_51_crop_19.jpg	sorted portion of the list
crop_img/data_structure_algorithm_note_51_crop_20.jpg	At i-th iteration, indices from 0→i are sorted
crop_img/data_structure_algorithm_note_51_crop_21.jpg	Runtime : O(n²)
crop_img/data_structure_algorithm_note_51_crop_22.jpg	Stable, Adaptive, In-place
crop_img/data_structure_algorithm_note_52_crop_0.jpg	Selection Sort: In i-th iteration, put the i-th largest element to
crop_img/data_structure_algorithm_note_52_crop_1.jpg	correct position
crop_img/data_structure_algorithm_note_52_crop_2.jpg	Actually the one that has the fewest #swaps
crop_img/data_structure_algorithm_note_52_crop_3.jpg	Not stable, Not adaptive, In-place
crop_img/data_structure_algorithm_note_52_crop_4.jpg	Cocktail shaker sort: Run bubble sort from left→right then right
crop_img/data_structure_algorithm_note_52_crop_5.jpg	to left
crop_img/data_structure_algorithm_note_52_crop_6.jpg	the next iteration of BB starts at the element right after
crop_img/data_structure_algorithm_note_52_crop_7.jpg	the last swap position of current BB
crop_img/data_structure_algorithm_note_52_crop_8.jpg	If no swap in one iteration → Finish
crop_img/data_structure_algorithm_note_52_crop_9.jpg	Stable, Adaptive, In-place
crop_img/data_structure_algorithm_note_52_crop_10.jpg	Runtime: O(n²)
crop_img/data_structure_algorithm_note_52_crop_11.jpg	Best iterative sorts: Insertion Sort (fewest compares)
crop_img/data_structure_algorithm_note_52_crop_12.jpg	Heap Sort: Add all data to heap, then remove item by item
crop_img/data_structure_algorithm_note_52_crop_13.jpg	Note: Use build Heap() to add data
crop_img/data_structure_algorithm_note_52_crop_14.jpg	Not Stable, not adaptive, not In-place
crop_img/data_structure_algorithm_note_52_crop_15.jpg	Runtime : O(log n)
crop_img/data_structure_algorithm_note_52_crop_16.jpg	Mergesort: Recursively sort left half, and then right-half and then
crop_img/data_structure_algorithm_note_52_crop_17.jpg	merge left and right halves
crop_img/data_structure_algorithm_note_52_crop_18.jpg	Note: left = data [0:size/2]
crop_img/data_structure_algorithm_note_52_crop_19.jpg	(right - exclusive)
crop_img/data_structure_algorithm_note_52_crop_20.jpg	right = data [size/2: size]
crop_img/data_structure_algorithm_note_52_crop_21.jpg	For merge, create a new temp array to hold the sorted
crop_img/data_structure_algorithm_note_52_crop_22.jpg	elements then copy them into the original portion
crop_img/data_structure_algorithm_note_52_crop_23.jpg	Stable, not adaptive, not In-place
crop_img/data_structure_algorithm_note_53_crop_0.jpg	Fred sort: break data into list of size n, then run insertion sort
crop_img/data_structure_algorithm_note_53_crop_1.jpg	on each list, then merge them into a single sorted list
crop_img/data_structure_algorithm_note_53_crop_2.jpg	Stable, not Adaptive, not In-place
crop_img/data_structure_algorithm_note_53_crop_3.jpg	Runtime: Insertion sorts: O(n)
crop_img/data_structure_algorithm_note_53_crop_4.jpg	Add 1 element to temp and need to compare with n other
crop_img/data_structure_algorithm_note_53_crop_5.jpg	→ O(n log n)
crop_img/data_structure_algorithm_note_53_crop_6.jpg	⇒ O(n log n)
crop_img/data_structure_algorithm_note_53_crop_7.jpg	QuickSort: recursively partition the left subarray and right subarray
crop_img/data_structure_algorithm_note_53_crop_8.jpg	according to a pivot chosen at random
crop_img/data_structure_algorithm_note_53_crop_9.jpg	<pivot | pivot | > pivot
crop_img/data_structure_algorithm_note_53_crop_10.jpg	Partition ():
crop_img/data_structure_algorithm_note_53_crop_11.jpg	Swap (pivot, A[start])
crop_img/data_structure_algorithm_note_53_crop_12.jpg	let i=1, j=size-1
crop_img/data_structure_algorithm_note_53_crop_13.jpg	Find i s.t. A[i] > pivot from index 1→end
crop_img/data_structure_algorithm_note_53_crop_14.jpg	Find j s.t. A[j] < pivot from index end→1
crop_img/data_structure_algorithm_note_53_crop_15.jpg	Swap(A[i], A[j])
crop_img/data_structure_algorithm_note_53_crop_16.jpg	Repeat until j<i, j moves to the region containing
crop_img/data_structure_algorithm_note_53_crop_17.jpg	elements <pivot
crop_img/data_structure_algorithm_note_53_crop_18.jpg	Swap (pivot, A[j])
crop_img/data_structure_algorithm_note_53_crop_19.jpg	Not stable, not adaptive, in-place
crop_img/data_structure_algorithm_note_53_crop_20.jpg	Runtime : average O(n log n)
crop_img/data_structure_algorithm_note_53_crop_21.jpg	O(n²) (keep choosing pivot which is the
crop_img/data_structure_algorithm_note_53_crop_22.jpg	worst
crop_img/data_structure_algorithm_note_53_crop_23.jpg	min /max element)
crop_img/data_structure_algorithm_note_53_crop_24.jpg	Quick Select: Similar to QuickSort, but only need to work on one side
crop_img/data_structure_algorithm_note_53_crop_27.jpg	→ o(n) runtime
crop_img/data_structure_algorithm_note_54_crop_0.jpg	) Radix Sort: Sort integer by each place (each place can only hold
crop_img/data_structure_algorithm_note_54_crop_1.jpg	digit from 0-9, except the largest place which may include negative
crop_img/data_structure_algorithm_note_54_crop_2.jpg	digits )k0 digit from-g→g
crop_img/data_structure_algorithm_note_54_crop_3.jpg	•# iterations:# digits of the longest int=k
crop_img/data_structure_algorithm_note_54_crop_4.jpg	. Represent each digit by a bucket(linked list) containing the
crop_img/data_structure_algorithm_note_54_crop_5.jpg	integers that has that digit at the current 10^k place.
crop_img/data_structure_algorithm_note_54_crop_6.jpg	• Runtime : o(kn)
crop_img/data_structure_algorithm_note_54_crop_7.jpg	. Stable ) not adaptive, not in-place
crop_img/data_structure_algorithm_note_54_crop_8.jpg	pattern matching : given string text and string pattern find all
crop_img/data_structure_algorithm_note_54_crop_9.jpg	occurrences of pattern in text
crop_img/data_structure_algorithm_note_54_crop_10.jpg	Boyer Moore:
crop_img/data_structure_algorithm_note_54_crop_11.jpg	.Last Occurrence Table : mapping each char in the pattern to the last
crop_img/data_structure_algorithm_note_54_crop_12.jpg	index it appears in the pattern, and all other char got mapped to
crop_img/data_structure_algorithm_note_54_crop_13.jpg	-1(Use hashmap)
crop_img/data_structure_algorithm_note_54_crop_14.jpg	• Searching algorithm
crop_img/data_structure_algorithm_note_54_crop_15.jpg	① Starting from the end of the pattern, compare char-by-char
crop_img/data_structure_algorithm_note_54_crop_16.jpg	with the compared portion of the text
crop_img/data_structure_algorithm_note_54_crop_17.jpg	2
crop_img/data_structure_algorithm_note_54_crop_18.jpg	If every char matches: add the start index of the compared portion
crop_img/data_structure_algorithm_note_54_crop_19.jpg	of the text to result, then move start forward 1 position
crop_img/data_structure_algorithm_note_54_crop_20.jpg	3
crop_img/data_structure_algorithm_note_54_crop_21.jpg	Else: let failtable be the failure table
crop_img/data_structure_algorithm_note_55_crop_0.jpg	let k be the index of the char of text that fails
crop_img/data_structure_algorithm_note_55_crop_1.jpg	lastId
crop_img/data_structure_algorithm_note_55_crop_2.jpg	I
crop_img/data_structure_algorithm_note_55_crop_3.jpg	If failtable.get(key(text[k]))<k:
crop_img/data_structure_algorithm_note_55_crop_4.jpg	start += pattern.length - lastId
crop_img/data_structure_algorithm_note_55_crop_5.jpg	Else : start +=1
crop_img/data_structure_algorithm_note_55_crop_6.jpg	KMP: relies on prefix & suffix of the pattern to determine
crop_img/data_structure_algorithm_note_55_crop_7.jpg	shifting
crop_img/data_structure_algorithm_note_55_crop_8.jpg	.Failure table: record the length of the longest prefix that is also
crop_img/data_structure_algorithm_note_55_crop_9.jpg	the suffix of the pattern Co…i] (right inclusive)
crop_img/data_structure_algorithm_note_55_crop_10.jpg	.Algorithm for creating FT :
crop_img/data_structure_algorithm_note_55_crop_11.jpg	FT[0]= 0
crop_img/data_structure_algorithm_note_55_crop_12.jpg	let i:= the starting index of prefix
crop_img/data_structure_algorithm_note_55_crop_13.jpg	suffix
crop_img/data_structure_algorithm_note_55_crop_14.jpg	j :=
crop_img/data_structure_algorithm_note_55_crop_15.jpg	i j (at both heads)
crop_img/data_structure_algorithm_note_55_crop_16.jpg	i=0)j=1 (the substring is ca)
crop_img/data_structure_algorithm_note_55_crop_17.jpg	While j < pat.length:
crop_img/data_structure_algorithm_note_55_crop_18.jpg	length of prefix
crop_img/data_structure_algorithm_note_55_crop_19.jpg	If pat[i] == pat[j]: write i+ to j
crop_img/data_structure_algorithm_note_55_crop_20.jpg	i++,j++
crop_img/data_structure_algorithm_note_55_crop_21.jpg	Else:
crop_img/data_structure_algorithm_note_55_crop_22.jpg	If i≠0：
crop_img/data_structure_algorithm_note_55_crop_23.jpg	i=FT[i- 1]
crop_img/data_structure_algorithm_note_55_crop_24.jpg	If i=0
crop_img/data_structure_algorithm_note_55_crop_25.jpg	FT[j]=0 ,j++
crop_img/data_structure_algorithm_note_55_crop_26.jpg	i )j now at both
crop_img/data_structure_algorithm_note_55_crop_27.jpg	head again and
crop_img/data_structure_algorithm_note_55_crop_28.jpg	Pat[i] ≠ pat[j]
crop_img/data_structure_algorithm_note_56_crop_0.jpg	 Searching algorithm: Acts like normal brute Force except:
crop_img/data_structure_algorithm_note_56_crop_1.jpg	Comparing go from left→ right of pattern
crop_img/data_structure_algorithm_note_56_crop_2.jpg	. When a mismatch occur at index k
crop_img/data_structure_algorithm_note_56_crop_3.jpg	of pattern
crop_img/data_structure_algorithm_note_56_crop_4.jpg	start +=P{-FT[k-1]}
crop_img/data_structure_algorithm_note_56_crop_5.jpg	For next comparing iteration start at id FT[k-1 of pattern
crop_img/data_structure_algorithm_note_56_crop_6.jpg	.If all chars match, treat the next char in text at mismatch
crop_img/data_structure_algorithm_note_56_crop_7.jpg	and shift like normal
crop_img/data_structure_algorithm_note_56_crop_8.jpg	Compare the whole pattern with the compared portion of text
crop_img/data_structure_algorithm_note_56_crop_9.jpg	) Rabin-Karp :
crop_img/data_structure_algorithm_note_56_crop_10.jpg	using hash
crop_img/data_structure_algorithm_note_56_crop_11.jpg	. searching algorithm :
crop_img/data_structure_algorithm_note_56_crop_12.jpg	If hash(text) == hash(pattern): (equal hashes doesn't mean
crop_img/data_structure_algorithm_note_56_crop_13.jpg	equal objects)
crop_img/data_structure_algorithm_note_56_crop_14.jpg	→ Compare text and pattern char by char
crop_img/data_structure_algorithm_note_56_crop_15.jpg	Else: shift pattern by 1, hash of new portion computed using
crop_img/data_structure_algorithm_note_56_crop_16.jpg	rolling hash
crop_img/data_structure_algorithm_note_56_crop_17.jpg	pattern = Cn.Cco
crop_img/data_structure_algorithm_note_56_crop_18.jpg	Coding Tips: hash(pat) = ∑ci.base
crop_img/data_structure_algorithm_note_56_crop_19.jpg	i =0
crop_img/data_structure_algorithm_note_56_crop_20.jpg	①Have to compute hash of .cl where l=pat.length
crop_img/data_structure_algorithm_note_56_crop_21.jpg	manually (can't use rolling hash)
crop_img/data_structure_algorithm_note_56_crop_22.jpg	hash First( ret hash of co…c and be noted
crop_img/data_structure_algorithm_note_56_crop_23.jpg	to use Math.exp())
crop_img/data_structure_algorithm_note_57_crop_0.jpg	Rolling hash: let h= hash(ci…cj)
crop_img/data_structure_algorithm_note_57_crop_1.jpg	a
crop_img/data_structure_algorithm_note_57_crop_2.jpg	hash（ci+e)=（hash()-ci.base)base
crop_img/data_structure_algorithm_note_57_crop_3.jpg	+ cj+1
crop_img/data_structure_algorithm_note_57_crop_4.jpg	③
crop_img/data_structure_algorithm_note_57_crop_5.jpg	Stop when i== end-l+1
crop_img/data_structure_algorithm_note_57_crop_6.jpg	 Galil Rule : A rule that can optimize Boyer Moore
crop_img/data_structure_algorithm_note_57_crop_7.jpg	Ex: text = a a a a aa a …a  (length n)
crop_img/data_structure_algorithm_note_57_crop_8.jpg	(m<n)
crop_img/data_structure_algorithm_note_57_crop_9.jpg	pattern= aaa..a (length m)
crop_img/data_structure_algorithm_note_57_crop_10.jpg	=) Runtime = o(mn) (just like Brute Force)
crop_img/data_structure_algorithm_note_57_crop_11.jpg	. We can make pattern become gggg where g = a.a
crop_img/data_structure_algorithm_note_57_crop_12.jpg	where g.length=pat.length-FT[end]
crop_img/data_structure_algorithm_note_57_crop_13.jpg	. When we get a complete match between pat and text, treat this
crop_img/data_structure_algorithm_note_57_crop_14.jpg	like the way KMP does: shift by period (=pat.length -FT[end])
crop_img/data_structure_algorithm_note_57_crop_15.jpg	next char in text keep at mismatch and start to check at id
crop_img/data_structure_algorithm_note_57_crop_16.jpg	pat.length-period (= FT[end])
crop_img/data_structure_algorithm_note_57_crop_17.jpg	ababab
crop_img/data_structure_algorithm_note_57_crop_18.jpg	日
crop_img/data_structure_algorithm_note_57_crop_19.jpg	a
crop_img/data_structure_algorithm_note_57_crop_20.jpg	3
crop_img/data_structure_algorithm_note_57_crop_21.jpg	4
crop_img/data_structure_algorithm_note_57_crop_22.jpg	5
crop_img/data_structure_algorithm_note_57_crop_23.jpg	period = ob
crop_img/data_structure_algorithm_note_57_crop_24.jpg	1
crop_img/data_structure_algorithm_note_57_crop_25.jpg	Ex
crop_img/data_structure_algorithm_note_57_crop_26.jpg	FT:
crop_img/data_structure_algorithm_note_57_crop_27.jpg	2
crop_img/data_structure_algorithm_note_57_crop_28.jpg	4
crop_img/data_structure_algorithm_note_57_crop_29.jpg	period.length = α
crop_img/data_structure_algorithm_note_57_crop_30.jpg	3
crop_img/data_structure_algorithm_note_57_crop_31.jpg	0
crop_img/data_structure_algorithm_note_57_crop_32.jpg	6
crop_img/data_structure_algorithm_note_57_crop_33.jpg	Depth-First Search (DFS): An algorithm to traverse the graph
crop_img/data_structure_algorithm_note_57_crop_34.jpg	where the visited vertices are marked to avoid later. The order
crop_img/data_structure_algorithm_note_57_crop_35.jpg	of visits is similar to the process of build up and tear down a stack
crop_img/data_structure_algorithm_note_57_crop_36.jpg	• Runtime: o(Vl+ lE1)
crop_img/data_structure_algorithm_note_57_crop_37.jpg	Space-complex: o(log n)
crop_img/data_structure_algorithm_note_58_crop_0.jpg	Breadth-First Search (BFS): Traverse the graph layer by layer
crop_img/data_structure_algorithm_note_58_crop_1.jpg	Where visited are marked to avoid later. The order of
crop_img/data_structure_algorithm_note_58_crop_2.jpg	visits is similar to the process of build up and tear down a queue.
crop_img/data_structure_algorithm_note_58_crop_3.jpg	Stop when the queue is empty.
crop_img/data_structure_algorithm_note_58_crop_4.jpg	. Runtime: O(Vl+|E1)
crop_img/data_structure_algorithm_note_58_crop_5.jpg	. Space complex: o( n/2)
crop_img/data_structure_algorithm_note_58_crop_6.jpg	.) Dijkstra: Find the shortest path from a node to all other nodes
crop_img/data_structure_algorithm_note_58_crop_7.jpg	in a weighted graph. Use priority queue to keep track of the
crop_img/data_structure_algorithm_note_58_crop_8.jpg	shortest path. vertices returned by priority queue's remove have
crop_img/data_structure_algorithm_note_58_crop_9.jpg	value of min distance to the starting node and thus marked as
crop_img/data_structure_algorithm_note_58_crop_10.jpg	visited. Stop when the queue is empty or all vertices are visited.
crop_img/data_structure_algorithm_note_58_crop_11.jpg	·Runtime :o((v+E) log v)
crop_img/data_structure_algorithm_note_58_crop_12.jpg	Prim: Find the MST by using a set of visited vertices S containing
crop_img/data_structure_algorithm_note_58_crop_13.jpg	vertices reached by the chosen edges. Use priority queue to keep track
crop_img/data_structure_algorithm_note_58_crop_14.jpg	of the shortest edge that incident to the vertices of S (to be added).
crop_img/data_structure_algorithm_note_58_crop_15.jpg	Stop when all edges visited or the queue is empty
crop_img/data_structure_algorithm_note_58_crop_16.jpg	. Runtime: o(ElloglE1)
crop_img/data_structure_algorithm_note_58_crop_17.jpg	Kruskal: Find the MST by picking the shortest edges possible throughout
crop_img/data_structure_algorithm_note_58_crop_18.jpg	the graph that don't form a cycle. Use union-find data structure
crop_img/data_structure_algorithm_note_58_crop_19.jpg	to keep track of cycles.
crop_img/data_structure_algorithm_note_58_crop_20.jpg	inverse Ackermann func
crop_img/data_structure_algorithm_note_58_crop_21.jpg	。Runtime: union()/find()=o(α(v)) ~0(1)
crop_img/data_structure_algorithm_note_58_crop_22.jpg	O (1E1 log)E1)
crop_img/data_structure_algorithm_note_58_crop_23.jpg	7
crop_img/dialogflow_intro_113_crop_0.jpg	Intent:
crop_img/dialogflow_intro_113_crop_1.jpg	user's goal or purpose
crop_img/dialogflow_intro_113_crop_2.jpg	only contains the logic to detect what the user wants
crop_img/dialogflow_intro_113_crop_3.jpg	Can be reused in multiple places of a conversation
crop_img/dialogflow_intro_113_crop_4.jpg	.
crop_img/dialogflow_intro_113_crop_5.jpg	Layer:
crop_img/dialogflow_intro_113_crop_6.jpg	.controls the flow of the conversation and what to do next
crop_img/dialogflow_intro_113_crop_7.jpg	.(can also cover fulfillment (answer)
crop_img/dialogflow_intro_113_crop_8.jpg	Flow: split complex conversation → multiple sub-conversation
crop_img/dialogflow_intro_113_crop_9.jpg	) Router:
crop_img/dialogflow_intro_113_crop_10.jpg	called when an end-user input matches an intent
crop_img/dialogflow_intro_113_crop_11.jpg	and /on
crop_img/dialogflow_intro_113_crop_12.jpg	some conditions are met
crop_img/dialogflow_intro_113_crop_13.jpg	Intent route: intent requirement needed
crop_img/dialogflow_intro_113_crop_14.jpg	.Condition route: a route with only 1 condition reg
crop_img/dialogflow_intro_113_crop_15.jpg	Grocery chat bot:
crop_img/dialogflow_intro_113_crop_16.jpg	Intents:
crop_img/dialogflow_intro_113_crop_17.jpg	①
crop_img/dialogflow_intro_113_crop_18.jpg	Ask for menu
crop_img/dialogflow_intro_113_crop_19.jpg	. Put into order list (name + quantity)
crop_img/dialogflow_intro_113_crop_20.jpg	Remove from order list (name + quantity)
crop_img/dialogflow_intro_113_crop_21.jpg	Make purchase
crop_img/dialogflow_intro_113_crop_22.jpg	2
crop_img/dialogflow_intro_113_crop_23.jpg	Reconfirm order
crop_img/dialogflow_intro_113_crop_24.jpg	Ask for refund
crop_img/dialogflow_intro_113_crop_25.jpg	→ Connect to employees
crop_img/dialogflow_intro_113_crop_26.jpg	③
crop_img/git_and_github_intro_110_crop_0.jpg	GIT & GITHUB
crop_img/git_and_github_intro_110_crop_1.jpg	) git init: initialize git for a project
crop_img/git_and_github_intro_110_crop_2.jpg	git remote add origin <link>: set up a remote repository for the project
crop_img/git_and_github_intro_110_crop_3.jpg	origin: an alias to a particular repo
crop_img/git_and_github_intro_110_crop_4.jpg	) git revert <commit's hash>: revert a commit
crop_img/git_and_github_intro_110_crop_5.jpg	(git revert -m 1 <commit's hash> if the commit is a merge)
crop_img/git_and_github_intro_110_crop_6.jpg	git commit: Save changes in the local repository
crop_img/git_and_github_intro_110_crop_7.jpg	) git branch: a pointer to a snapshot of our changes
crop_img/git_and_github_intro_110_crop_8.jpg	-8 for moving a branch into another commit
crop_img/git_and_github_intro_110_crop_9.jpg	) git checkout: checkout A means we move to branch A
crop_img/git_and_github_intro_110_crop_10.jpg	git merge <branch A>: merge branch A to the current branch
crop_img/git_and_github_intro_110_crop_11.jpg	conflict: when we try to merge 2 branches with diff contents
crop_img/git_and_github_intro_110_crop_12.jpg	pull request: request to merge a branch with the main branch
crop_img/git_and_github_intro_110_crop_13.jpg	(directory)
crop_img/git_and_github_intro_110_crop_14.jpg	what files in .gitignore will not be pushed to remote
crop_img/git_and_github_intro_110_crop_15.jpg	)git ignore
crop_img/git_and_github_intro_110_crop_16.jpg	Fix the remote repo to comply with .gitignore: git rm --cached file
crop_img/git_and_github_intro_110_crop_17.jpg	→ push
crop_img/git_and_github_intro_110_crop_18.jpg	)git cherry-pick: pick commits and add it to current HEAD
crop_img/git_and_github_intro_110_crop_19.jpg	the commit
crop_img/git_and_github_intro_110_crop_20.jpg	just check
crop_img/git_and_github_intro_110_crop_21.jpg	out
crop_img/git_and_github_intro_110_crop_22.jpg	git reset: reverse changes by moving a branch ref backward in time
crop_img/git_and_github_intro_110_crop_23.jpg	(only work for local)
crop_img/git_and_github_intro_110_crop_24.jpg	git rebase: change for remote by editing modified commit
crop_img/git_and_github_intro_111_crop_0.jpg	don't create new)
crop_img/git_and_github_intro_111_crop_1.jpg	commit
crop_img/git_and_github_intro_111_crop_2.jpg	git commit --amend: combine staged changes within the last commit
crop_img/git_and_github_intro_111_crop_3.jpg	) Trunk-based Dev: Work on main branch only and the code base is
crop_img/git_and_github_intro_111_crop_4.jpg	always up-to-date and stable
crop_img/git_and_github_intro_111_crop_5.jpg	pro: early issue detection, quick feedback, reduce overhead
crop_img/git_and_github_intro_111_crop_6.jpg	.con: conflict integration later, robust testing, hard and
crop_img/git_and_github_intro_111_crop_7.jpg	Feature branching: Creating a new branch for a specific feature/change,
crop_img/git_and_github_intro_111_crop_8.jpg	then merge back to main using pull request
crop_img/git_and_github_intro_111_crop_9.jpg	Pro: parallel dev, good management, main stability, encourage short-lived
crop_img/git_and_github_intro_111_crop_10.jpg	branches exist testing pos
crop_img/git_and_github_intro_111_crop_11.jpg	Con:bigbranch delaymerging for reviewconflict due tobranch
crop_img/git_and_github_intro_111_crop_12.jpg	dependencies
crop_img/git_and_github_intro_111_crop_13.jpg	come from stacked application fielddocument
crop_img/git_and_github_intro_111_crop_14.jpg	√
crop_img/git_and_github_intro_111_crop_15.jpg	REQUIREMENTS ENGINEERING
crop_img/git_and_github_intro_111_crop_16.jpg	)Non-functional req: criteria used to judge how the system performs, f
crop_img/git_and_github_intro_111_crop_17.jpg	what it does (ex: security, accuracy, cost, reliability)….)
crop_img/git_and_github_intro_111_crop_18.jpg	Completeness: what the system needs to do, determining the relevance of req
crop_img/git_and_github_intro_111_crop_19.jpg	(the software can do this
crop_img/git_and_github_intro_111_crop_20.jpg	) User req: written for customers, no technical details
crop_img/git_and_github_intro_111_crop_21.jpg	that)
crop_img/git_and_github_intro_111_crop_22.jpg	System req
crop_img/git_and_github_intro_111_crop_23.jpg	written for devs, include functional/ nonfunctional reqs
crop_img/git_and_github_intro_111_crop_24.jpg	specific, clear, have technical details
crop_img/git_and_github_intro_111_crop_25.jpg	Ex: the user should be provided with facility to define the type of external file
crop_img/git_and_github_intro_111_crop_26.jpg	(customer wants?)
crop_img/git_and_github_intro_111_crop_27.jpg	Analyzing req: verification → validation → risk analysis
crop_img/git_and_github_intro_111_crop_28.jpg	(complete, pertinent)
crop_img/git_and_github_intro_111_crop_29.jpg	(error)
crop_img/git_and_github_intro_111_crop_30.jpg	) req prioritization:
crop_img/git_and_github_intro_111_crop_31.jpg	mandatory → nice to have → users
crop_img/git_intro_231_crop_0.jpg	) commit: Name changes in the local repository
crop_img/git_intro_231_crop_1.jpg	) branch: a pointer to a snapshot of our changes
crop_img/git_intro_231_crop_2.jpg	.) checkout.
crop_img/git_intro_231_crop_3.jpg	checkout A means we move to branch A
crop_img/git_intro_231_crop_4.jpg	)rebase : move our work
crop_img/git_intro_231_crop_5.jpg	from branch A into branch B
crop_img/git_intro_231_crop_6.jpg	is called rebasing A to B
crop_img/git_intro_231_crop_7.jpg	command : git rebase b
crop_img/git_intro_231_crop_8.jpg	) head : the commit we just checkout
crop_img/git_intro_231_crop_9.jpg	detaching head: attach head to a commit instead of a branch
crop_img/git_intro_231_crop_10.jpg	. A: move to the above/previous commit
crop_img/git_intro_231_crop_11.jpg	. 2 : move up a number of commits
crop_img/git_intro_231_crop_12.jpg	Ex: git checkout HEAD~4
crop_img/git_intro_231_crop_13.jpg	.-8: reassign a branch to a commit
crop_img/git_intro_231_crop_14.jpg	Ex: git branch -f main HEAD~8
crop_img/git_intro_231_crop_15.jpg	reset: reverses change by moving a branch ref backwards in time
crop_img/git_intro_231_crop_16.jpg	) git commit --amend
crop_img/git_intro_231_crop_17.jpg	:make slight modification
crop_img/git_intro_232_crop_0.jpg	git tag: a tagged commit cannot be changed
crop_img/git_intro_232_crop_1.jpg	Ex: git tag v1 C1
crop_img/git_intro_232_crop_2.jpg	git describe: how many commits have you done since a tagged
crop_img/git_intro_232_crop_3.jpg	commit (anchor)
crop_img/git_intro_232_crop_4.jpg	Ex: git describe c5
crop_img/git_intro_232_crop_5.jpg	.) ^a: direct HEAD to another parent commit
crop_img/git_intro_232_crop_6.jpg	.A: “first” parent commit
crop_img/git_intro_232_crop_7.jpg	Ex: git branch newBranch main will create the newBranch
crop_img/git_intro_232_crop_8.jpg	branch at another commit
crop_img/git_intro_232_crop_9.jpg	GITHUB
crop_img/git_intro_232_crop_10.jpg	push: publish to the remote repository
crop_img/git_intro_232_crop_11.jpg	. How to create a branch on GitHub?
crop_img/git_intro_232_crop_12.jpg	. Make the local branch in your computer
crop_img/git_intro_232_crop_13.jpg	Commit
crop_img/git_intro_232_crop_14.jpg	the remote
crop_img/git_intro_232_crop_15.jpg	push it to “origin"
crop_img/git_intro_232_crop_16.jpg	7
crop_img/git_intro_232_crop_17.jpg	resp you cloned
crop_img/git_intro_232_crop_18.jpg	from, usually it is the
crop_img/git_intro_232_crop_19.jpg	default
crop_img/git_intro_232_crop_20.jpg	main
crop_img/git_intro_232_crop_21.jpg	git push <remote-name> <local-branch-name>:remote-branch-name>
crop_img/lecture_algorithm_160_crop_0.jpg	) Sorting
crop_img/lecture_algorithm_160_crop_1.jpg	Adaptive: if the algorithm faster if some elements are already sorted
crop_img/lecture_algorithm_160_crop_2.jpg	In-place: space complexity, how much memory at least do you need
crop_img/lecture_algorithm_160_crop_3.jpg	to sort n-things → n things
crop_img/lecture_algorithm_160_crop_4.jpg	.If it uses O(1) extra memory → in-place
crop_img/lecture_algorithm_160_crop_5.jpg	. Stable: do items w/ same value end up in same relative order
crop_img/lecture_algorithm_160_crop_6.jpg	2
crop_img/lecture_algorithm_160_crop_7.jpg	4 4 6 10 → stable
crop_img/lecture_algorithm_160_crop_8.jpg	2
crop_img/lecture_algorithm_160_crop_9.jpg	人
crop_img/lecture_algorithm_160_crop_10.jpg	146 104
crop_img/lecture_algorithm_160_crop_11.jpg	9
crop_img/lecture_algorithm_160_crop_12.jpg	Ex
crop_img/lecture_algorithm_160_crop_13.jpg	V
crop_img/lecture_algorithm_160_crop_14.jpg	2
crop_img/lecture_algorithm_160_crop_15.jpg	1
crop_img/lecture_algorithm_160_crop_16.jpg	4 6 10 not stable
crop_img/lecture_algorithm_160_crop_17.jpg	/
crop_img/lecture_algorithm_160_crop_18.jpg	4
crop_img/lecture_algorithm_160_crop_19.jpg	)
crop_img/lecture_algorithm_160_crop_20.jpg	Bubble Sort.
crop_img/lecture_algorithm_160_crop_21.jpg	for item: for each pair of items, if it out of order swap
crop_img/lecture_algorithm_160_crop_22.jpg	.keep track of last swap index, the following iteration only goes
crop_img/lecture_algorithm_160_crop_23.jpg	up to this pos
crop_img/lecture_algorithm_160_crop_24.jpg	. Run-time: O(n^2)
crop_img/lecture_algorithm_160_crop_25.jpg	. stable, adaptive) and in-place
crop_img/lecture_algorithm_160_crop_26.jpg	Insertion Sort
crop_img/lecture_algorithm_160_crop_27.jpg	Sorted NonSorted
crop_img/lecture_algorithm_160_crop_28.jpg	• At iteration i:
crop_img/lecture_algorithm_160_crop_29.jpg	U↑
crop_img/lecture_algorithm_160_crop_30.jpg	swap swap
crop_img/lecture_algorithm_160_crop_31.jpg	· stable) Adaptive) In-place) O(n^2)
crop_img/lecture_algorithm_161_crop_0.jpg	) Selection sort: largest → last, 2nd-largest → 2nd-to-last)
crop_img/lecture_algorithm_161_crop_1.jpg	Stable: X
crop_img/lecture_algorithm_161_crop_2.jpg	Adaptive: X
crop_img/lecture_algorithm_161_crop_3.jpg	• Inplace: √
crop_img/lecture_algorithm_161_crop_4.jpg	Note: take fewest actual swaps
crop_img/lecture_algorithm_161_crop_5.jpg	) Bubble sort: partial adaptive
crop_img/lecture_algorithm_161_crop_6.jpg	worse
crop_img/lecture_algorithm_161_crop_7.jpg	√
crop_img/lecture_algorithm_161_crop_8.jpg	812 34567
crop_img/lecture_algorithm_161_crop_9.jpg	23456781
crop_img/lecture_algorithm_161_crop_10.jpg	Bubble Sort from left→ right
crop_img/lecture_algorithm_161_crop_11.jpg	) cocktail shaker sort;
crop_img/lecture_algorithm_161_crop_12.jpg	one
crop_img/lecture_algorithm_161_crop_13.jpg	Bubble sort from right → left one
crop_img/lecture_algorithm_161_crop_14.jpg	• still stops at no swap
crop_img/lecture_algorithm_161_crop_15.jpg	last in diars on the left and right on the boundary for next
crop_img/lecture_algorithm_161_crop_16.jpg	iteration
crop_img/lecture_algorithm_161_crop_17.jpg	Why use Insertion, Bubble, cocktail Sort?
crop_img/lecture_algorithm_161_crop_18.jpg	is stable + in-place + adaptive
crop_img/lecture_algorithm_161_crop_19.jpg	faster for small amounts of data
crop_img/lecture_algorithm_161_crop_20.jpg	• used inside
crop_img/lecture_algorithm_161_crop_21.jpg	of more complex sorts
crop_img/lecture_algorithm_161_crop_22.jpg	runtime
crop_img/lecture_algorithm_161_crop_23.jpg	Note: Worst is bubble sort
crop_img/lecture_algorithm_162_crop_0.jpg	selection sort does fewer swaps
crop_img/lecture_algorithm_162_crop_1.jpg	Insertion sort does fewer compares
crop_img/lecture_algorithm_162_crop_2.jpg	can fix 1 item be faster?
crop_img/lecture_algorithm_162_crop_3.jpg	. add all items a heap: o(n)
crop_img/lecture_algorithm_162_crop_4.jpg	repeatedly remove largest item: O(log n)
crop_img/lecture_algorithm_162_crop_5.jpg	o(n logn)
crop_img/lecture_algorithm_162_crop_6.jpg	X
crop_img/lecture_algorithm_162_crop_7.jpg	×
crop_img/lecture_algorithm_162_crop_8.jpg	In-place, adaptive, stable (if you swap only adjacent
crop_img/lecture_algorithm_162_crop_9.jpg	depend
crop_img/lecture_algorithm_162_crop_10.jpg	elements: probably stable
crop_img/lecture_algorithm_162_crop_11.jpg	Swap further elements
crop_img/lecture_algorithm_162_crop_12.jpg	→probably unstable
crop_img/lecture_algorithm_162_crop_13.jpg	) Divide & Conquer
crop_img/lecture_algorithm_162_crop_14.jpg	) Merge Sort
crop_img/lecture_algorithm_162_crop_15.jpg	High-level plan: split data into small & large
crop_img/lecture_algorithm_162_crop_16.jpg	How to choose pivot: many options
crop_img/lecture_algorithm_162_crop_17.jpg	how to divide data (“partition)
crop_img/lecture_algorithm_162_crop_18.jpg	——
crop_img/lecture_algorithm_162_crop_19.jpg	4-step plan
crop_img/lecture_algorithm_162_crop_20.jpg	pivot
crop_img/lecture_algorithm_162_crop_21.jpg	2
crop_img/lecture_algorithm_162_crop_22.jpg	Move pivot to index 0
crop_img/lecture_algorithm_162_crop_23.jpg	3
crop_img/lecture_algorithm_162_crop_24.jpg	partition data into (< pivot) and (>pivot)
crop_img/lecture_algorithm_162_crop_25.jpg	④
crop_img/lecture_algorithm_162_crop_26.jpg	AC→
crop_img/lecture_algorithm_162_crop_27.jpg	A[n-1]
crop_img/lecture_algorithm_162_crop_28.jpg	i
crop_img/lecture_algorithm_162_crop_29.jpg	j
crop_img/lecture_algorithm_163_crop_0.jpg	To find a num < pivot on the right
crop_img/lecture_algorithm_163_crop_1.jpg	and a num > pivot on the left
crop_img/lecture_algorithm_163_crop_2.jpg	Swap them
crop_img/lecture_algorithm_163_crop_3.jpg	Stop when i> j
crop_img/lecture_algorithm_163_crop_4.jpg	5
crop_img/lecture_algorithm_163_crop_5.jpg	Return pivot to original 0
crop_img/lecture_algorithm_163_crop_6.jpg	Do Quick Sort on
crop_img/lecture_algorithm_163_crop_7.jpg	left A and right A
crop_img/lecture_algorithm_163_crop_8.jpg	left/right A
crop_img/lecture_algorithm_163_crop_9.jpg	Worst runtime: O(n)→pivot = max/min
crop_img/lecture_algorithm_163_crop_10.jpg	Avg runtime: o(n logn)
crop_img/lecture_algorithm_163_crop_11.jpg	Stable
crop_img/lecture_algorithm_163_crop_12.jpg	Adaptive
crop_img/lecture_algorithm_163_crop_13.jpg	In-place
crop_img/lecture_algorithm_163_crop_14.jpg	×
crop_img/lecture_algorithm_163_crop_15.jpg	X
crop_img/lecture_algorithm_163_crop_16.jpg	√ (don't use another
crop_img/lecture_algorithm_163_crop_17.jpg	Data structure)
crop_img/lecture_algorithm_163_crop_18.jpg	•pivot strategies
crop_img/lecture_algorithm_163_crop_19.jpg	A[0]
crop_img/lecture_algorithm_163_crop_20.jpg	middle(A[0], A[1], A[n-1])
crop_img/lecture_algorithm_163_crop_21.jpg	random pivot
crop_img/lecture_algorithm_163_crop_22.jpg	Guaranteed good pivot:
crop_img/lecture_algorithm_163_crop_23.jpg	. Median-of-Medians
crop_img/lecture_algorithm_163_crop_24.jpg	) Quick Select:
crop_img/lecture_algorithm_163_crop_25.jpg	Stable
crop_img/lecture_algorithm_163_crop_26.jpg	Adaptive
crop_img/lecture_algorithm_163_crop_27.jpg	In-place
crop_img/lecture_algorithm_163_crop_28.jpg	<
crop_img/lecture_algorithm_163_crop_29.jpg	√
crop_img/lecture_algorithm_163_crop_30.jpg	X
crop_img/lecture_algorithm_164_crop_0.jpg	) Radix sort:
crop_img/lecture_algorithm_164_crop_1.jpg	En: Sorting n digit ) sort by 1's place first
crop_img/lecture_algorithm_164_crop_2.jpg	10's place second
crop_img/lecture_algorithm_164_crop_3.jpg	:
crop_img/lecture_algorithm_164_crop_4.jpg	. Sort by digit's pos:
crop_img/lecture_algorithm_164_crop_5.jpg	.10 of work: 0-g → create 10 queues to put 1 place number
crop_img/lecture_algorithm_164_crop_6.jpg	# loops=k
crop_img/lecture_algorithm_164_crop_7.jpg	. each loop put number into buckets
crop_img/lecture_algorithm_164_crop_8.jpg	. get # outs from bucket 0→ g
crop_img/lecture_algorithm_164_crop_9.jpg	0(kn)
crop_img/lecture_algorithm_164_crop_10.jpg	Runtime:
crop_img/lecture_algorithm_164_crop_11.jpg	Note: given a sorted arr ⇒ still 0(kn)
crop_img/lecture_algorithm_164_crop_12.jpg	Adaptive ×
crop_img/lecture_algorithm_164_crop_13.jpg	Stable
crop_img/lecture_algorithm_164_crop_14.jpg	In-place X
crop_img/lecture_algorithm_164_crop_15.jpg	Time runtime: 0(kn+kB)
crop_img/lecture_algorithm_164_crop_16.jpg	C
crop_img/lecture_algorithm_164_crop_17.jpg	→.k loop
crop_img/lecture_algorithm_164_crop_18.jpg	.k loop
crop_img/lecture_algorithm_164_crop_19.jpg	.go through each bucket
crop_img/lecture_algorithm_164_crop_20.jpg	put n digits into
crop_img/lecture_algorithm_164_crop_21.jpg	to get digit out
crop_img/lecture_algorithm_164_crop_22.jpg	buckets
crop_img/lecture_algorithm_164_crop_23.jpg	pattern matching prob:
crop_img/lecture_algorithm_164_crop_24.jpg	input string 18 → length
crop_img/lecture_algorithm_164_crop_25.jpg	Input
crop_img/lecture_algorithm_164_crop_26.jpg	n
crop_img/lecture_algorithm_164_crop_27.jpg	m
crop_img/lecture_algorithm_164_crop_28.jpg	A containN
crop_img/lecture_algorithm_165_crop_0.jpg	false otherwise
crop_img/lecture_algorithm_165_crop_1.jpg	. While done : for each id in ks
crop_img/lecture_algorithm_165_crop_2.jpg	check if s is in there
crop_img/lecture_algorithm_165_crop_3.jpg	) KML: Go from left → right
crop_img/lecture_algorithm_165_crop_4.jpg	 Rabin-Karp : Use hashing to check the whole pattern at each index
crop_img/lecture_algorithm_165_crop_5.jpg	If different hash code ⇒ pattern is not here
crop_img/lecture_algorithm_165_crop_6.jpg	. hash (pattern) takes o(m)
crop_img/lecture_algorithm_165_crop_7.jpg	→“roll"-able hash,i.e. given one hash code already
crop_img/lecture_algorithm_165_crop_8.jpg	computed, compute the Next one in o(1) time
crop_img/lecture_algorithm_165_crop_9.jpg	 new Hash = old hash - old First + new Last
crop_img/lecture_algorithm_165_crop_10.jpg	n-1
crop_img/lecture_algorithm_165_crop_11.jpg	n-2
crop_img/lecture_algorithm_165_crop_12.jpg	rolling:(hash-oldfirst.)New last
crop_img/lecture_algorithm_165_crop_13.jpg	. Running time.
crop_img/lecture_algorithm_165_crop_14.jpg	o(m)
crop_img/lecture_algorithm_165_crop_15.jpg	hash of pattern
crop_img/lecture_algorithm_165_crop_16.jpg	rolling hash :o(n) times, o() each
crop_img/lecture_algorithm_166_crop_0.jpg	compare matching-hash patterns (m)
crop_img/lecture_algorithm_166_crop_1.jpg	→o(m+n)
crop_img/lecture_algorithm_166_crop_2.jpg	 Worst case:A lot of matching-hash pattern
crop_img/lecture_algorithm_166_crop_3.jpg	Galil Rule:
crop_img/lecture_algorithm_166_crop_4.jpg	Graph Theory
crop_img/lecture_algorithm_166_crop_5.jpg	(in this class)
crop_img/lecture_algorithm_166_crop_6.jpg	)Equal: G and a are equal if they have the same vertex and edges
crop_img/lecture_algorithm_166_crop_7.jpg	,
crop_img/lecture_algorithm_166_crop_8.jpg	F. isolated vertex
crop_img/lecture_algorithm_166_crop_9.jpg	) Isolated vertex:
crop_img/lecture_algorithm_166_crop_10.jpg	A
crop_img/lecture_algorithm_166_crop_11.jpg	①
crop_img/lecture_algorithm_166_crop_12.jpg	A。
crop_img/lecture_algorithm_166_crop_13.jpg	A
crop_img/lecture_algorithm_166_crop_14.jpg	) Undirected graph:
crop_img/lecture_algorithm_166_crop_15.jpg	A
crop_img/lecture_algorithm_166_crop_16.jpg	 Directed graph:
crop_img/lecture_algorithm_166_crop_17.jpg	今。
crop_img/lecture_algorithm_166_crop_18.jpg	C
crop_img/lecture_algorithm_166_crop_19.jpg	B
crop_img/lecture_algorithm_166_crop_20.jpg	Simple graph: no self loops & no repeated edges
crop_img/lecture_algorithm_166_crop_21.jpg	Simple
crop_img/lecture_algorithm_166_crop_22.jpg	not simple
crop_img/lecture_algorithm_166_crop_23.jpg	A
crop_img/lecture_algorithm_166_crop_24.jpg	B
crop_img/lecture_algorithm_166_crop_25.jpg	A
crop_img/lecture_algorithm_166_crop_26.jpg	B
crop_img/lecture_algorithm_166_crop_27.jpg	AB+BA
crop_img/lecture_algorithm_166_crop_28.jpg	→
crop_img/lecture_algorithm_166_crop_29.jpg	A
crop_img/lecture_algorithm_166_crop_30.jpg	B
crop_img/lecture_algorithm_167_crop_0.jpg	 Weighted edge:ge can have weight (stands for distance)
crop_img/lecture_algorithm_167_crop_1.jpg	a
crop_img/lecture_algorithm_167_crop_2.jpg	…
crop_img/lecture_algorithm_167_crop_3.jpg	A
crop_img/lecture_algorithm_167_crop_4.jpg	人
crop_img/lecture_algorithm_167_crop_5.jpg	3
crop_img/lecture_algorithm_167_crop_6.jpg	4
crop_img/lecture_algorithm_167_crop_7.jpg	,
crop_img/lecture_algorithm_167_crop_8.jpg	B
crop_img/lecture_algorithm_167_crop_9.jpg	C
crop_img/lecture_algorithm_167_crop_10.jpg	2
crop_img/lecture_algorithm_167_crop_11.jpg	graph traversal:
crop_img/lecture_algorithm_167_crop_12.jpg	A
crop_img/lecture_algorithm_167_crop_13.jpg	B
crop_img/lecture_algorithm_167_crop_14.jpg	E
crop_img/lecture_algorithm_167_crop_15.jpg	 path: sequence of vertices where vertices next to each other are
crop_img/lecture_algorithm_167_crop_16.jpg	adjacent vertices
crop_img/lecture_algorithm_167_crop_17.jpg	. No repeated vertices
crop_img/lecture_algorithm_167_crop_18.jpg	. No repeated edges
crop_img/lecture_algorithm_167_crop_19.jpg	Trail : can repeat vertices but can't repeat edges
crop_img/lecture_algorithm_167_crop_20.jpg	)Walk:
crop_img/lecture_algorithm_167_crop_21.jpg	can repeat vertices and edges
crop_img/lecture_algorithm_167_crop_22.jpg	) cycle:
crop_img/lecture_algorithm_167_crop_23.jpg	no repeated edges
crop_img/lecture_algorithm_167_crop_24.jpg	no repeated vertices except start = end
crop_img/lecture_algorithm_167_crop_25.jpg	 admit:
crop_img/lecture_algorithm_167_crop_26.jpg	can repeat
crop_img/lecture_algorithm_167_crop_27.jpg	vertices
crop_img/lecture_algorithm_167_crop_28.jpg	can't repeat edges
crop_img/lecture_algorithm_167_crop_29.jpg	2 vertices are connected if a path that connects them
crop_img/lecture_algorithm_167_crop_30.jpg	) Connected.
crop_img/lecture_algorithm_168_crop_0.jpg	一
crop_img/lecture_algorithm_168_crop_1.jpg	C
crop_img/lecture_algorithm_168_crop_2.jpg	&
crop_img/lecture_algorithm_168_crop_3.jpg	 Map<vertex,[adjacent vertices]>
crop_img/lecture_algorithm_168_crop_4.jpg	DFS
crop_img/lecture_algorithm_168_crop_5.jpg	0
crop_img/lecture_algorithm_168_crop_6.jpg	BFS
crop_img/lecture_algorithm_169_crop_0.jpg	) Dijkstra fail with negative edges
crop_img/lecture_algorithm_169_crop_1.jpg	Dist
crop_img/lecture_algorithm_169_crop_2.jpg	2
crop_img/lecture_algorithm_169_crop_3.jpg	A :0
crop_img/lecture_algorithm_169_crop_4.jpg	王
crop_img/lecture_algorithm_169_crop_5.jpg	U：13
crop_img/lecture_algorithm_169_crop_6.jpg	B
crop_img/lecture_algorithm_169_crop_7.jpg	g
crop_img/lecture_algorithm_169_crop_8.jpg	6
crop_img/lecture_algorithm_169_crop_9.jpg	B:6
crop_img/lecture_algorithm_169_crop_10.jpg	/3
crop_img/lecture_algorithm_169_crop_11.jpg	C.15
crop_img/lecture_algorithm_169_crop_12.jpg	10
crop_img/lecture_algorithm_169_crop_13.jpg	G
crop_img/lecture_algorithm_169_crop_14.jpg	4
crop_img/lecture_algorithm_169_crop_15.jpg	E:8
crop_img/lecture_algorithm_169_crop_16.jpg	A
crop_img/lecture_algorithm_169_crop_17.jpg	7
crop_img/lecture_algorithm_169_crop_18.jpg	4
crop_img/lecture_algorithm_169_crop_19.jpg	F
crop_img/lecture_algorithm_169_crop_20.jpg	C
crop_img/lecture_algorithm_169_crop_21.jpg	D:g
crop_img/lecture_algorithm_169_crop_22.jpg	2
crop_img/lecture_algorithm_169_crop_23.jpg	g
crop_img/lecture_algorithm_169_crop_24.jpg	g
crop_img/lecture_algorithm_169_crop_25.jpg	1
crop_img/lecture_algorithm_169_crop_26.jpg	G:10
crop_img/lecture_algorithm_169_crop_27.jpg	4
crop_img/lecture_algorithm_169_crop_28.jpg	D
crop_img/lecture_algorithm_169_crop_29.jpg	F:11
crop_img/lecture_algorithm_169_crop_30.jpg	1
crop_img/lecture_algorithm_169_crop_31.jpg	什
crop_img/lecture_algorithm_169_crop_32.jpg	10
crop_img/lecture_algorithm_169_crop_33.jpg	8
crop_img/lecture_algorithm_169_crop_34.jpg	15
crop_img/lecture_algorithm_169_crop_35.jpg	18
crop_img/lecture_algorithm_169_crop_36.jpg	7
crop_img/lecture_algorithm_169_crop_37.jpg	9
crop_img/lecture_algorithm_169_crop_38.jpg	14
crop_img/lecture_algorithm_169_crop_39.jpg	6
crop_img/lecture_algorithm_169_crop_40.jpg	14
crop_img/lecture_algorithm_169_crop_41.jpg	15
crop_img/lecture_algorithm_169_crop_42.jpg	13
crop_img/lecture_algorithm_169_crop_43.jpg	A
crop_img/lecture_algorithm_169_crop_44.jpg	8
crop_img/lecture_algorithm_169_crop_45.jpg	C
crop_img/lecture_algorithm_169_crop_46.jpg	8
crop_img/lecture_algorithm_169_crop_47.jpg	F
crop_img/lecture_algorithm_169_crop_48.jpg	G
crop_img/lecture_algorithm_169_crop_49.jpg	G
crop_img/lecture_algorithm_169_crop_50.jpg	E
crop_img/lecture_algorithm_169_crop_51.jpg	H
crop_img/lecture_algorithm_169_crop_52.jpg	C
crop_img/lecture_algorithm_169_crop_53.jpg	F
crop_img/lecture_algorithm_169_crop_54.jpg	H
crop_img/lecture_algorithm_169_crop_55.jpg	C
crop_img/lecture_algorithm_169_crop_56.jpg	H
crop_img/lecture_algorithm_169_crop_57.jpg	76
crop_img/lecture_algorithm_169_crop_58.jpg	2
crop_img/lecture_algorithm_169_crop_59.jpg	2
crop_img/lecture_algorithm_169_crop_60.jpg	一
crop_img/lecture_algorithm_169_crop_61.jpg	3
crop_img/lecture_algorithm_169_crop_62.jpg	5
crop_img/lecture_algorithm_169_crop_63.jpg	) Minimum Spanning Tree (MST)
crop_img/lecture_algorithm_169_crop_64.jpg	1
crop_img/lecture_algorithm_169_crop_65.jpg	"greedy algo: trying to graph the min cost edge whenever
crop_img/lecture_algorithm_169_crop_66.jpg	responsible (Also called Prim)
crop_img/lecture_algorithm_169_crop_67.jpg	goal: minimal total edge cost
crop_img/lecture_algorithm_169_crop_68.jpg	plan: start somewhere, track edge seen visited always
crop_img/lecture_algorithm_169_crop_69.jpg	the cheapest one
crop_img/lecture_algorithm_169_crop_70.jpg	How do we create the nodes and edges? Use node and adjacent
crop_img/lecture_algorithm_169_crop_71.jpg	list
crop_img/lecture_algorithm_169_crop_72.jpg	Plan: Use a heap (similar to Dijkstra)
crop_img/lecture_algorithm_170_crop_0.jpg	Note: if an edge that contains 2 visited nodes
crop_img/lecture_algorithm_170_crop_1.jpg	→ pick that edge make a cycle
crop_img/lecture_algorithm_170_crop_2.jpg	Kruskal:
crop_img/lecture_algorithm_170_crop_3.jpg	greedily choose the lightest edge in the entire graph
crop_img/lecture_algorithm_170_crop_4.jpg	that doesn't make a cycle
crop_img/lecture_algorithm_170_crop_5.jpg	Plan:
crop_img/lecture_algorithm_170_crop_6.jpg	①
crop_img/lecture_algorithm_170_crop_7.jpg	sort the edges choose the smallest edge in the graph which
crop_img/lecture_algorithm_170_crop_8.jpg	doesn't make a cycle
crop_img/lecture_algorithm_170_crop_9.jpg	2
crop_img/lecture_algorithm_170_crop_10.jpg	How to know when a cycle appears?
crop_img/lecture_algorithm_170_crop_11.jpg	Cannot use the strategy of Prim
crop_img/lecture_algorithm_170_crop_12.jpg	label distinct connected component until from chosen
crop_img/lecture_algorithm_170_crop_13.jpg	edges with distinct names
crop_img/lecture_algorithm_170_crop_14.jpg	After choose edge that connect a C component→ update
crop_img/lecture_algorithm_170_crop_15.jpg	label
crop_img/lecture_algorithm_170_crop_16.jpg	→Actually, this can be done using Union-Find data structure
crop_img/lecture_algorithm_170_crop_17.jpg	Union-Find data structure:
crop_img/lecture_algorithm_170_crop_18.jpg	find(x): return the label of x
crop_img/lecture_algorithm_170_crop_19.jpg	union(x,y): update labels after adding (x,y)
crop_img/lecture_algorithm_170_crop_20.jpg	runtime of find/union:
crop_img/lecture_algorithm_170_crop_21.jpg	Ackermann function: a function that grows very fast
crop_img/lecture_algorithm_170_crop_22.jpg	A(n) T fast
crop_img/lecture_algorithm_170_crop_23.jpg	A^(-1)(n): inverse function of Ackermann function
crop_img/lecture_algorithm_170_crop_24.jpg	→T Now
crop_img/lecture_data_structure_182_crop_0.jpg	Time Complexity: # of operations done based on the size of input
crop_img/lecture_data_structure_182_crop_1.jpg	Array: A contiguous block of memory
crop_img/lecture_data_structure_182_crop_2.jpg	no gap
crop_img/lecture_data_structure_182_crop_3.jpg	Drawbacks of array:
crop_img/lecture_data_structure_182_crop_4.jpg	size is fixed
crop_img/lecture_data_structure_182_crop_5.jpg	list(ADT): An ordered aligned, contiguous collection of data
crop_img/lecture_data_structure_182_crop_6.jpg	↓
crop_img/lecture_data_structure_182_crop_7.jpg	Aside from
crop_img/lecture_data_structure_182_crop_8.jpg	no gaps
crop_img/lecture_data_structure_182_crop_9.jpg	0
crop_img/lecture_data_structure_182_crop_10.jpg	•Two standard
crop_img/lecture_data_structure_182_crop_11.jpg	implementationx f List:
crop_img/lecture_data_structure_182_crop_12.jpg	. Array List
crop_img/lecture_data_structure_182_crop_13.jpg	Linked List
crop_img/lecture_data_structure_182_crop_14.jpg	) Array list
crop_img/lecture_data_structure_182_crop_15.jpg	Use an array as an underlying
crop_img/lecture_data_structure_182_crop_16.jpg	structure
crop_img/lecture_data_structure_182_crop_17.jpg	;
crop_img/lecture_data_structure_182_crop_18.jpg	• Add Back ()
crop_img/lecture_data_structure_182_crop_19.jpg	∴0(1)
crop_img/lecture_data_structure_182_crop_20.jpg	.If the underlying array is full → make the new array with
crop_img/lecture_data_structure_182_crop_21.jpg	similar data but larger capacity:(n)
crop_img/lecture_data_structure_182_crop_22.jpg	We denote this situation as o()*, where  =
crop_img/lecture_data_structure_182_crop_23.jpg	uL
crop_img/lecture_data_structure_182_crop_24.jpg	amortized
crop_img/lecture_data_structure_182_crop_25.jpg	刀
crop_img/lecture_data_structure_182_crop_26.jpg	" average worst case
crop_img/lecture_data_structure_182_crop_27.jpg	mostly fast, sometimes slow
crop_img/lecture_data_structure_183_crop_0.jpg	adding back time assume the underlying aa
crop_img/lecture_data_structure_183_crop_1.jpg	• Worst case
crop_img/lecture_data_structure_183_crop_2.jpg	of
crop_img/lecture_data_structure_183_crop_3.jpg	o(n)+(n-1)0(1)
crop_img/lecture_data_structure_183_crop_4.jpg	has size n
crop_img/lecture_data_structure_183_crop_5.jpg	=0(1)
crop_img/lecture_data_structure_183_crop_6.jpg	n
crop_img/lecture_data_structure_183_crop_7.jpg	. Add Front (): O ( a)
crop_img/lecture_data_structure_183_crop_8.jpg	Add AtIndex l) : o(n) (the worst case is that user want
crop_img/lecture_data_structure_183_crop_9.jpg	to add front)
crop_img/lecture_data_structure_183_crop_10.jpg	.Remove Back ( : remove the item (change it to null)
crop_img/lecture_data_structure_183_crop_11.jpg	Note : Extra work is okay if it is o(1)
crop_img/lecture_data_structure_183_crop_12.jpg	before Array over ArrayList when!
crop_img/lecture_data_structure_183_crop_13.jpg	Data in fixed size
crop_img/lecture_data_structure_183_crop_14.jpg	Want gaps
crop_img/lecture_data_structure_183_crop_15.jpg	save memory
crop_img/lecture_data_structure_183_crop_16.jpg	) single linked list: each data is stored with a pointer to the
crop_img/lecture_data_structure_183_crop_17.jpg	next node
crop_img/lecture_data_structure_183_crop_18.jpg	Py: data linked Node<T>
crop_img/lecture_data_structure_183_crop_19.jpg	Data
crop_img/lecture_data_structure_183_crop_20.jpg	Linked Node <T> next
crop_img/lecture_data_structure_183_crop_21.jpg	3
crop_img/lecture_data_structure_183_crop_22.jpg	data linked list <T> 
crop_img/lecture_data_structure_183_crop_23.jpg	LinkedNode<T> head
crop_img/lecture_data_structure_183_crop_24.jpg	int size
crop_img/lecture_data_structure_183_crop_25.jpg	3
crop_img/lecture_data_structure_184_crop_0.jpg	new Node = new linked Node (data)
crop_img/lecture_data_structure_184_crop_1.jpg	curr.next = new Node
crop_img/lecture_data_structure_184_crop_2.jpg	→0(n)
crop_img/lecture_data_structure_184_crop_3.jpg	. Add At Index (;)
crop_img/lecture_data_structure_184_crop_4.jpg	i_A
crop_img/lecture_data_structure_184_crop_5.jpg	i+
crop_img/lecture_data_structure_184_crop_6.jpg	7
crop_img/lecture_data_structure_184_crop_7.jpg	→X→
crop_img/lecture_data_structure_184_crop_8.jpg	□→□
crop_img/lecture_data_structure_184_crop_9.jpg	A.
crop_img/lecture_data_structure_184_crop_10.jpg	2,
crop_img/lecture_data_structure_184_crop_11.jpg	V
crop_img/lecture_data_structure_184_crop_12.jpg	D
crop_img/lecture_data_structure_184_crop_13.jpg	1
crop_img/lecture_data_structure_184_crop_14.jpg	. Remove First:
crop_img/lecture_data_structure_184_crop_15.jpg	head
crop_img/lecture_data_structure_184_crop_16.jpg	head
crop_img/lecture_data_structure_184_crop_17.jpg	→
crop_img/lecture_data_structure_184_crop_18.jpg	—
crop_img/lecture_data_structure_184_crop_19.jpg	口→
crop_img/lecture_data_structure_184_crop_20.jpg	D→
crop_img/lecture_data_structure_185_crop_0.jpg	↓
crop_img/lecture_data_structure_185_crop_1.jpg	waste? No if we are
crop_img/lecture_data_structure_185_crop_2.jpg	using java
crop_img/lecture_data_structure_185_crop_3.jpg	because it has a garbage
crop_img/lecture_data_structure_185_crop_4.jpg	collector that takes care
crop_img/lecture_data_structure_185_crop_5.jpg	of objects that is no longer
crop_img/lecture_data_structure_185_crop_6.jpg	accessed by both client & programmer
crop_img/lecture_data_structure_185_crop_7.jpg	.Remove last:
crop_img/lecture_data_structure_185_crop_8.jpg	n→null
crop_img/lecture_data_structure_185_crop_9.jpg	→
crop_img/lecture_data_structure_185_crop_10.jpg	D
crop_img/lecture_data_structure_185_crop_11.jpg	→
crop_img/lecture_data_structure_185_crop_12.jpg	—
crop_img/lecture_data_structure_185_crop_13.jpg	set this to null
crop_img/lecture_data_structure_185_crop_14.jpg	→wrong
crop_img/lecture_data_structure_185_crop_15.jpg	and to last
crop_img/lecture_data_structure_185_crop_16.jpg	口
crop_img/lecture_data_structure_185_crop_17.jpg	)→ □→null
crop_img/lecture_data_structure_185_crop_18.jpg	口
crop_img/lecture_data_structure_185_crop_19.jpg	→
crop_img/lecture_data_structure_185_crop_20.jpg	□
crop_img/lecture_data_structure_185_crop_21.jpg	→
crop_img/lecture_data_structure_185_crop_22.jpg	→
crop_img/lecture_data_structure_185_crop_23.jpg	null
crop_img/lecture_data_structure_185_crop_24.jpg	How to access the end to last? curr ,next,next ==null?
crop_img/lecture_data_structure_185_crop_25.jpg	ite =o→ Input validation
crop_img/lecture_data_structure_185_crop_26.jpg	·site =1→ Null exception
crop_img/lecture_data_structure_185_crop_27.jpg	20(n)
crop_img/lecture_data_structure_185_crop_28.jpg	AddFront remove +front → fast
crop_img/lecture_data_structure_185_crop_29.jpg	Add Back , Remove Back  slow
crop_img/lecture_data_structure_185_crop_30.jpg	→ We can add a “tail”
crop_img/lecture_data_structure_186_crop_0.jpg	int size
crop_img/lecture_data_structure_186_crop_1.jpg	tail
crop_img/lecture_data_structure_186_crop_2.jpg	□→→D
crop_img/lecture_data_structure_186_crop_3.jpg	1) Add back W tail
crop_img/lecture_data_structure_186_crop_4.jpg	tail.next = New Node(data)
crop_img/lecture_data_structure_186_crop_5.jpg	tail = tail.next
crop_img/lecture_data_structure_186_crop_6.jpg	.) Removl back w/tail.
crop_img/lecture_data_structure_186_crop_7.jpg	head
crop_img/lecture_data_structure_186_crop_8.jpg	D→ □→□→. →→D→N
crop_img/lecture_data_structure_186_crop_9.jpg	need
crop_img/lecture_data_structure_186_crop_10.jpg	and
crop_img/lecture_data_structure_186_crop_11.jpg	lar Node
crop_img/lecture_data_structure_186_crop_12.jpg	 hast travers
crop_img/lecture_data_structure_186_crop_13.jpg	the list again
crop_img/lecture_data_structure_186_crop_14.jpg	why don't we a pretail pointer?
crop_img/lecture_data_structure_186_crop_15.jpg	Aftor pretail → null
crop_img/lecture_data_structure_186_crop_16.jpg	tail → pretail
crop_img/lecture_data_structure_186_crop_17.jpg	pretail→???
crop_img/lecture_data_structure_186_crop_18.jpg	broken
crop_img/lecture_data_structure_186_crop_19.jpg	) How to step backward to the previous node
crop_img/lecture_data_structure_186_crop_20.jpg	) Doubly-Linked list: each node contains references to both
crop_img/lecture_data_structure_186_crop_21.jpg	the next and previous node
crop_img/lecture_data_structure_187_crop_0.jpg	.)Remove At Index:
crop_img/lecture_data_structure_187_crop_1.jpg	2
crop_img/lecture_data_structure_187_crop_2.jpg	D
crop_img/lecture_data_structure_187_crop_3.jpg	今
crop_img/lecture_data_structure_187_crop_4.jpg	K
crop_img/lecture_data_structure_187_crop_5.jpg	GC collector
crop_img/lecture_data_structure_187_crop_6.jpg	.)Why
crop_img/lecture_data_structure_187_crop_7.jpg	prefer sll over Dl:
crop_img/lecture_data_structure_187_crop_8.jpg	.OlL uses more memory
crop_img/lecture_data_structure_187_crop_9.jpg	. can hold more nodes in cache
crop_img/lecture_data_structure_187_crop_10.jpg	. less complicated code
crop_img/lecture_data_structure_187_crop_11.jpg	) Circular sll:
crop_img/lecture_data_structure_187_crop_12.jpg	→ □→→D
crop_img/lecture_data_structure_187_crop_13.jpg	兴
crop_img/lecture_data_structure_187_crop_14.jpg	90①
crop_img/lecture_data_structure_187_crop_15.jpg	. Add Front:
crop_img/lecture_data_structure_187_crop_16.jpg	→0-
crop_img/lecture_data_structure_187_crop_17.jpg	→. .,→□
crop_img/lecture_data_structure_187_crop_18.jpg	2
crop_img/lecture_data_structure_188_crop_0.jpg	. Add Back:
crop_img/lecture_data_structure_188_crop_1.jpg	① add Front (data)
crop_img/lecture_data_structure_188_crop_2.jpg	 move Front To back ()
crop_img/lecture_data_structure_188_crop_3.jpg	②
crop_img/lecture_data_structure_188_crop_4.jpg	head
crop_img/lecture_data_structure_188_crop_5.jpg	head=head.next
crop_img/lecture_data_structure_188_crop_6.jpg	new
crop_img/lecture_data_structure_188_crop_7.jpg	→□→.→D
crop_img/lecture_data_structure_188_crop_8.jpg	①
crop_img/lecture_data_structure_188_crop_9.jpg	. Remove Front:
crop_img/lecture_data_structure_188_crop_10.jpg	head
crop_img/lecture_data_structure_188_crop_11.jpg	gone
crop_img/lecture_data_structure_188_crop_12.jpg	→⑥→D→.→D
crop_img/lecture_data_structure_188_crop_13.jpg	head.data= head.next, data
crop_img/lecture_data_structure_188_crop_14.jpg	head, next = head, net . nut
crop_img/lecture_data_structure_188_crop_15.jpg	Not worked for csll with 1 node
crop_img/lecture_data_structure_188_crop_16.jpg	→iterate, stop at arr .next. next = head
crop_img/lecture_data_structure_189_crop_0.jpg	u
crop_img/lecture_data_structure_189_crop_1.jpg	. Revision:
crop_img/lecture_data_structure_189_crop_2.jpg	ptr rein forcement
crop_img/lecture_data_structure_189_crop_3.jpg	- each node determines whether it
crop_img/lecture_data_structure_189_crop_4.jpg	remains in the list
crop_img/lecture_data_structure_189_crop_5.jpg	. Remove Even :
crop_img/lecture_data_structure_189_crop_6.jpg	1→2→3→4→7→9
crop_img/lecture_data_structure_189_crop_7.jpg	1→3→ →9
crop_img/lecture_data_structure_189_crop_8.jpg	a node
crop_img/lecture_data_structure_189_crop_9.jpg	point somewhere else
crop_img/lecture_data_structure_189_crop_10.jpg	Effect of running
crop_img/lecture_data_structure_189_crop_11.jpg	1→4→7→6→2→8→3→ null
crop_img/lecture_data_structure_189_crop_12.jpg	⇒
crop_img/lecture_data_structure_189_crop_13.jpg	1→7→3
crop_img/lecture_data_structure_189_crop_14.jpg	The method Revive Helper should return the node that a node should
crop_img/lecture_data_structure_189_crop_15.jpg	point to
crop_img/lecture_data_structure_189_crop_16.jpg	Divide:
crop_img/lecture_data_structure_189_crop_17.jpg	T(n)=T(n-1)
crop_img/lecture_data_structure_189_crop_18.jpg	Conquer.
crop_img/lecture_data_structure_189_crop_19.jpg	w .nπt
crop_img/lecture_data_structure_189_crop_20.jpg	) little:
crop_img/lecture_data_structure_189_crop_21.jpg	only remove/add from top
crop_img/lecture_data_structure_189_crop_22.jpg	6
crop_img/lecture_data_structure_189_crop_23.jpg	60
crop_img/lecture_data_structure_189_crop_24.jpg	) Stack
crop_img/lecture_data_structure_189_crop_25.jpg	1
crop_img/lecture_data_structure_189_crop_26.jpg	0
crop_img/lecture_data_structure_189_crop_27.jpg	0
crop_img/lecture_data_structure_189_crop_28.jpg	0
crop_img/lecture_data_structure_189_crop_29.jpg	力
crop_img/lecture_data_structure_190_crop_0.jpg	Always remove the most recently added "newest data
crop_img/lecture_data_structure_190_crop_1.jpg	.The data at the bottom stay there the longest
crop_img/lecture_data_structure_190_crop_2.jpg	_
crop_img/lecture_data_structure_190_crop_3.jpg	(Last In First Out - LIFO)
crop_img/lecture_data_structure_190_crop_4.jpg	.Ex：
crop_img/lecture_data_structure_190_crop_5.jpg	Undo/ Redo
crop_img/lecture_data_structure_190_crop_6.jpg	undo 1
crop_img/lecture_data_structure_190_crop_7.jpg	J
crop_img/lecture_data_structure_190_crop_8.jpg	e
crop_img/lecture_data_structure_190_crop_9.jpg	undo
crop_img/lecture_data_structure_190_crop_10.jpg	@
crop_img/lecture_data_structure_190_crop_11.jpg	8
crop_img/lecture_data_structure_190_crop_12.jpg	C
crop_img/lecture_data_structure_190_crop_13.jpg	a
crop_img/lecture_data_structure_190_crop_14.jpg	し
crop_img/lecture_data_structure_190_crop_15.jpg	e
crop_img/lecture_data_structure_190_crop_16.jpg	a
crop_img/lecture_data_structure_190_crop_17.jpg	Redo
crop_img/lecture_data_structure_190_crop_18.jpg	Undo
crop_img/lecture_data_structure_190_crop_19.jpg	Behavior:
crop_img/lecture_data_structure_190_crop_20.jpg	add Top = push ()
crop_img/lecture_data_structure_190_crop_21.jpg	No add Bottom
crop_img/lecture_data_structure_190_crop_22.jpg	remove Top = pop ()
crop_img/lecture_data_structure_190_crop_23.jpg	remove bottom
crop_img/lecture_data_structure_190_crop_24.jpg	get Top = peek ()
crop_img/lecture_data_structure_190_crop_25.jpg	. Array Stack
crop_img/lecture_data_structure_190_crop_26.jpg	. Linked Stack
crop_img/lecture_data_structure_190_crop_27.jpg	. Linked Stack : use LinkedList
crop_img/lecture_data_structure_190_crop_28.jpg	front
crop_img/lecture_data_structure_190_crop_29.jpg	1
crop_img/lecture_data_structure_190_crop_30.jpg	. top = front
crop_img/lecture_data_structure_190_crop_31.jpg	back
crop_img/lecture_data_structure_190_crop_32.jpg	0()
crop_img/lecture_data_structure_190_crop_33.jpg	push = add Front
crop_img/lecture_data_structure_190_crop_34.jpg	pop = remove Front o(1)
crop_img/lecture_data_structure_190_crop_35.jpg	Implementation for linked stack is the same with Linked List
crop_img/lecture_data_structure_191_crop_0.jpg	back
crop_img/lecture_data_structure_191_crop_1.jpg	. Array stack: use Array List
crop_img/lecture_data_structure_191_crop_2.jpg	push = add Back
crop_img/lecture_data_structure_191_crop_3.jpg	. top = back
crop_img/lecture_data_structure_191_crop_4.jpg	front
crop_img/lecture_data_structure_191_crop_5.jpg	二
crop_img/lecture_data_structure_191_crop_6.jpg	S
crop_img/lecture_data_structure_191_crop_7.jpg	remove Back
crop_img/lecture_data_structure_191_crop_8.jpg	pop =
crop_img/lecture_data_structure_191_crop_9.jpg	problem & stack: don't have remove/add AtIndex
crop_img/lecture_data_structure_191_crop_10.jpg	If don't need those ) then choose Stack
crop_img/lecture_data_structure_191_crop_11.jpg	Add To back = enqueue
crop_img/lecture_data_structure_191_crop_12.jpg	No add/remove
crop_img/lecture_data_structure_191_crop_13.jpg	queue
crop_img/lecture_data_structure_191_crop_14.jpg	→
crop_img/lecture_data_structure_191_crop_15.jpg	→
crop_img/lecture_data_structure_191_crop_16.jpg	Remove From Front = dequeue
crop_img/lecture_data_structure_191_crop_17.jpg	：
crop_img/lecture_data_structure_191_crop_18.jpg	AtIndex
crop_img/lecture_data_structure_191_crop_19.jpg	back
crop_img/lecture_data_structure_191_crop_20.jpg	front
crop_img/lecture_data_structure_191_crop_21.jpg	· Linked queue: try using a linked list
crop_img/lecture_data_structure_191_crop_22.jpg	enqueue = add Front
crop_img/lecture_data_structure_191_crop_23.jpg	. add To Front
crop_img/lecture_data_structure_191_crop_24.jpg	dequeue = remove Back (hard)
crop_img/lecture_data_structure_191_crop_25.jpg	a
crop_img/lecture_data_structure_191_crop_26.jpg	Y
crop_img/lecture_data_structure_191_crop_27.jpg	0(1) → need tail
crop_img/lecture_data_structure_191_crop_28.jpg	enqueue = add back
crop_img/lecture_data_structure_191_crop_29.jpg	add To Back
crop_img/lecture_data_structure_191_crop_30.jpg	1
crop_img/lecture_data_structure_191_crop_31.jpg	dequeue = remove Front o(1)
crop_img/lecture_data_structure_191_crop_32.jpg	.Array same
crop_img/lecture_data_structure_191_crop_33.jpg	enqueue = add To Front o(n)
crop_img/lecture_data_structure_191_crop_34.jpg	add To Front
crop_img/lecture_data_structure_191_crop_35.jpg	⇒
crop_img/lecture_data_structure_191_crop_36.jpg	deque
crop_img/lecture_data_structure_191_crop_37.jpg	= remove From Back o(1)
crop_img/lecture_data_structure_191_crop_38.jpg	水
crop_img/lecture_data_structure_191_crop_39.jpg	. add To back ⇒
crop_img/lecture_data_structure_191_crop_40.jpg	enqueue = add to back 0(1)
crop_img/lecture_data_structure_191_crop_41.jpg	dequeue = remove Front o(n)
crop_img/lecture_data_structure_191_crop_42.jpg	⇒ Back Cannot use ArrayList
crop_img/lecture_data_structure_192_crop_0.jpg	Circular Array contiguous don't need to be O-aligned but
crop_img/lecture_data_structure_192_crop_1.jpg	must keep track of index
crop_img/lecture_data_structure_192_crop_2.jpg	4
crop_img/lecture_data_structure_192_crop_3.jpg	front
crop_img/lecture_data_structure_192_crop_4.jpg	front
crop_img/lecture_data_structure_192_crop_5.jpg	(front + id) % len
crop_img/lecture_data_structure_192_crop_6.jpg	lag
crop_img/lecture_data_structure_192_crop_7.jpg	3
crop_img/lecture_data_structure_192_crop_8.jpg	4
crop_img/lecture_data_structure_192_crop_9.jpg	2
crop_img/lecture_data_structure_192_crop_10.jpg	1
crop_img/lecture_data_structure_192_crop_11.jpg	6
crop_img/lecture_data_structure_192_crop_12.jpg	q0size () → a|b|c|d|e|
crop_img/lecture_data_structure_192_crop_13.jpg	.unqueue () = add back (front + size) % len (backA)
crop_img/lecture_data_structure_192_crop_14.jpg	2
crop_img/lecture_data_structure_192_crop_15.jpg	ffa{
crop_img/lecture_data_structure_192_crop_16.jpg	.dequeue () = remove Front ()
crop_img/lecture_data_structure_192_crop_17.jpg	|e||x|b|c|d→e|(b|c|d
crop_img/lecture_data_structure_192_crop_18.jpg	Dequeues (Double Ended Queue)
crop_img/lecture_data_structure_192_crop_19.jpg	add front
crop_img/lecture_data_structure_192_crop_20.jpg	add Back
crop_img/lecture_data_structure_192_crop_21.jpg	5
crop_img/lecture_data_structure_192_crop_22.jpg	Rem back
crop_img/lecture_data_structure_192_crop_23.jpg	rem Front
crop_img/lecture_data_structure_192_crop_24.jpg	1
crop_img/lecture_data_structure_192_crop_25.jpg	tail
crop_img/lecture_data_structure_192_crop_26.jpg	deque
crop_img/lecture_data_structure_192_crop_27.jpg	escalator:
crop_img/lecture_data_structure_192_crop_28.jpg	queue
crop_img/lecture_data_structure_192_crop_29.jpg	. elevator: stack
crop_img/lecture_data_structure_192_crop_30.jpg	) Linked deque:
crop_img/lecture_data_structure_192_crop_31.jpg	. LinkedStack: sLL
crop_img/lecture_data_structure_192_crop_32.jpg	. Linked Queue : SLL W/ tail, cache
crop_img/lecture_data_structure_192_crop_33.jpg	. Linked Deque : DLL
crop_img/lecture_data_structure_192_crop_34.jpg	↓
crop_img/lecture_data_structure_192_crop_35.jpg	make remBack() o() too
crop_img/lecture_data_structure_193_crop_0.jpg	Linked Deque is DlL without add Index () & rem Index )
crop_img/lecture_data_structure_193_crop_1.jpg	Array Deque :
crop_img/lecture_data_structure_193_crop_2.jpg	Array Stack
crop_img/lecture_data_structure_193_crop_3.jpg	array List
crop_img/lecture_data_structure_193_crop_4.jpg	:
crop_img/lecture_data_structure_193_crop_5.jpg	circular array
crop_img/lecture_data_structure_193_crop_6.jpg	Array Queue:
crop_img/lecture_data_structure_193_crop_7.jpg	array Deque:
crop_img/lecture_data_structure_193_crop_8.jpg	circular day
crop_img/lecture_data_structure_193_crop_9.jpg	add Back ()
crop_img/lecture_data_structure_193_crop_10.jpg	from
crop_img/lecture_data_structure_193_crop_11.jpg	Linked Queue
crop_img/lecture_data_structure_193_crop_12.jpg	Rem Front ()
crop_img/lecture_data_structure_193_crop_13.jpg	add Front () :
crop_img/lecture_data_structure_193_crop_14.jpg	ff{{}
crop_img/lecture_data_structure_193_crop_15.jpg	el
crop_img/lecture_data_structure_193_crop_16.jpg	a（bcld
crop_img/lecture_data_structure_193_crop_17.jpg	l
crop_img/lecture_data_structure_193_crop_18.jpg	e
crop_img/lecture_data_structure_193_crop_19.jpg	ablcld
crop_img/lecture_data_structure_193_crop_20.jpg	2
crop_img/lecture_data_structure_193_crop_21.jpg	a
crop_img/lecture_data_structure_193_crop_22.jpg	\
crop_img/lecture_data_structure_193_crop_23.jpg	8
crop_img/lecture_data_structure_193_crop_24.jpg	.Note:
crop_img/lecture_data_structure_193_crop_25.jpg	ae|c|d|e|
crop_img/lecture_data_structure_193_crop_26.jpg	-1
crop_img/lecture_data_structure_193_crop_27.jpg	eon
crop_img/lecture_data_structure_193_crop_28.jpg	Move f to front in CAsr:
crop_img/lecture_data_structure_193_crop_29.jpg	8=(f-1)%len(back+ππ)
crop_img/lecture_data_structure_193_crop_30.jpg	Problem:"l in java is not mod, it& remainder
crop_img/lecture_data_structure_193_crop_31.jpg	Sol:
crop_img/lecture_data_structure_193_crop_32.jpg	f=f-1$
crop_img/lecture_data_structure_193_crop_33.jpg	i(8==-1)= len(back ta)-1
crop_img/lecture_data_structure_193_crop_34.jpg	. qembach () :
crop_img/lecture_data_structure_194_crop_0.jpg	2
crop_img/lecture_data_structure_194_crop_1.jpg	f
crop_img/lecture_data_structure_194_crop_2.jpg	f
crop_img/lecture_data_structure_194_crop_3.jpg	|el|x|b|c|d→[e|
crop_img/lecture_data_structure_194_crop_4.jpg	(blcld
crop_img/lecture_data_structure_194_crop_5.jpg	1
crop_img/lecture_data_structure_194_crop_6.jpg	f=（f+1)l0 len(back+πn)
crop_img/lecture_data_structure_194_crop_7.jpg	V
crop_img/lecture_data_structure_194_crop_8.jpg	20→no problem
crop_img/lecture_data_structure_194_crop_9.jpg	Why don't use CAor instead AraList?
crop_img/lecture_data_structure_194_crop_10.jpg	Doing mod is more expensive than just t/-
crop_img/lecture_data_structure_194_crop_11.jpg	Tree: nodes connected by edges where
crop_img/lecture_data_structure_194_crop_12.jpg	parent
crop_img/lecture_data_structure_194_crop_13.jpg	0
crop_img/lecture_data_structure_194_crop_14.jpg	→0
crop_img/lecture_data_structure_194_crop_15.jpg	child
crop_img/lecture_data_structure_194_crop_16.jpg	A node can have any # of children
crop_img/lecture_data_structure_194_crop_17.jpg	can only have o one I parent
crop_img/lecture_data_structure_194_crop_18.jpg	Exactly
crop_img/lecture_data_structure_194_crop_19.jpg	I node with o parent
crop_img/lecture_data_structure_194_crop_20.jpg	No cycles
crop_img/lecture_data_structure_194_crop_21.jpg	leaf
crop_img/lecture_data_structure_194_crop_22.jpg	Node that has o children
crop_img/lecture_data_structure_194_crop_23.jpg	Internal node : node that is not a leaf
crop_img/lecture_data_structure_194_crop_24.jpg	g
crop_img/lecture_data_structure_194_crop_25.jpg	A
crop_img/lecture_data_structure_194_crop_26.jpg	A)B are the ancestors of C
crop_img/lecture_data_structure_194_crop_27.jpg	.
crop_img/lecture_data_structure_194_crop_28.jpg	descendants of
crop_img/lecture_data_structure_194_crop_29.jpg	B)C—
crop_img/lecture_data_structure_194_crop_30.jpg	C)0 are siblings
crop_img/lecture_data_structure_194_crop_31.jpg	depth of c is a ) height of A is 2
crop_img/lecture_data_structure_195_crop_0.jpg	Subtree
crop_img/lecture_data_structure_195_crop_1.jpg	depth
crop_img/lecture_data_structure_195_crop_2.jpg	depth of parent +1
crop_img/lecture_data_structure_195_crop_3.jpg	Height : max (height of kids)+1
crop_img/lecture_data_structure_195_crop_4.jpg	γ
crop_img/lecture_data_structure_195_crop_5.jpg	Full : BT is full if each node has exactly o or a kids
crop_img/lecture_data_structure_195_crop_6.jpg	0
crop_img/lecture_data_structure_195_crop_7.jpg	O
crop_img/lecture_data_structure_195_crop_8.jpg	Complete : BT is complete if
crop_img/lecture_data_structure_195_crop_9.jpg	lowest
crop_img/lecture_data_structure_195_crop_10.jpg	depth
crop_img/lecture_data_structure_195_crop_11.jpg	Each depth of the tree except the lowest must have maximum
crop_img/lecture_data_structure_195_crop_12.jpg	# nodes
crop_img/lecture_data_structure_195_crop_13.jpg	2
crop_img/lecture_data_structure_195_crop_14.jpg	lowest depth must be filled from left→ right
crop_img/lecture_data_structure_195_crop_15.jpg	For each tree is exactly one shape a complete tree has
crop_img/lecture_data_structure_195_crop_16.jpg	balanced: A node is balanced if its children have height that differ
crop_img/lecture_data_structure_195_crop_17.jpg	?
crop_img/lecture_data_structure_195_crop_18.jpg	by 0 or 1. A tree is balanced if every node is balanced
crop_img/lecture_data_structure_195_crop_19.jpg	The height of null node is -1
crop_img/lecture_data_structure_195_crop_20.jpg	leaf nodes are always balanced
crop_img/lecture_data_structure_195_crop_21.jpg	full but not balanced
crop_img/lecture_data_structure_195_crop_22.jpg	complete but not full
crop_img/lecture_data_structure_195_crop_23.jpg	balanced but not complete
crop_img/lecture_data_structure_195_crop_24.jpg	0
crop_img/lecture_data_structure_195_crop_25.jpg	80
crop_img/lecture_data_structure_195_crop_26.jpg	2
crop_img/lecture_data_structure_195_crop_27.jpg	Heap: a data structure that stores data in a tree-based struct where
crop_img/lecture_data_structure_195_crop_28.jpg	Binary Search Tree : A binary tree where :
crop_img/lecture_data_structure_197_crop_0.jpg	Add (): we add to leaf
crop_img/lecture_data_structure_197_crop_1.jpg	x
crop_img/lecture_data_structure_197_crop_2.jpg	goes down
crop_img/lecture_data_structure_197_crop_3.jpg	where v should be
crop_img/lecture_data_structure_197_crop_4.jpg	public void Add(T data)
crop_img/lecture_data_structure_197_crop_5.jpg	(c+n node reps cr
crop_img/lecture_data_structure_197_crop_6.jpg	root = addH(root, data)
crop_img/lecture_data_structure_197_crop_7.jpg	tr reinforcement
crop_img/lecture_data_structure_197_crop_8.jpg	private Node addH(Node curr, T data):
crop_img/lecture_data_structure_197_crop_9.jpg	if curr == null:
crop_img/lecture_data_structure_197_crop_10.jpg	Node newNode = new Node(data)
crop_img/lecture_data_structure_197_crop_11.jpg	→ replace null w new Node
crop_img/lecture_data_structure_197_crop_12.jpg	return newNode
crop_img/lecture_data_structure_197_crop_13.jpg	if curr.data == data:
crop_img/lecture_data_structure_197_crop_14.jpg	// do nothing, data already in tree
crop_img/lecture_data_structure_197_crop_15.jpg	if curr.data < data:
crop_img/lecture_data_structure_197_crop_16.jpg	// recurse right
crop_img/lecture_data_structure_197_crop_17.jpg	curr.right = addH(curr.right, data)
crop_img/lecture_data_structure_197_crop_18.jpg	if curr.data > data:
crop_img/lecture_data_structure_197_crop_19.jpg	// recurse left
crop_img/lecture_data_structure_197_crop_20.jpg	curr.left = addH(curr.left, data)
crop_img/lecture_data_structure_197_crop_21.jpg	return curr
crop_img/lecture_data_structure_197_crop_22.jpg	. Remove() :
crop_img/lecture_data_structure_197_crop_23.jpg	• If no children : similar to add
crop_img/lecture_data_structure_197_crop_24.jpg	Has 1 child : remove 55
crop_img/lecture_data_structure_197_crop_25.jpg	34
crop_img/lecture_data_structure_197_crop_26.jpg	Solution : connect 34 to 76
crop_img/lecture_data_structure_197_crop_27.jpg	7
crop_img/lecture_data_structure_197_crop_28.jpg	55
crop_img/lecture_data_structure_197_crop_29.jpg	22
crop_img/lecture_data_structure_197_crop_30.jpg	/
crop_img/lecture_data_structure_197_crop_31.jpg	18
crop_img/lecture_data_structure_197_crop_32.jpg	31
crop_img/lecture_data_structure_197_crop_33.jpg	76
crop_img/lecture_data_structure_197_crop_34.jpg	. How 2 children :
crop_img/lecture_data_structure_197_crop_35.jpg	Successor of x is the smallest data item in tree
crop_img/lecture_data_structure_197_crop_36.jpg	. Predecessor of x is the largest
crop_img/lecture_data_structure_197_crop_37.jpg	∠x
crop_img/lecture_data_structure_197_crop_38.jpg	. Finding
crop_img/lecture_data_structure_197_crop_39.jpg	Successor : 1 right  left until goes to the end
crop_img/lecture_data_structure_197_crop_40.jpg	predecessor; 1 left → right
crop_img/lecture_data_structure_198_crop_0.jpg	When removing a node with a child, the node doesn't
crop_img/lecture_data_structure_198_crop_1.jpg	go away but replaced with predecessor/ successor's data.
crop_img/lecture_data_structure_198_crop_2.jpg	The predecessor/ successor that we used will be removed
crop_img/lecture_data_structure_198_crop_3.jpg	(removing with 1/0 child this time)
crop_img/lecture_data_structure_198_crop_4.jpg	.problem with coding in Java regarding ptr reinforcement
crop_img/lecture_data_structure_198_crop_5.jpg	remove
crop_img/lecture_data_structure_198_crop_6.jpg	1. remove x
crop_img/lecture_data_structure_198_crop_7.jpg	2. what is at?
crop_img/lecture_data_structure_198_crop_8.jpg	return 2
crop_img/lecture_data_structure_198_crop_9.jpg	things → hard to
crop_img/lecture_data_structure_198_crop_10.jpg	3. what was removed
crop_img/lecture_data_structure_198_crop_11.jpg	do in Java
crop_img/lecture_data_structure_198_crop_12.jpg	↓
crop_img/lecture_data_structure_198_crop_13.jpg	share in a dummy node
crop_img/lecture_data_structure_198_crop_14.jpg	) Priority queue: each item has some assigned priority
crop_img/lecture_data_structure_198_crop_15.jpg	enqueue()
crop_img/lecture_data_structure_198_crop_16.jpg	dequeue() → removes highest prio data
crop_img/lecture_data_structure_198_crop_17.jpg	●
crop_img/lecture_data_structure_198_crop_18.jpg	enqueue(14)
crop_img/lecture_data_structure_198_crop_19.jpg	V
crop_img/lecture_data_structure_198_crop_20.jpg	H
crop_img/lecture_data_structure_198_crop_21.jpg	$7\fr1
crop_img/lecture_data_structure_198_crop_22.jpg	C5
crop_img/lecture_data_structure_198_crop_23.jpg	→
crop_img/lecture_data_structure_198_crop_24.jpg	1552
crop_img/lecture_data_structure_198_crop_25.jpg	7
crop_img/lecture_data_structure_198_crop_26.jpg	using heap
crop_img/lecture_data_structure_198_crop_27.jpg	using BST
crop_img/lecture_data_structure_198_crop_28.jpg	) Heap :
crop_img/lecture_data_structure_198_crop_29.jpg	d conditions
crop_img/lecture_data_structure_199_crop_0.jpg	3
crop_img/lecture_data_structure_199_crop_1.jpg	9
crop_img/lecture_data_structure_199_crop_2.jpg	empty
crop_img/lecture_data_structure_199_crop_3.jpg	4
crop_img/lecture_data_structure_199_crop_4.jpg	9
crop_img/lecture_data_structure_199_crop_5.jpg	o
crop_img/lecture_data_structure_199_crop_6.jpg	kids
crop_img/lecture_data_structure_199_crop_7.jpg	data at index i, 2i, dit1
crop_img/lecture_data_structure_199_crop_8.jpg	parent
crop_img/lecture_data_structure_199_crop_9.jpg	. Add():
crop_img/lecture_data_structure_199_crop_10.jpg	• Maintain completeness
crop_img/lecture_data_structure_199_crop_11.jpg	. Fix order
crop_img/lecture_data_structure_199_crop_12.jpg	(U, Heap)
crop_img/lecture_data_structure_199_crop_13.jpg	in good relationship w parent
crop_img/lecture_data_structure_199_crop_14.jpg	terminating condition
crop_img/lecture_data_structure_199_crop_15.jpg	at root
crop_img/lecture_data_structure_199_crop_16.jpg	Runtime: O(log(n))
crop_img/lecture_data_structure_200_crop_0.jpg	.
crop_img/lecture_data_structure_200_crop_1.jpg	Max heap
crop_img/lecture_data_structure_200_crop_2.jpg	highest order (root)
crop_img/lecture_data_structure_200_crop_3.jpg	lowest order in this
crop_img/lecture_data_structure_200_crop_4.jpg	(a leaf)
crop_img/lecture_data_structure_200_crop_5.jpg	) Remove():
crop_img/lecture_data_structure_200_crop_6.jpg	new root
crop_img/lecture_data_structure_200_crop_7.jpg	• Remove root
crop_img/lecture_data_structure_200_crop_8.jpg	Downheap cases for a the right most leaf when it becomes the
crop_img/lecture_data_structure_200_crop_9.jpg	. 2 good kids → done
crop_img/lecture_data_structure_200_crop_10.jpg	1 good, 1 bad → swap with bad
crop_img/lecture_data_structure_200_crop_11.jpg	a bad
crop_img/lecture_data_structure_200_crop_12.jpg	→ swap with higher order
crop_img/lecture_data_structure_200_crop_13.jpg	. stop if
crop_img/lecture_data_structure_200_crop_14.jpg	becomes a leaf (has data at index di, di+1)
crop_img/lecture_data_structure_200_crop_15.jpg	d
crop_img/lecture_data_structure_200_crop_16.jpg	gord reflection ship
crop_img/lecture_data_structure_200_crop_17.jpg	32
crop_img/lecture_data_structure_200_crop_18.jpg	Run qmovel):
crop_img/lecture_data_structure_200_crop_19.jpg	swap
crop_img/lecture_data_structure_200_crop_20.jpg	1
crop_img/lecture_data_structure_200_crop_21.jpg	人5
crop_img/lecture_data_structure_200_crop_22.jpg	10
crop_img/lecture_data_structure_200_crop_23.jpg	swap
crop_img/lecture_data_structure_200_crop_24.jpg	2536
crop_img/lecture_data_structure_200_crop_25.jpg	16
crop_img/lecture_data_structure_200_crop_26.jpg	Al
crop_img/lecture_data_structure_200_crop_27.jpg	αA
crop_img/lecture_data_structure_200_crop_28.jpg	19
crop_img/lecture_data_structure_201_crop_0.jpg	10
crop_img/lecture_data_structure_201_crop_1.jpg	7
crop_img/lecture_data_structure_201_crop_2.jpg	/
crop_img/lecture_data_structure_201_crop_3.jpg	15
crop_img/lecture_data_structure_201_crop_4.jpg	M
crop_img/lecture_data_structure_201_crop_5.jpg	1
crop_img/lecture_data_structure_201_crop_6.jpg	/
crop_img/lecture_data_structure_201_crop_7.jpg	32
crop_img/lecture_data_structure_201_crop_8.jpg	2536
crop_img/lecture_data_structure_201_crop_9.jpg	16
crop_img/lecture_data_structure_201_crop_10.jpg	/
crop_img/lecture_data_structure_201_crop_11.jpg	21
crop_img/lecture_data_structure_201_crop_12.jpg	lg
crop_img/lecture_data_structure_201_crop_13.jpg	) build heap() :
crop_img/lecture_data_structure_201_crop_14.jpg	Input : det a Ago [n]
crop_img/lecture_data_structure_201_crop_15.jpg	out put: Heap with the data
crop_img/lecture_data_structure_201_crop_16.jpg	Methodl : add n times⇒
crop_img/lecture_data_structure_201_crop_17.jpg	0 (n log n)
crop_img/lecture_data_structure_201_crop_18.jpg	Method2:
crop_img/lecture_data_structure_201_crop_19.jpg	A
crop_img/lecture_data_structure_201_crop_20.jpg	For each internal node in reverse order.
crop_img/lecture_data_structure_201_crop_21.jpg	down Heap (n)
crop_img/lecture_data_structure_201_crop_22.jpg	⇒0(n)
crop_img/lecture_data_structure_201_crop_23.jpg	Binary
crop_img/lecture_data_structure_201_crop_24.jpg	) Given af, how many swap maximum to get the binary
crop_img/lecture_data_structure_201_crop_25.jpg	heap?
crop_img/lecture_data_structure_201_crop_26.jpg	→
crop_img/lecture_data_structure_201_crop_27.jpg	∑ heights()
crop_img/lecture_data_structure_201_crop_28.jpg	) Hash Map : store <key, value >pair
crop_img/lecture_data_structure_201_crop_29.jpg	.Rules for key : must be unique, immutable
crop_img/lecture_data_structure_201_crop_30.jpg	put key() add new (key, value) to the Map
crop_img/lecture_data_structure_202_crop_0.jpg	if already has the key → replace old value with
crop_img/lecture_data_structure_202_crop_1.jpg	new value
crop_img/lecture_data_structure_202_crop_2.jpg	get key ()
crop_img/lecture_data_structure_202_crop_3.jpg	backing
crop_img/lecture_data_structure_202_crop_4.jpg	put key() : use array ( get()of this object)
crop_img/lecture_data_structure_202_crop_5.jpg	the index derived from the hash code of the object
crop_img/lecture_data_structure_202_crop_6.jpg	.what if key is not an int?→ use hash code ()
crop_img/lecture_data_structure_202_crop_7.jpg	hash Code () . d properties
crop_img/lecture_data_structure_202_crop_8.jpg	.Mandatory : a2 equals () object has the same hash code
crop_img/lecture_data_structure_202_crop_9.jpg	.Nice to have: a diff object has diff hash code
crop_img/lecture_data_structure_202_crop_10.jpg	·hashcode index abs(hashcode % array length)
crop_img/lecture_data_structure_202_crop_11.jpg	collision: trying to put key into an index where there is already
crop_img/lecture_data_structure_202_crop_12.jpg	a key
crop_img/lecture_data_structure_202_crop_13.jpg	. We can rewrite the back trace to reduce collision rate
crop_img/lecture_data_structure_202_crop_14.jpg	→rewrite before full the proportion we should resize at
crop_img/lecture_data_structure_202_crop_15.jpg	in called load factor)
crop_img/lecture_data_structure_203_crop_0.jpg	for i= 0,1,
crop_img/lecture_data_structure_203_crop_1.jpg	Increment : when node key i occupy
crop_img/lecture_data_structure_203_crop_2.jpg	k+i2>ln→ index=(k+i²2)/。len
crop_img/lecture_data_structure_203_crop_3.jpg	if
crop_img/lecture_data_structure_203_crop_4.jpg	1
crop_img/lecture_data_structure_203_crop_5.jpg	solve po of lin.probing but have to resize manner
crop_img/lecture_data_structure_203_crop_6.jpg	Better plan:
crop_img/lecture_data_structure_203_crop_7.jpg	) Run Binary search on Linkedlist
crop_img/lecture_data_structure_203_crop_8.jpg	.One approach : 2 linked list stacked
crop_img/lecture_data_structure_203_crop_9.jpg	Still o(n) (no mid t for left/right linkedlist)
crop_img/lecture_data_structure_203_crop_10.jpg	Skiplist: stacking several linked lists on top of each other
crop_img/lecture_data_structure_203_crop_11.jpg	Each node contain refs to: next, previous, above, below
crop_img/lecture_data_structure_203_crop_12.jpg	0
crop_img/lecture_data_structure_203_crop_13.jpg	Node must obey rules:
crop_img/lecture_data_structure_203_crop_14.jpg	。
crop_img/lecture_data_structure_203_crop_15.jpg	All data must be in lowest level
crop_img/lecture_data_structure_203_crop_16.jpg	If in levels, must be in all lower levels
crop_img/lecture_data_structure_203_crop_17.jpg	(name of creators)
crop_img/lecture_data_structure_203_crop_18.jpg	) AVL: self-balancing BST
crop_img/lecture_data_structure_203_crop_19.jpg	 balance factor := node.left.height-node.right.height
crop_img/lecture_data_structure_203_crop_20.jpg	. Each node contains height and bf
crop_img/lecture_data_structure_204_crop_0.jpg	· null node has height -1
crop_img/lecture_data_structure_204_crop_1.jpg	[-1,1]: good
crop_img/lecture_data_structure_204_crop_2.jpg	-2092
crop_img/lecture_data_structure_204_crop_3.jpg	unbalanced → not good → have to rebalance
crop_img/lecture_data_structure_204_crop_4.jpg	)AVL(s add () : scan a BST to find unbalanced nodes
crop_img/lecture_data_structure_204_crop_5.jpg	0) Fixing unbalance : Rotate the unbalanced node subtree
crop_img/lecture_data_structure_204_crop_6.jpg	$$
crop_img/lecture_data_structure_204_crop_7.jpg	A
crop_img/lecture_data_structure_204_crop_8.jpg	B
crop_img/lecture_data_structure_204_crop_9.jpg	left
crop_img/lecture_data_structure_204_crop_10.jpg	A
crop_img/lecture_data_structure_204_crop_11.jpg	B
crop_img/lecture_data_structure_204_crop_12.jpg	A
crop_img/lecture_data_structure_204_crop_13.jpg	C
crop_img/lecture_data_structure_204_crop_14.jpg	Do when node. bf = -2
crop_img/lecture_data_structure_204_crop_15.jpg	node. right.bf =-1 or 0
crop_img/lecture_data_structure_204_crop_16.jpg	Note
crop_img/lecture_data_structure_204_crop_17.jpg	B
crop_img/lecture_data_structure_204_crop_18.jpg	:
crop_img/lecture_data_structure_204_crop_19.jpg	A
crop_img/lecture_data_structure_204_crop_20.jpg	left
crop_img/lecture_data_structure_204_crop_21.jpg	C
crop_img/lecture_data_structure_204_crop_22.jpg	→
crop_img/lecture_data_structure_204_crop_23.jpg	A
crop_img/lecture_data_structure_204_crop_24.jpg	B
crop_img/lecture_data_structure_204_crop_25.jpg	ρ
crop_img/lecture_data_structure_204_crop_26.jpg	D
crop_img/lecture_data_structure_204_crop_27.jpg	.right
crop_img/lecture_data_structure_204_crop_28.jpg	A
crop_img/lecture_data_structure_204_crop_29.jpg	B
crop_img/lecture_data_structure_204_crop_30.jpg	A
crop_img/lecture_data_structure_204_crop_31.jpg	B
crop_img/lecture_data_structure_204_crop_32.jpg	↓
crop_img/lecture_data_structure_204_crop_33.jpg	-
crop_img/lecture_data_structure_204_crop_34.jpg	C
crop_img/lecture_data_structure_204_crop_35.jpg	②
crop_img/lecture_data_structure_204_crop_36.jpg	dangerous
crop_img/lecture_data_structure_204_crop_37.jpg	4
crop_img/lecture_data_structure_204_crop_38.jpg	3
crop_img/lecture_data_structure_204_crop_39.jpg	4
crop_img/lecture_data_structure_204_crop_40.jpg	3
crop_img/lecture_data_structure_204_crop_41.jpg	node
crop_img/lecture_data_structure_204_crop_42.jpg	B
crop_img/lecture_data_structure_204_crop_43.jpg	A
crop_img/lecture_data_structure_204_crop_44.jpg	l
crop_img/lecture_data_structure_204_crop_45.jpg	·Node
crop_img/lecture_data_structure_204_crop_46.jpg	→ get nothing
crop_img/lecture_data_structure_204_crop_47.jpg	A
crop_img/lecture_data_structure_204_crop_48.jpg	B
crop_img/lecture_data_structure_204_crop_49.jpg	C
crop_img/lecture_data_structure_204_crop_50.jpg	high↓
crop_img/lecture_data_structure_204_crop_51.jpg	B
crop_img/lecture_data_structure_205_crop_0.jpg	.sight -left rotation: node,of =-2,node.right.bf =1
crop_img/lecture_data_structure_205_crop_1.jpg	A
crop_img/lecture_data_structure_205_crop_2.jpg	C
crop_img/lecture_data_structure_205_crop_3.jpg	A
crop_img/lecture_data_structure_205_crop_4.jpg	6
crop_img/lecture_data_structure_205_crop_5.jpg	→
crop_img/lecture_data_structure_205_crop_6.jpg	→
crop_img/lecture_data_structure_205_crop_7.jpg	A
crop_img/lecture_data_structure_205_crop_8.jpg	B
crop_img/lecture_data_structure_205_crop_9.jpg	C
crop_img/lecture_data_structure_205_crop_10.jpg	B
crop_img/lecture_data_structure_205_crop_11.jpg	B
crop_img/lecture_data_structure_205_crop_12.jpg	Q
crop_img/lecture_data_structure_205_crop_13.jpg	C
crop_img/lecture_data_structure_205_crop_14.jpg	.there may be dangerous node
crop_img/lecture_data_structure_205_crop_15.jpg	. left -right rotation : node.bf =2
crop_img/lecture_data_structure_205_crop_16.jpg	node,left.BF =-1
crop_img/lecture_data_structure_205_crop_17.jpg	A
crop_img/lecture_data_structure_205_crop_18.jpg	A
crop_img/lecture_data_structure_205_crop_19.jpg	C
crop_img/lecture_data_structure_205_crop_20.jpg	C
crop_img/lecture_data_structure_205_crop_21.jpg	V
crop_img/lecture_data_structure_205_crop_22.jpg	B
crop_img/lecture_data_structure_205_crop_23.jpg	A
crop_img/lecture_data_structure_205_crop_24.jpg	「
crop_img/lecture_data_structure_205_crop_25.jpg	→
crop_img/lecture_data_structure_205_crop_26.jpg	B
crop_img/lecture_data_structure_205_crop_27.jpg	V
crop_img/lecture_data_structure_205_crop_28.jpg	B
crop_img/lecture_data_structure_205_crop_29.jpg	C
crop_img/lecture_data_structure_205_crop_30.jpg	) a-4 trs: tree, but each node can have 1,2, or 3 items)sorted, and
crop_img/lecture_data_structure_205_crop_31.jpg	# key=$ data+1
crop_img/lecture_data_structure_205_crop_32.jpg	.Shape property: all leaves at the same depth
crop_img/lecture_data_structure_205_crop_33.jpg	order property
crop_img/lecture_data_structure_205_crop_34.jpg	y
crop_img/lecture_data_structure_205_crop_35.jpg	d3
crop_img/lecture_data_structure_205_crop_36.jpg	a
crop_img/lecture_data_structure_205_crop_37.jpg	t4(> d{3)
crop_img/lecture_data_structure_205_crop_38.jpg	入2
crop_img/lecture_data_structure_205_crop_39.jpg	*
crop_img/lecture_data_structure_205_crop_40.jpg	t3
crop_img/lecture_data_structure_205_crop_41.jpg	(<d₁）（d₁<…<d2）（d<...<d₃）
crop_img/lecture_data_structure_206_crop_0.jpg	) 2-4 add:Use 2-4 container () to find node
crop_img/lecture_data_structure_206_crop_1.jpg	Add to it still
crop_img/lecture_data_structure_206_crop_2.jpg	. What if the leaf is full ( i.e.3items)
crop_img/lecture_data_structure_206_crop_3.jpg	→still add) temporarily overflow"→
crop_img/lecture_data_structure_206_crop_4.jpg	push and/39d
crop_img/lecture_data_structure_206_crop_5.jpg	data to parent and split the parent node to & nodes
crop_img/lecture_data_structure_206_crop_6.jpg	What if parent is full! do the same thing and we have
crop_img/lecture_data_structure_206_crop_7.jpg	a new parent
crop_img/lecture_data_structure_206_crop_8.jpg	8
crop_img/lecture_data_structure_206_crop_9.jpg	25
crop_img/lecture_data_structure_206_crop_10.jpg	78
crop_img/lecture_data_structure_206_crop_11.jpg	8
crop_img/lecture_data_structure_206_crop_12.jpg	25
crop_img/lecture_data_structure_206_crop_13.jpg	78
crop_img/lecture_data_structure_206_crop_14.jpg	→
crop_img/lecture_data_structure_206_crop_15.jpg	80
crop_img/lecture_data_structure_206_crop_16.jpg	3
crop_img/lecture_data_structure_206_crop_17.jpg	12,14
crop_img/lecture_data_structure_206_crop_18.jpg	425566477
crop_img/lecture_data_structure_206_crop_19.jpg	3
crop_img/lecture_data_structure_206_crop_20.jpg	么2，64，77
crop_img/lecture_data_structure_206_crop_21.jpg	80
crop_img/lecture_data_structure_206_crop_22.jpg	2，14
crop_img/lecture_data_structure_206_crop_23.jpg	overflow
crop_img/lecture_data_structure_206_crop_24.jpg	↑
crop_img/lecture_data_structure_206_crop_25.jpg	56
crop_img/lecture_data_structure_206_crop_26.jpg	25
crop_img/lecture_data_structure_206_crop_27.jpg	7
crop_img/lecture_data_structure_206_crop_28.jpg	overflow
crop_img/lecture_data_structure_206_crop_29.jpg	56 78
crop_img/lecture_data_structure_206_crop_30.jpg	8
crop_img/lecture_data_structure_206_crop_31.jpg	25
crop_img/lecture_data_structure_206_crop_32.jpg	56
crop_img/lecture_data_structure_206_crop_33.jpg	78
crop_img/lecture_data_structure_206_crop_34.jpg	8.
crop_img/lecture_data_structure_206_crop_35.jpg	→
crop_img/lecture_data_structure_206_crop_36.jpg	→
crop_img/lecture_data_structure_206_crop_37.jpg	1214 42 6477 80
crop_img/lecture_data_structure_206_crop_38.jpg	3
crop_img/lecture_data_structure_206_crop_39.jpg	80
crop_img/lecture_data_structure_206_crop_40.jpg	64,77
crop_img/lecture_data_structure_206_crop_41.jpg	12,14
crop_img/lecture_data_structure_206_crop_42.jpg	42
crop_img/lecture_data_structure_206_crop_43.jpg	3
crop_img/lecture_data_structure_206_crop_44.jpg	) a-4 remove
crop_img/lecture_data_structure_206_crop_45.jpg	c
crop_img/lecture_data_structure_206_crop_46.jpg	Case 1: remove data from leaf with 2 or more data
crop_img/lecture_data_structure_206_crop_47.jpg	→ Just delete
crop_img/lecture_data_structure_207_crop_0.jpg	Case a: remove from internal nodes
crop_img/lecture_data_structure_207_crop_1.jpg	→ replace data with predecessor or successor
crop_img/lecture_data_structure_207_crop_2.jpg	63
crop_img/lecture_data_structure_207_crop_3.jpg	. Replace in
crop_img/lecture_data_structure_207_crop_4.jpg	a leaf with
crop_img/lecture_data_structure_207_crop_5.jpg	2
crop_img/lecture_data_structure_207_crop_6.jpg	12
crop_img/lecture_data_structure_207_crop_7.jpg	47
crop_img/lecture_data_structure_207_crop_8.jpg	51
crop_img/lecture_data_structure_207_crop_9.jpg	V
crop_img/lecture_data_structure_207_crop_10.jpg	other data
crop_img/lecture_data_structure_207_crop_11.jpg	6
crop_img/lecture_data_structure_207_crop_12.jpg	52
crop_img/lecture_data_structure_207_crop_13.jpg	53
crop_img/lecture_data_structure_207_crop_14.jpg	8
crop_img/lecture_data_structure_207_crop_15.jpg	33
crop_img/lecture_data_structure_207_crop_16.jpg	44
crop_img/lecture_data_structure_207_crop_17.jpg	the only data
crop_img/lecture_data_structure_207_crop_18.jpg	Relabel in a leaf → use 3 and 4
crop_img/lecture_data_structure_207_crop_19.jpg	same parent
crop_img/lecture_data_structure_207_crop_20.jpg	个
crop_img/lecture_data_structure_207_crop_21.jpg	Case 3: data is in the only immediate sibling
crop_img/lecture_data_structure_207_crop_22.jpg	has a, 3 data
crop_img/lecture_data_structure_207_crop_23.jpg	→ Transfer: parent, sibling data
crop_img/lecture_data_structure_207_crop_24.jpg	empty
crop_img/lecture_data_structure_207_crop_25.jpg	↓
crop_img/lecture_data_structure_207_crop_26.jpg	closest sibling
crop_img/lecture_data_structure_207_crop_27.jpg	Remove (33)
crop_img/lecture_data_structure_207_crop_28.jpg	7
crop_img/lecture_data_structure_207_crop_29.jpg	25
crop_img/lecture_data_structure_207_crop_30.jpg	33
crop_img/lecture_data_structure_207_crop_31.jpg	/
crop_img/lecture_data_structure_207_crop_32.jpg	A
crop_img/lecture_data_structure_207_crop_33.jpg	7
crop_img/lecture_data_structure_207_crop_34.jpg	→
crop_img/lecture_data_structure_207_crop_35.jpg	74
crop_img/lecture_data_structure_207_crop_36.jpg	17
crop_img/lecture_data_structure_207_crop_37.jpg	74
crop_img/lecture_data_structure_207_crop_38.jpg	4
crop_img/lecture_data_structure_207_crop_39.jpg	/
crop_img/lecture_data_structure_207_crop_40.jpg	7
crop_img/lecture_data_structure_207_crop_41.jpg	/
crop_img/lecture_data_structure_207_crop_42.jpg	1
crop_img/lecture_data_structure_207_crop_43.jpg	86
crop_img/lecture_data_structure_207_crop_44.jpg	×
crop_img/lecture_data_structure_207_crop_45.jpg	6168
crop_img/lecture_data_structure_207_crop_46.jpg	61 68
crop_img/lecture_data_structure_207_crop_47.jpg	16 u
crop_img/lecture_data_structure_207_crop_48.jpg	25
crop_img/lecture_data_structure_207_crop_49.jpg	8 16
crop_img/lecture_data_structure_207_crop_50.jpg	25
crop_img/lecture_data_structure_207_crop_51.jpg	→
crop_img/lecture_data_structure_207_crop_52.jpg	74
crop_img/lecture_data_structure_207_crop_53.jpg	16
crop_img/lecture_data_structure_207_crop_54.jpg	/
crop_img/lecture_data_structure_207_crop_55.jpg	16
crop_img/lecture_data_structure_207_crop_56.jpg	8
crop_img/lecture_data_structure_207_crop_57.jpg	6168
crop_img/lecture_data_structure_208_crop_0.jpg	Case 4, leaf has 1 data, siblings also have 1 data
crop_img/lecture_data_structure_208_crop_1.jpg	all have 1 data
crop_img/lecture_data_structure_208_crop_2.jpg	. We will treat underflow exactly like overflow, but reverse
crop_img/lecture_data_structure_208_crop_3.jpg	2
crop_img/lecture_data_structure_208_crop_4.jpg	8
crop_img/lecture_data_structure_208_crop_5.jpg	68
crop_img/lecture_data_structure_208_crop_6.jpg	68
crop_img/lecture_data_structure_208_crop_7.jpg	remove(t)
crop_img/lecture_data_structure_208_crop_8.jpg	→
crop_img/lecture_data_structure_208_crop_9.jpg	く
crop_img/lecture_data_structure_208_crop_10.jpg	8 α4
crop_img/lecture_data_structure_208_crop_11.jpg	100 20
crop_img/lecture_data_structure_208_crop_12.jpg	7
crop_img/lecture_data_structure_208_crop_13.jpg	24
crop_img/lecture_data_structure_208_crop_14.jpg	100 200
crop_img/lecture_data_structure_208_crop_15.jpg	-
crop_img/lecture_data_structure_208_crop_16.jpg	V
crop_img/lecture_data_structure_208_crop_17.jpg	V
crop_img/lecture_data_structure_208_crop_18.jpg	merge
crop_img/lecture_data_structure_208_crop_19.jpg	function
crop_img/lecture_data_structure_208_crop_20.jpg	overflow: pushing to parent can make it too full
crop_img/lecture_data_structure_208_crop_21.jpg	underflow: pull out parent could make parent empty
crop_img/lecture_data_structure_208_crop_22.jpg	if parent is empty
crop_img/lecture_data_structure_208_crop_23.jpg	if sibling of parent has space transfer →done
crop_img/lecture_data_structure_208_crop_24.jpg	if sibling or parent all have data fusion again
crop_img/lecture_data_structure_208_crop_25.jpg	↓
crop_img/lecture_data_structure_208_crop_26.jpg	can make more
crop_img/lecture_data_structure_208_crop_27.jpg	work:
crop_img/lecture_data_structure_208_crop_28.jpg	empty root: remove it
crop_img/memory_input_output_4_crop_0.jpg	) Memory-mapped Io: Io devices and memory share the same addr
crop_img/memory_input_output_4_crop_1.jpg	Space
crop_img/memory_input_output_4_crop_2.jpg	Data registers: Used for actual transfer of data
crop_img/memory_input_output_4_crop_3.jpg	Status register: Information the device is telling us
crop_img/memory_input_output_4_crop_4.jpg	) Control register: Allows us to set changeable device characteristics
crop_img/memory_input_output_4_crop_5.jpg	( finish input a char?)
crop_img/memory_input_output_4_crop_6.jpg	Io Completion handling: Interrupt-driven & polling
crop_img/memory_input_output_4_crop_7.jpg	• Interrupt-driven: A device signals the cpu when it needs attention
crop_img/memory_input_output_4_crop_8.jpg	polling: cpu actively checks the status of a device
crop_img/memory_input_output_4_crop_9.jpg	Asynchronous Io: allows programs to continue executing other tasks
crop_img/memory_input_output_4_crop_10.jpg	while waiting for Io
crop_img/memory_input_output_4_crop_11.jpg	Note: we will focus on memory-mapped, asynchronous Io with
crop_img/memory_input_output_4_crop_12.jpg	polling
crop_img/memory_input_output_4_crop_13.jpg	)KBSR( Keyboard status register) (xFE00)
crop_img/memory_input_output_4_crop_14.jpg	. Only use bit 15, which is set when a character is available
crop_img/memory_input_output_4_crop_15.jpg	) KBDR(keyboard data register) (xFE02)
crop_img/memory_input_output_4_crop_16.jpg	.use bits 0-7, where the location is ready and reading
crop_img/memory_input_output_4_crop_17.jpg	clears KBSR
crop_img/memory_input_output_4_crop_18.jpg	KBSR and KBDR are used for keyboard input
crop_img/memory_input_output_5_crop_0.jpg	) DSR( Destination source register) (xFE04)
crop_img/memory_input_output_5_crop_1.jpg	Only use bit 15 which is set when monitor finish printing a char
crop_img/memory_input_output_5_crop_2.jpg	) DDR(Destination data register) (xFE06)
crop_img/memory_input_output_5_crop_3.jpg	. Use bits 0-7, transferring the data to this addr to output on
crop_img/memory_input_output_5_crop_4.jpg	the monitor
crop_img/memory_input_output_5_crop_5.jpg	. Clear DSR
crop_img/memory_input_output_5_crop_6.jpg	DSR and DDR are used for output
crop_img/memory_input_output_5_crop_7.jpg	type of os: sharing resources and protecting us from themselves
crop_img/memory_input_output_5_crop_8.jpg	and others
crop_img/memory_input_output_5_crop_9.jpg	Interrupt: An anticipated subroutine call triggered by an external event
crop_img/memory_input_output_5_crop_10.jpg	(E: Io device reports a completion/error)
crop_img/memory_input_output_5_crop_11.jpg	Note: KBSR and DSR both use bit 14 as Interruption Enable Bit
crop_img/memory_input_output_5_crop_12.jpg	) TRAP: An instruction that calls os subroutine (Ex: reading
crop_img/memory_input_output_5_crop_13.jpg	from a file)
crop_img/memory_input_output_5_crop_14.jpg	Exception: Unanticipated thing has happened
crop_img/memory_input_output_5_crop_15.jpg	Ex：
crop_img/memory_input_output_5_crop_16.jpg	hardware error / program error
crop_img/memory_input_output_5_crop_17.jpg	Processor Status register: a register that stores information about
crop_img/memory_input_output_5_crop_18.jpg	the current state of the processor
crop_img/memory_input_output_5_crop_19.jpg	15
crop_img/memory_input_output_5_crop_20.jpg	14-11
crop_img/memory_input_output_5_crop_21.jpg	10-8
crop_img/memory_input_output_5_crop_22.jpg	7-3
crop_img/memory_input_output_5_crop_23.jpg	2-0
crop_img/memory_input_output_5_crop_24.jpg	privilege
crop_img/memory_input_output_5_crop_25.jpg	priority
crop_img/memory_input_output_5_crop_26.jpg	don't
crop_img/memory_input_output_5_crop_27.jpg	don't
crop_img/memory_input_output_5_crop_28.jpg	condition
crop_img/memory_input_output_5_crop_29.jpg	IRQL
crop_img/memory_input_output_5_crop_30.jpg	CPU
crop_img/memory_input_output_5_crop_31.jpg	code
crop_img/memory_input_output_5_crop_32.jpg	mode
crop_img/memory_input_output_5_crop_33.jpg	use
crop_img/micro_econ_note_60_crop_0.jpg	Introduction to Economics
crop_img/micro_econ_note_60_crop_1.jpg	) Scarcity: human desires for goods & services are unlimited but
crop_img/micro_econ_note_60_crop_2.jpg	the resources & time are limited
crop_img/micro_econ_note_60_crop_3.jpg	) Economics: A social science that studies the choices people & organizations
crop_img/micro_econ_note_60_crop_4.jpg	make to cope with Scarcity and the incentives of these choices
crop_img/micro_econ_note_60_crop_5.jpg	Micro econ: The study of the choices that individuals and businesses
crop_img/micro_econ_note_60_crop_6.jpg	.
crop_img/micro_econ_note_60_crop_7.jpg	make, how they interact in the market, and government influence
crop_img/micro_econ_note_60_crop_8.jpg	Chap I: Working
crop_img/micro_econ_note_60_crop_9.jpg	(F01)
crop_img/micro_econ_note_60_crop_10.jpg	Factors & prod:
crop_img/micro_econ_note_60_crop_11.jpg	Resources used to produce goods & services
crop_img/micro_econ_note_60_crop_12.jpg	· Land: natural resources
crop_img/micro_econ_note_60_crop_13.jpg	→ rent
crop_img/micro_econ_note_60_crop_14.jpg	Labor: physical and mental effort of people → wages
crop_img/micro_econ_note_60_crop_15.jpg	.Human capital: knowledge & skill of people used to produce resource
crop_img/micro_econ_note_60_crop_16.jpg	Capital: tools, instruments, machines, buildings used to
crop_img/micro_econ_note_60_crop_17.jpg	produce
crop_img/micro_econ_note_60_crop_18.jpg	→
crop_img/micro_econ_note_60_crop_19.jpg	interest (lending them)
crop_img/micro_econ_note_60_crop_20.jpg	. Not financial capital (money, stocks, bonds)
crop_img/micro_econ_note_60_crop_21.jpg	Entrepreneurship: The process of discovering new ways to combine
crop_img/micro_econ_note_60_crop_22.jpg	resources
crop_img/micro_econ_note_60_crop_23.jpg	profit
crop_img/micro_econ_note_60_crop_24.jpg	→
crop_img/micro_econ_note_60_crop_25.jpg	Efficiency: The resource use is efficient if it is not possible to
crop_img/micro_econ_note_60_crop_26.jpg	make someone richer without making another poorer
crop_img/micro_econ_note_61_crop_0.jpg	Ex: Divide 5 apples to 3 people:
crop_img/micro_econ_note_61_crop_1.jpg	.0 5
crop_img/micro_econ_note_61_crop_2.jpg	4
crop_img/micro_econ_note_61_crop_3.jpg	Efficient
crop_img/micro_econ_note_61_crop_4.jpg	)
crop_img/micro_econ_note_61_crop_5.jpg	:
crop_img/micro_econ_note_61_crop_6.jpg	3, 2
crop_img/micro_econ_note_61_crop_7.jpg	. 2, 2 and throw 1 away
crop_img/micro_econ_note_61_crop_8.jpg	→ one person can have 3 apples (richer) and the other stay
crop_img/micro_econ_note_61_crop_9.jpg	the xame (not poorer) → Inefficient
crop_img/micro_econ_note_61_crop_10.jpg	Tradeoff: an exchange, giving up one thing to get something else
crop_img/micro_econ_note_61_crop_11.jpg	A choice is a tradeoff
crop_img/micro_econ_note_61_crop_12.jpg	greatest benefit
crop_img/micro_econ_note_61_crop_13.jpg	Rationality: compare costs & benefits → achieve
crop_img/micro_econ_note_61_crop_14.jpg	costs
crop_img/micro_econ_note_61_crop_15.jpg	Benefit: The gain/pleasure, determined by preference
crop_img/micro_econ_note_61_crop_16.jpg	Cost: The thing that you have to give up
crop_img/micro_econ_note_61_crop_17.jpg	(0c)
crop_img/micro_econ_note_61_crop_18.jpg	Opportunity cost: The highest-valued alternative that is given up
crop_img/micro_econ_note_61_crop_19.jpg	to get a thing is the opportunity cost of that thing
crop_img/micro_econ_note_61_crop_20.jpg	Positive statement:
crop_img/micro_econ_note_61_crop_21.jpg	fact, can be tested scientifically
crop_img/micro_econ_note_61_crop_22.jpg	Ex: Salary increases
crop_img/micro_econ_note_61_crop_23.jpg	30% compared to last year
crop_img/micro_econ_note_61_crop_24.jpg	Normative statement: opinion, cannot be tested scientifically
crop_img/micro_econ_note_61_crop_25.jpg	Ex. Unemployment should be lower
crop_img/micro_econ_note_62_crop_0.jpg	Economic models: A description of some aspects of the economic which
crop_img/micro_econ_note_62_crop_1.jpg	is needed for a purpose
crop_img/micro_econ_note_62_crop_2.jpg	→ Help economists conduct research and advise on goods and industry
crop_img/micro_econ_note_62_crop_3.jpg	policy
crop_img/micro_econ_note_62_crop_4.jpg	Market capitalism: an economic system in which
crop_img/micro_econ_note_62_crop_5.jpg	Individuals own resources and are free to buy/sell them (land, capital,
crop_img/micro_econ_note_62_crop_6.jpg	goods & services)
crop_img/micro_econ_note_62_crop_7.jpg	(g & s)
crop_img/micro_econ_note_62_crop_8.jpg	Markets determine what, how, and for whom goods & services are
crop_img/micro_econ_note_62_crop_9.jpg	produced
crop_img/micro_econ_note_62_crop_10.jpg	No supreme planner guiding the use of resources
crop_img/micro_econ_note_62_crop_11.jpg	Centrally planned socialism: an economic system in which:
crop_img/micro_econ_note_62_crop_12.jpg	Gov owns all resources, directs workers to jobs
crop_img/micro_econ_note_62_crop_13.jpg	Gov decides what, how, and for whom to produce
crop_img/micro_econ_note_62_crop_14.jpg	We are in a mixed economic system
crop_img/micro_econ_note_62_crop_15.jpg	Chapter 1: Introduction to PPF
crop_img/micro_econ_note_62_crop_16.jpg	Production possibility frontier (PPF): Production has tradeoffs
crop_img/micro_econ_note_62_crop_17.jpg	apples
crop_img/micro_econ_note_62_crop_18.jpg	unattainable
crop_img/micro_econ_note_62_crop_19.jpg	attainable
crop_img/micro_econ_note_62_crop_20.jpg	but inefficient
crop_img/micro_econ_note_62_crop_21.jpg	bikes
crop_img/micro_econ_note_63_crop_0.jpg	Marginal Benefit: benefit from consuming
crop_img/micro_econ_note_63_crop_1.jpg	1 more unit
crop_img/micro_econ_note_63_crop_2.jpg	Marginal Cost: cost
crop_img/micro_econ_note_63_crop_3.jpg	from producing
crop_img/micro_econ_note_63_crop_4.jpg	1 more unit
crop_img/micro_econ_note_63_crop_5.jpg	Economic growth: Expansion of the PPF
crop_img/micro_econ_note_63_crop_6.jpg	Technological change
crop_img/micro_econ_note_63_crop_7.jpg	Capital accumulation
crop_img/micro_econ_note_63_crop_8.jpg	PPF shifts out:
crop_img/micro_econ_note_63_crop_9.jpg	Technological advance
crop_img/micro_econ_note_63_crop_10.jpg	More education/training
crop_img/micro_econ_note_63_crop_11.jpg	Not natural disaster
crop_img/micro_econ_note_63_crop_12.jpg	(compare to others)
crop_img/micro_econ_note_63_crop_13.jpg	(fewer inputs, same output)
crop_img/micro_econ_note_63_crop_14.jpg	Absolute advantage & Comparative advantage:
crop_img/micro_econ_note_63_crop_15.jpg	1 hour
crop_img/micro_econ_note_63_crop_16.jpg	R has absolute advantage
crop_img/micro_econ_note_63_crop_17.jpg	chicken
crop_img/micro_econ_note_63_crop_18.jpg	waffle
crop_img/micro_econ_note_63_crop_19.jpg	1h
crop_img/micro_econ_note_63_crop_20.jpg	P
crop_img/micro_econ_note_63_crop_21.jpg	in producing waffle
crop_img/micro_econ_note_63_crop_22.jpg	Rachel
crop_img/micro_econ_note_63_crop_23.jpg	30
crop_img/micro_econ_note_63_crop_24.jpg	30
crop_img/micro_econ_note_63_crop_25.jpg	Nick
crop_img/micro_econ_note_63_crop_26.jpg	30
crop_img/micro_econ_note_63_crop_27.jpg	6
crop_img/micro_econ_note_63_crop_28.jpg	1h
crop_img/micro_econ_note_63_crop_29.jpg	60
crop_img/micro_econ_note_63_crop_30.jpg	0
crop_img/micro_econ_note_63_crop_31.jpg	→
crop_img/micro_econ_note_63_crop_32.jpg	better
crop_img/micro_econ_note_63_crop_33.jpg	60
crop_img/micro_econ_note_63_crop_34.jpg	0
crop_img/micro_econ_note_63_crop_35.jpg	Cost
crop_img/micro_econ_note_63_crop_36.jpg	Nick has comp advantage
crop_img/micro_econ_note_63_crop_37.jpg	chicken
crop_img/micro_econ_note_63_crop_38.jpg	waffle
crop_img/micro_econ_note_63_crop_39.jpg	7 in prod chicken over
crop_img/micro_econ_note_63_crop_40.jpg	Rachel
crop_img/micro_econ_note_63_crop_41.jpg	Rachel
crop_img/micro_econ_note_63_crop_42.jpg	1W
crop_img/micro_econ_note_63_crop_43.jpg	1C
crop_img/micro_econ_note_63_crop_44.jpg	Nick
crop_img/micro_econ_note_63_crop_45.jpg	5
crop_img/micro_econ_note_63_crop_46.jpg	→
crop_img/micro_econ_note_63_crop_47.jpg	5C
crop_img/micro_econ_note_63_crop_48.jpg	Rachel has comp
crop_img/micro_econ_note_63_crop_49.jpg	Rachel's oc for chicken is 1 waffle
crop_img/micro_econ_note_63_crop_50.jpg	waffle
crop_img/micro_econ_note_63_crop_51.jpg	Nick
crop_img/micro_econ_note_63_crop_52.jpg	Nick's oc for waffle
crop_img/micro_econ_note_63_crop_53.jpg	B
crop_img/micro_econ_note_63_crop_54.jpg	A
crop_img/micro_econ_note_63_crop_55.jpg	3B
crop_img/micro_econ_note_63_crop_56.jpg	-13
crop_img/micro_econ_note_63_crop_57.jpg	P
crop_img/micro_econ_note_63_crop_58.jpg	.
crop_img/micro_econ_note_63_crop_59.jpg	P
crop_img/micro_econ_note_63_crop_60.jpg	15
crop_img/micro_econ_note_63_crop_61.jpg	5
crop_img/micro_econ_note_63_crop_62.jpg	→
crop_img/micro_econ_note_63_crop_63.jpg	M
crop_img/micro_econ_note_63_crop_64.jpg	10
crop_img/micro_econ_note_63_crop_65.jpg	20
crop_img/micro_econ_note_63_crop_66.jpg	-12
crop_img/micro_econ_note_63_crop_67.jpg	2B
crop_img/micro_econ_note_63_crop_68.jpg	P
crop_img/micro_econ_note_64_crop_0.jpg	DEMAND AND SUPPLY
crop_img/micro_econ_note_64_crop_1.jpg	(0&S)
crop_img/micro_econ_note_64_crop_2.jpg	(卫)
crop_img/micro_econ_note_64_crop_3.jpg	(Q)
crop_img/micro_econ_note_64_crop_4.jpg	demand relationship bet ween price of a good and the quantity demanded
crop_img/micro_econ_note_64_crop_5.jpg	Demand curve :
crop_img/micro_econ_note_64_crop_6.jpg	($)
crop_img/micro_econ_note_64_crop_7.jpg	个
crop_img/micro_econ_note_64_crop_8.jpg	Demand Curve
crop_img/micro_econ_note_64_crop_9.jpg	(also marginal benefit
crop_img/micro_econ_note_64_crop_10.jpg	curve)
crop_img/micro_econ_note_64_crop_11.jpg	7
crop_img/micro_econ_note_64_crop_12.jpg	Q
crop_img/micro_econ_note_64_crop_13.jpg	) Market: where sellers & buyers interact to exchange goods & services
crop_img/micro_econ_note_64_crop_14.jpg	) Money price : price in currency
crop_img/micro_econ_note_64_crop_15.jpg	Relative price in terms of good
crop_img/micro_econ_note_64_crop_16.jpg	Used throughout this class
crop_img/micro_econ_note_64_crop_17.jpg	) Law of D
crop_img/micro_econ_note_64_crop_18.jpg	P个→Q√
crop_img/micro_econ_note_64_crop_19.jpg	.) Movement along the curve
crop_img/micro_econ_note_64_crop_20.jpg	Q changes because P changes
crop_img/micro_econ_note_64_crop_21.jpg	.) change in Demand : D curve shifts
crop_img/micro_econ_note_65_crop_0.jpg	.) Demand Shifters:
crop_img/micro_econ_note_65_crop_1.jpg	. Preferences
crop_img/micro_econ_note_65_crop_2.jpg	Income (I)
crop_img/micro_econ_note_65_crop_3.jpg	. Normal good : I↑ → shift right
crop_img/micro_econ_note_65_crop_4.jpg	. Inferior good : I↑ → shift left
crop_img/micro_econ_note_65_crop_5.jpg	Expectation of Future (EOF)
crop_img/micro_econ_note_65_crop_6.jpg	6
crop_img/micro_econ_note_65_crop_7.jpg	Future price high → shift right
crop_img/micro_econ_note_65_crop_8.jpg	low→
crop_img/micro_econ_note_65_crop_9.jpg	left
crop_img/micro_econ_note_65_crop_10.jpg	. Substitute & Complement
crop_img/micro_econ_note_65_crop_11.jpg	yehue.m
crop_img/micro_econ_note_65_crop_12.jpg	P of sub ↑ → shift right
crop_img/micro_econ_note_65_crop_13.jpg	P of Sub ↓→ shift left
crop_img/micro_econ_note_65_crop_14.jpg	P of Com ↑ → shift left
crop_img/micro_econ_note_65_crop_15.jpg	P of
crop_img/micro_econ_note_65_crop_16.jpg	com ↓ → shift right
crop_img/micro_econ_note_65_crop_17.jpg	.# Demanders
crop_img/micro_econ_note_65_crop_18.jpg	# Demander ↑ → shift right
crop_img/micro_econ_note_65_crop_19.jpg	. Network and congestion effects
crop_img/micro_econ_note_66_crop_0.jpg	Network; More people use → shift right
crop_img/micro_econ_note_66_crop_1.jpg	Congestion: More.
crop_img/micro_econ_note_66_crop_2.jpg	→ shift left
crop_img/micro_econ_note_66_crop_3.jpg	(S)
crop_img/micro_econ_note_66_crop_4.jpg	Supply relation between a good and the price
crop_img/micro_econ_note_66_crop_5.jpg	) Law of S: P↑→Q↑
crop_img/micro_econ_note_66_crop_6.jpg	) change & S .S curve shifts
crop_img/micro_econ_note_66_crop_7.jpg	Supply curve also marginal cost
crop_img/micro_econ_note_66_crop_8.jpg	f($)
crop_img/micro_econ_note_66_crop_9.jpg	curve)
crop_img/micro_econ_note_66_crop_10.jpg	个
crop_img/micro_econ_note_66_crop_11.jpg	M
crop_img/micro_econ_note_66_crop_12.jpg	shift
crop_img/micro_econ_note_66_crop_13.jpg	along
crop_img/micro_econ_note_66_crop_14.jpg	3
crop_img/micro_econ_note_66_crop_15.jpg	C
crop_img/micro_econ_note_66_crop_16.jpg	high
crop_img/micro_econ_note_66_crop_17.jpg	Q
crop_img/micro_econ_note_66_crop_18.jpg	) change in Q Supplied: M along the C
crop_img/micro_econ_note_66_crop_19.jpg	) Supply Shifters:
crop_img/micro_econ_note_66_crop_20.jpg	① P of Fop/Input: P↑→S↓
crop_img/micro_econ_note_66_crop_21.jpg	② Expectations: future P ↑→S↓(reserve for future)
crop_img/micro_econ_note_66_crop_22.jpg	③
crop_img/micro_econ_note_66_crop_23.jpg	L
crop_img/micro_econ_note_66_crop_24.jpg	of Related outputs:
crop_img/micro_econ_note_66_crop_25.jpg	Substitute in prod: thing produced with the same resources
crop_img/micro_econ_note_66_crop_26.jpg	Ex: wool jacket
crop_img/micro_econ_note_66_crop_27.jpg	V
crop_img/micro_econ_note_66_crop_28.jpg	Water
crop_img/micro_econ_note_66_crop_29.jpg	.I of substitute ↑→ S ↓
crop_img/micro_econ_note_66_crop_30.jpg	.I of substitute ↓→ S ↑
crop_img/micro_econ_note_68_crop_0.jpg	Chapter 4: Elasticity
crop_img/micro_econ_note_68_crop_1.jpg	Elasticity: A measure of the responsiveness to a change
crop_img/micro_econ_note_68_crop_2.jpg	. Highly responsive → elastic
crop_img/micro_econ_note_68_crop_3.jpg	. Weakly
crop_img/micro_econ_note_68_crop_4.jpg	inelastic
crop_img/micro_econ_note_68_crop_5.jpg	J
crop_img/micro_econ_note_68_crop_6.jpg	(^°)
crop_img/micro_econ_note_68_crop_7.jpg	△Q demanded
crop_img/micro_econ_note_68_crop_8.jpg	.) price Elasticity of D:
crop_img/micro_econ_note_68_crop_9.jpg	Q average
crop_img/micro_econ_note_68_crop_10.jpg	△Q demanded (P)
crop_img/micro_econ_note_68_crop_11.jpg	△P
crop_img/micro_econ_note_68_crop_12.jpg	△P (%)
crop_img/micro_econ_note_68_crop_13.jpg	P average
crop_img/micro_econ_note_68_crop_14.jpg	△QA→B/OA+OB
crop_img/micro_econ_note_68_crop_15.jpg	n
crop_img/micro_econ_note_68_crop_16.jpg	Ex:
crop_img/micro_econ_note_68_crop_17.jpg	e
crop_img/micro_econ_note_68_crop_18.jpg	a
crop_img/micro_econ_note_68_crop_19.jpg	A→B
crop_img/micro_econ_note_68_crop_20.jpg	二
crop_img/micro_econ_note_68_crop_21.jpg	△L
crop_img/micro_econ_note_68_crop_22.jpg	A→B
crop_img/micro_econ_note_68_crop_23.jpg	A+LB
crop_img/micro_econ_note_68_crop_24.jpg	a
crop_img/micro_econ_note_68_crop_25.jpg	0
crop_img/micro_econ_note_68_crop_26.jpg	Consider lel:
crop_img/micro_econ_note_68_crop_27.jpg	.|ε|=1→unit elastic demand→%Δl=%Δa
crop_img/micro_econ_note_68_crop_28.jpg	.|ε|<1→inelastic demand(Ex:food, ga)
crop_img/micro_econ_note_68_crop_29.jpg	|ε|>1→elastic demand (Ex: luxuries)
crop_img/micro_econ_note_68_crop_30.jpg	different sellers)
crop_img/micro_econ_note_68_crop_31.jpg	00
crop_img/micro_econ_note_69_crop_0.jpg	) Elasticity ↓ ar Q↑ on the demand curve
crop_img/micro_econ_note_69_crop_1.jpg	f($)
crop_img/micro_econ_note_69_crop_2.jpg	个
crop_img/micro_econ_note_69_crop_3.jpg	Perfectly inelastic
crop_img/micro_econ_note_69_crop_4.jpg	perfectly
crop_img/micro_econ_note_69_crop_5.jpg	elastic
crop_img/micro_econ_note_69_crop_6.jpg	r
crop_img/micro_econ_note_69_crop_7.jpg	E
crop_img/micro_econ_note_69_crop_8.jpg	√
crop_img/micro_econ_note_69_crop_9.jpg	V
crop_img/micro_econ_note_69_crop_10.jpg	7
crop_img/micro_econ_note_69_crop_11.jpg	Q
crop_img/micro_econ_note_69_crop_12.jpg	① Closeness of substitutes:
crop_img/micro_econ_note_69_crop_13.jpg	more substitutes more elastic
crop_img/micro_econ_note_69_crop_14.jpg	α
crop_img/micro_econ_note_69_crop_15.jpg	proportion of income spent on goods: more expensive, more elastic
crop_img/micro_econ_note_69_crop_16.jpg	3
crop_img/micro_econ_note_69_crop_17.jpg	Time elapsed since the price change: more time, more elastic
crop_img/micro_econ_note_69_crop_18.jpg	.) Effects of Elasticity:
crop_img/micro_econ_note_69_crop_19.jpg	办
crop_img/micro_econ_note_69_crop_20.jpg	. P ut / hi ke
crop_img/micro_econ_note_69_crop_21.jpg	. Elastic: ↑Total revenue /
crop_img/micro_econ_note_69_crop_22.jpg	. Inelastic: _
crop_img/micro_econ_note_69_crop_23.jpg	个
crop_img/micro_econ_note_69_crop_24.jpg	unit
crop_img/micro_econ_note_69_crop_25.jpg	ω
crop_img/micro_econ_note_69_crop_26.jpg	. Unit Elastic: Unchange
crop_img/micro_econ_note_69_crop_27.jpg	) Causes Elasticity of Demand:
crop_img/micro_econ_note_69_crop_28.jpg	% Δa demanded
crop_img/micro_econ_note_69_crop_29.jpg	εC
crop_img/micro_econ_note_69_crop_30.jpg	% ΔP other good
crop_img/micro_econ_note_70_crop_0.jpg	) Price Elasticity of Supply:
crop_img/micro_econ_note_70_crop_1.jpg	E = %△Q supplied
crop_img/micro_econ_note_70_crop_2.jpg	中
crop_img/micro_econ_note_70_crop_3.jpg	→
crop_img/micro_econ_note_70_crop_4.jpg	Always Positive
crop_img/micro_econ_note_70_crop_5.jpg	%△
crop_img/micro_econ_note_70_crop_6.jpg	V
crop_img/micro_econ_note_70_crop_7.jpg	=1: unit elastic s
crop_img/micro_econ_note_70_crop_8.jpg	<1: inelastic s
crop_img/micro_econ_note_70_crop_9.jpg	>1: elastic s
crop_img/micro_econ_note_70_crop_10.jpg	for little bit
crop_img/micro_econ_note_70_crop_11.jpg	个
crop_img/micro_econ_note_70_crop_12.jpg	perfectly elastic supply
crop_img/micro_econ_note_70_crop_13.jpg	9
crop_img/micro_econ_note_70_crop_14.jpg	个
crop_img/micro_econ_note_70_crop_15.jpg	8
crop_img/micro_econ_note_70_crop_16.jpg	Q
crop_img/micro_econ_note_70_crop_17.jpg	&
crop_img/micro_econ_note_70_crop_18.jpg	SIV little bit
crop_img/micro_econ_note_70_crop_19.jpg	Q=0 (no sale)
crop_img/micro_econ_note_70_crop_20.jpg	) Factors that influence Elasticity of Supply
crop_img/micro_econ_note_70_crop_21.jpg	①Resource substitution possibilities: goods produced using resources
crop_img/micro_econ_note_70_crop_22.jpg	that few substitutions are very inelastic
crop_img/micro_econ_note_70_crop_23.jpg	short time frame
crop_img/micro_econ_note_70_crop_24.jpg	2 Time frame:
crop_img/micro_econ_note_70_crop_25.jpg	. short run: inelastic
crop_img/micro_econ_note_70_crop_26.jpg	' Long run: elastic
crop_img/micro_econ_note_71_crop_0.jpg	Availability of resources: If supply is dependent on rare resource
crop_img/micro_econ_note_71_crop_1.jpg	3
crop_img/micro_econ_note_71_crop_2.jpg	can't increase production when e↑
crop_img/micro_econ_note_71_crop_3.jpg	4 Barriers to entry: Hard to enter the market → inelastic
crop_img/micro_econ_note_71_crop_4.jpg	% △Q demanded
crop_img/micro_econ_note_71_crop_5.jpg	) Income elasticity of Demand:
crop_img/micro_econ_note_71_crop_6.jpg	% △
crop_img/micro_econ_note_71_crop_7.jpg	of a good
crop_img/micro_econ_note_71_crop_8.jpg	Chapter 5:
crop_img/micro_econ_note_71_crop_9.jpg	Efficiency & Equity
crop_img/micro_econ_note_71_crop_10.jpg	Optimal consumption point: A point where marginal benefit = marginal
crop_img/micro_econ_note_71_crop_11.jpg	cost
crop_img/micro_econ_note_71_crop_12.jpg	.
crop_img/micro_econ_note_71_crop_13.jpg	Allocation methods:
crop_img/micro_econ_note_71_crop_14.jpg	. Market price: S & D determine price
crop_img/micro_econ_note_71_crop_15.jpg	Command system: order
crop_img/micro_econ_note_71_crop_16.jpg	. Majority rule: vote (use of tax $)
crop_img/micro_econ_note_71_crop_17.jpg	Contest
crop_img/micro_econ_note_71_crop_18.jpg	First-come, first-served
crop_img/micro_econ_note_71_crop_19.jpg	Lottery
crop_img/micro_econ_note_71_crop_20.jpg	personal characteristics
crop_img/micro_econ_note_71_crop_21.jpg	A
crop_img/micro_econ_note_71_crop_22.jpg	.En: A soccer team might choose players with good spatial awareness
crop_img/micro_econ_note_71_crop_23.jpg	and speed
crop_img/micro_econ_note_72_crop_0.jpg	.Force: Enforce contracts (law suit, etc.)
crop_img/micro_econ_note_72_crop_1.jpg	A demand curve is a marginal benefit curve
crop_img/micro_econ_note_72_crop_2.jpg	Individual Demand: relationship between an individual quantity demanded
crop_img/micro_econ_note_72_crop_3.jpg	and price
crop_img/micro_econ_note_72_crop_4.jpg	.Individual Supply
crop_img/micro_econ_note_72_crop_5.jpg	ad of all buyer and pris
crop_img/micro_econ_note_72_crop_6.jpg	Market Demand :
crop_img/micro_econ_note_72_crop_7.jpg	• Sum of all individual demand curves
crop_img/micro_econ_note_72_crop_8.jpg	Market Supply
crop_img/micro_econ_note_72_crop_9.jpg	(MSB)
crop_img/micro_econ_note_72_crop_10.jpg	) Marginal social benefit:
crop_img/micro_econ_note_72_crop_11.jpg	market (society)'s marginal benefit
crop_img/micro_econ_note_72_crop_12.jpg	Market Demand Curve = MSB curve
crop_img/micro_econ_note_72_crop_13.jpg	(MSC)
crop_img/micro_econ_note_72_crop_14.jpg	Market Supply curve = Marginal social cost curve
crop_img/micro_econ_note_72_crop_15.jpg	Consumer Surplus & producer Surplus :
crop_img/micro_econ_note_72_crop_16.jpg	2↑
crop_img/micro_econ_note_72_crop_17.jpg	D(MB) Curve
crop_img/micro_econ_note_72_crop_18.jpg	C sur
crop_img/micro_econ_note_72_crop_19.jpg	7
crop_img/micro_econ_note_72_crop_20.jpg	7
crop_img/micro_econ_note_72_crop_21.jpg	Market price
crop_img/micro_econ_note_72_crop_22.jpg	fsw2
crop_img/micro_econ_note_72_crop_23.jpg	R
crop_img/micro_econ_note_72_crop_24.jpg	S(MC) curve
crop_img/micro_econ_note_72_crop_25.jpg	Q
crop_img/micro_econ_note_72_crop_26.jpg	At equilibrium ) C sur & I sur are maximum
crop_img/micro_econ_note_72_crop_27.jpg	→ Allocative efficiency
crop_img/micro_econ_note_73_crop_0.jpg	.) Market failure: when a market is not allocative efficient
crop_img/micro_econ_note_73_crop_1.jpg	Underproduction / overproduction will occur
crop_img/micro_econ_note_73_crop_2.jpg	P
crop_img/micro_econ_note_73_crop_3.jpg	S
crop_img/micro_econ_note_73_crop_4.jpg	Deadweight loss := decrease of total surplus
crop_img/micro_econ_note_73_crop_5.jpg	loss by inefficiency
crop_img/micro_econ_note_73_crop_6.jpg	C
crop_img/micro_econ_note_73_crop_7.jpg	→
crop_img/micro_econ_note_73_crop_8.jpg	6
crop_img/micro_econ_note_73_crop_9.jpg	A2
crop_img/micro_econ_note_73_crop_10.jpg	Q
crop_img/micro_econ_note_73_crop_11.jpg	Q
crop_img/micro_econ_note_73_crop_12.jpg	Q
crop_img/micro_econ_note_73_crop_13.jpg	eq
crop_img/micro_econ_note_73_crop_14.jpg	↓
crop_img/micro_econ_note_73_crop_15.jpg	↓
crop_img/micro_econ_note_73_crop_16.jpg	Under
crop_img/micro_econ_note_73_crop_17.jpg	over
crop_img/micro_econ_note_73_crop_18.jpg	P
crop_img/micro_econ_note_73_crop_19.jpg	p
crop_img/micro_econ_note_73_crop_20.jpg	Sources of Market Failure:
crop_img/micro_econ_note_73_crop_21.jpg	• price and quantity regulations:
crop_img/micro_econ_note_73_crop_22.jpg	Ex: price caps / oo98
crop_img/micro_econ_note_73_crop_23.jpg	limited # factories
crop_img/micro_econ_note_73_crop_24.jpg	• Taxes and Subsidies :
crop_img/micro_econ_note_73_crop_25.jpg	.Taxes: higher price for buyers, lower revenue for sellers
crop_img/micro_econ_note_73_crop_26.jpg	V
crop_img/micro_econ_note_73_crop_27.jpg	under production
crop_img/micro_econ_note_73_crop_28.jpg	Subsidies(payment by gov to poor): lower price for by
crop_img/micro_econ_note_73_crop_29.jpg	increase revenue for buyers
crop_img/micro_econ_note_73_crop_30.jpg	V
crop_img/micro_econ_note_73_crop_31.jpg	overproduction
crop_img/micro_econ_note_74_crop_0.jpg	Externality: Cost benefit that affect people that are not
crop_img/micro_econ_note_74_crop_1.jpg	buyer / seller
crop_img/micro_econ_note_74_crop_2.jpg	External cost causes overproduction (doesn't care for others)
crop_img/micro_econ_note_74_crop_3.jpg	. External benefit
crop_img/micro_econ_note_74_crop_4.jpg	underproduction ( care too much
crop_img/micro_econ_note_74_crop_5.jpg	. Public goods & common resources
crop_img/micro_econ_note_74_crop_6.jpg	Public good;
crop_img/micro_econ_note_74_crop_7.jpg	everyone benefit without having to pay
crop_img/micro_econ_note_74_crop_8.jpg	→under produced ) ex: public bus
crop_img/micro_econ_note_74_crop_9.jpg	Common resource : owned by no one and nonexcludable
crop_img/micro_econ_note_74_crop_10.jpg	→ over produced ) ex:over fishing
crop_img/micro_econ_note_74_crop_11.jpg	Monopoly: only one seller exists→ they will and a
crop_img/micro_econ_note_74_crop_12.jpg	Underproduction
crop_img/micro_econ_note_74_crop_13.jpg	High transaction cost: cost of connecting seller & buyer high
crop_img/micro_econ_note_74_crop_14.jpg	→ Underproduction
crop_img/micro_econ_note_74_crop_15.jpg	) Competitive market's fairness:
crop_img/micro_econ_note_74_crop_16.jpg	Utilitarianism : it is not fair if the result isn't fair
crop_img/micro_econ_note_74_crop_17.jpg	→ Want to achieve the greatest good for the greatest number
crop_img/micro_econ_note_74_crop_18.jpg	. Rawlsian:
crop_img/micro_econ_note_74_crop_19.jpg	a
crop_img/micro_econ_note_74_crop_20.jpg	it's not fair if the rules aren't fair
crop_img/micro_econ_note_75_crop_0.jpg	)Redistribution: Taking from the rich and give to the poor
crop_img/micro_econ_note_75_crop_1.jpg	. Have consequence.
crop_img/micro_econ_note_75_crop_2.jpg	change behavior: cause people to work and invest less (Tax)
crop_img/micro_econ_note_75_crop_3.jpg	② Transfer cost
crop_img/micro_econ_note_75_crop_4.jpg	→ Cause underproduction
crop_img/micro_econ_note_75_crop_5.jpg	9 Trade off between equity & efficiency
crop_img/micro_econ_note_75_crop_6.jpg	) symmetry principle : people in similar situation should be treated similarly
crop_img/micro_econ_note_75_crop_7.jpg	Not determined by outcome / result
crop_img/micro_econ_note_75_crop_8.jpg	. private property rule :
crop_img/micro_econ_note_75_crop_9.jpg	protect private property & can only transfer
crop_img/micro_econ_note_75_crop_10.jpg	through voluntary exchange
crop_img/micro_econ_note_75_crop_11.jpg	Chapter 6 : Gov Action In Market
crop_img/micro_econ_note_75_crop_12.jpg	price ceiling: a level where suppliers cannot charge higher
crop_img/micro_econ_note_75_crop_13.jpg	·If set below equi price → shortage → inefficiency
crop_img/micro_econ_note_75_crop_14.jpg	Housing shortage
crop_img/micro_econ_note_75_crop_15.jpg	Ex:Rent ceiling if set below equi 
crop_img/micro_econ_note_75_crop_16.jpg	Increased search activity
crop_img/micro_econ_note_75_crop_17.jpg	create illegal market
crop_img/micro_econ_note_75_crop_18.jpg	L
crop_img/micro_econ_note_75_crop_19.jpg	C-xu
crop_img/micro_econ_note_75_crop_20.jpg	OWL: dead weight loss
crop_img/micro_econ_note_75_crop_21.jpg	S
crop_img/micro_econ_note_75_crop_22.jpg	5
crop_img/micro_econ_note_75_crop_23.jpg	OWL
crop_img/micro_econ_note_75_crop_24.jpg	equi
crop_img/micro_econ_note_75_crop_25.jpg	ceiling I
crop_img/micro_econ_note_75_crop_26.jpg	A
crop_img/micro_econ_note_75_crop_27.jpg	D
crop_img/micro_econ_note_75_crop_28.jpg	→Q
crop_img/micro_econ_note_75_crop_29.jpg	6_{s}$
crop_img/micro_econ_note_76_crop_0.jpg	searching cost: maximum price willing to pay can equal ceiling
crop_img/micro_econ_note_76_crop_1.jpg	+ searching
crop_img/micro_econ_note_76_crop_2.jpg	P
crop_img/micro_econ_note_76_crop_3.jpg	max search cost because
crop_img/micro_econ_note_76_crop_4.jpg	L
crop_img/micro_econ_note_76_crop_5.jpg	C-s
crop_img/micro_econ_note_76_crop_6.jpg	supplier don't want to sell
crop_img/micro_econ_note_76_crop_7.jpg	S
crop_img/micro_econ_note_76_crop_8.jpg	DWL
crop_img/micro_econ_note_76_crop_9.jpg	(don't get any profit) and
crop_img/micro_econ_note_76_crop_10.jpg	equi
crop_img/micro_econ_note_76_crop_11.jpg	buyer spend too much money
crop_img/micro_econ_note_76_crop_12.jpg	mar
crop_img/micro_econ_note_76_crop_13.jpg	search
crop_img/micro_econ_note_76_crop_14.jpg	20188
crop_img/micro_econ_note_76_crop_15.jpg	ceiling
crop_img/micro_econ_note_76_crop_16.jpg	finding seller No they
crop_img/micro_econ_note_76_crop_17.jpg	cont
crop_img/micro_econ_note_76_crop_18.jpg	froms
crop_img/micro_econ_note_76_crop_19.jpg	D
crop_img/micro_econ_note_76_crop_20.jpg	don't get any profit to
crop_img/micro_econ_note_76_crop_21.jpg	search
crop_img/micro_econ_note_76_crop_22.jpg	→ Q
crop_img/micro_econ_note_76_crop_23.jpg	Qs}$
crop_img/micro_econ_note_76_crop_24.jpg	) who benefit from renting ceiling: who has an apartment or lucky to
crop_img/micro_econ_note_76_crop_25.jpg	find one
crop_img/micro_econ_note_76_crop_26.jpg	Who loser
crop_img/micro_econ_note_76_crop_27.jpg	: everyone else
crop_img/micro_econ_note_76_crop_28.jpg	price floor: a level where suppliers cannot charge lower
crop_img/micro_econ_note_76_crop_29.jpg	If set above equi L → &urg thus → inefficiency
crop_img/micro_econ_note_76_crop_30.jpg	.Ex: Minimum wage >equi→ too many applicants but too few jobs
crop_img/micro_econ_note_76_crop_31.jpg	unemployment
crop_img/micro_econ_note_76_crop_32.jpg	d
crop_img/micro_econ_note_76_crop_33.jpg	Q→:people who are unemployed
crop_img/micro_econ_note_76_crop_34.jpg	A
crop_img/micro_econ_note_76_crop_35.jpg	e
crop_img/micro_econ_note_76_crop_36.jpg	S
crop_img/micro_econ_note_76_crop_37.jpg	ad →ae:who should have
crop_img/micro_econ_note_76_crop_38.jpg	PF
crop_img/micro_econ_note_76_crop_39.jpg	min wage
crop_img/micro_econ_note_76_crop_40.jpg	a job but don't
crop_img/micro_econ_note_76_crop_41.jpg	PE
crop_img/micro_econ_note_76_crop_42.jpg	E
crop_img/micro_econ_note_76_crop_43.jpg	. Qe→a :who want to work
crop_img/micro_econ_note_76_crop_44.jpg	at LF and can't find job
crop_img/micro_econ_note_76_crop_45.jpg	0
crop_img/micro_econ_note_76_crop_46.jpg	7
crop_img/micro_econ_note_76_crop_47.jpg	ae
crop_img/micro_econ_note_76_crop_48.jpg	Q
crop_img/micro_econ_note_76_crop_49.jpg	6
crop_img/micro_econ_note_76_crop_50.jpg	Q
crop_img/micro_econ_note_76_crop_51.jpg	Q
crop_img/micro_econ_note_76_crop_52.jpg	winners:people who employed at low wage and now earn min wage
crop_img/micro_econ_note_76_crop_53.jpg	people who get a job at this min wage
crop_img/micro_econ_note_77_crop_0.jpg	people employed at low wage and now love their job cuz min wage
crop_img/micro_econ_note_77_crop_1.jpg	Loser
crop_img/micro_econ_note_77_crop_2.jpg	E
crop_img/micro_econ_note_77_crop_3.jpg	-people who should have the job if p =p
crop_img/micro_econ_note_77_crop_4.jpg	) Production quota : upper limit to produced, only has effect if set
crop_img/micro_econ_note_77_crop_5.jpg	below aE
crop_img/micro_econ_note_77_crop_6.jpg	Tax incident : the division of the burden of a tax between buyers & sellers
crop_img/micro_econ_note_77_crop_7.jpg	.Note :. The law doesn't decide tax incident, the market does
crop_img/micro_econ_note_77_crop_8.jpg	Put the tax on buyer or sellers has the same effect
crop_img/micro_econ_note_77_crop_9.jpg	S+tax
crop_img/micro_econ_note_77_crop_10.jpg	S
crop_img/micro_econ_note_77_crop_11.jpg	buyer
crop_img/micro_econ_note_77_crop_12.jpg	tax buyer
crop_img/micro_econ_note_77_crop_13.jpg	pay
crop_img/micro_econ_note_77_crop_14.jpg	pay
crop_img/micro_econ_note_77_crop_15.jpg	--
crop_img/micro_econ_note_77_crop_16.jpg	seller
crop_img/micro_econ_note_77_crop_17.jpg	tax seller
crop_img/micro_econ_note_77_crop_18.jpg	receive
crop_img/micro_econ_note_77_crop_19.jpg	pay
crop_img/micro_econ_note_77_crop_20.jpg	0
crop_img/micro_econ_note_77_crop_21.jpg	Buyers paid less tax if the demand is more elastic
crop_img/micro_econ_note_77_crop_22.jpg	Sellers paid less
crop_img/micro_econ_note_77_crop_23.jpg	supply is more elastic
crop_img/micro_econ_note_77_crop_24.jpg	I buyers se
crop_img/micro_econ_note_77_crop_25.jpg	s (elastic)
crop_img/micro_econ_note_77_crop_26.jpg	S(inelastic)
crop_img/micro_econ_note_77_crop_27.jpg	→
crop_img/micro_econ_note_77_crop_28.jpg	Q
crop_img/micro_econ_note_78_crop_0.jpg	Buyers pay all taxes if S is perfectly elastic
crop_img/micro_econ_note_78_crop_1.jpg	Sellers
crop_img/micro_econ_note_78_crop_2.jpg	S is perfectly
crop_img/micro_econ_note_78_crop_3.jpg	inelastic
crop_img/micro_econ_note_78_crop_4.jpg	P
crop_img/micro_econ_note_78_crop_5.jpg	s+ tax
crop_img/micro_econ_note_78_crop_6.jpg	个
crop_img/micro_econ_note_78_crop_7.jpg	Buyer pay all
crop_img/micro_econ_note_78_crop_8.jpg	个
crop_img/micro_econ_note_78_crop_9.jpg	S
crop_img/micro_econ_note_78_crop_10.jpg	tax
crop_img/micro_econ_note_78_crop_11.jpg	price
crop_img/micro_econ_note_78_crop_12.jpg	70
crop_img/micro_econ_note_78_crop_13.jpg	Transfor effct: Some surplus is transferred from consumer or producer → gov
crop_img/micro_econ_note_78_crop_14.jpg	sttax
crop_img/micro_econ_note_78_crop_15.jpg	S
crop_img/micro_econ_note_78_crop_16.jpg	CS
crop_img/micro_econ_note_78_crop_17.jpg	Iwr 8
crop_img/micro_econ_note_78_crop_18.jpg	10WL
crop_img/micro_econ_note_78_crop_19.jpg	actual L
crop_img/micro_econ_note_78_crop_20.jpg	gov
crop_img/micro_econ_note_78_crop_21.jpg	p
crop_img/micro_econ_note_78_crop_22.jpg	Ves
crop_img/micro_econ_note_78_crop_23.jpg	Note: For perfectly inelastic demand or perfectly elastic supply
crop_img/micro_econ_note_78_crop_24.jpg	DWL doesn't occur because Q stays the same
crop_img/micro_econ_note_78_crop_25.jpg	) Subsidier: payment made by gov to a producer
crop_img/micro_econ_note_78_crop_26.jpg	→ Encourage producers to produce more than equi
crop_img/micro_econ_note_78_crop_27.jpg	→ S shift right but cause DWL (inefficient)
crop_img/micro_econ_note_79_crop_0.jpg	Chaptor 7:
crop_img/micro_econ_note_79_crop_1.jpg	International Trade
crop_img/micro_econ_note_79_crop_2.jpg	Comparative advantage: A has comparative advantage to B when A produces
crop_img/micro_econ_note_79_crop_3.jpg	one thing with lower opportunity cost than B
crop_img/micro_econ_note_79_crop_4.jpg	National Comp ad: A and B are nations
crop_img/micro_econ_note_79_crop_5.jpg	0) Import & Export
crop_img/micro_econ_note_79_crop_6.jpg	goods
crop_img/micro_econ_note_79_crop_7.jpg	Free Trade w/ Tariff
crop_img/micro_econ_note_79_crop_8.jpg	Free Trade
crop_img/micro_econ_note_79_crop_9.jpg	P
crop_img/micro_econ_note_79_crop_10.jpg	L
crop_img/micro_econ_note_79_crop_11.jpg	S
crop_img/micro_econ_note_79_crop_12.jpg	S
crop_img/micro_econ_note_79_crop_13.jpg	D
crop_img/micro_econ_note_79_crop_14.jpg	D
crop_img/micro_econ_note_79_crop_15.jpg	C sur
crop_img/micro_econ_note_79_crop_16.jpg	π
crop_img/micro_econ_note_79_crop_17.jpg	→
crop_img/micro_econ_note_79_crop_18.jpg	World P +ta)
crop_img/micro_econ_note_79_crop_19.jpg	World
crop_img/micro_econ_note_79_crop_20.jpg	2
crop_img/micro_econ_note_79_crop_21.jpg	OWL
crop_img/micro_econ_note_79_crop_22.jpg	world
crop_img/micro_econ_note_79_crop_23.jpg	Import
crop_img/micro_econ_note_79_crop_24.jpg	8
crop_img/micro_econ_note_79_crop_25.jpg	tar rev
crop_img/micro_econ_note_79_crop_26.jpg	Import
crop_img/micro_econ_note_79_crop_27.jpg	Q bought
crop_img/micro_econ_note_79_crop_28.jpg	Q
crop_img/micro_econ_note_79_crop_29.jpg	Q sold
crop_img/micro_econ_note_79_crop_30.jpg	sold bought
crop_img/micro_econ_note_79_crop_31.jpg	Q
crop_img/micro_econ_note_79_crop_32.jpg	by us
crop_img/micro_econ_note_79_crop_33.jpg	by us con
crop_img/micro_econ_note_79_crop_34.jpg	Import ↓ pro
crop_img/micro_econ_note_79_crop_35.jpg	. Tariff revenue earned by gov
crop_img/micro_econ_note_79_crop_36.jpg	) Import quota: limits the Q of goods that can be imported in a
crop_img/micro_econ_note_79_crop_37.jpg	given period
crop_img/micro_econ_note_79_crop_38.jpg	. Same effect as tariff except tariff rev is now importers' profit
crop_img/micro_econ_note_79_crop_39.jpg	) Trade war: A situation where one country increases its tariff
crop_img/micro_econ_note_79_crop_40.jpg	on another
crop_img/micro_econ_note_79_crop_41.jpg	country, and the country that suffers the tariff does the same thing
crop_img/micro_econ_note_79_crop_42.jpg	1
crop_img/micro_econ_note_79_crop_43.jpg	Chaptor 17:
crop_img/micro_econ_note_79_crop_44.jpg	Externalities
crop_img/micro_econ_note_80_crop_0.jpg	) Externality: A market exchange affects a 3rd party
crop_img/micro_econ_note_80_crop_1.jpg	. Negative Externality: create a cost
crop_img/micro_econ_note_80_crop_2.jpg	. Production: comes from production (burning coal)
crop_img/micro_econ_note_80_crop_3.jpg	consumption (smoking)
crop_img/micro_econ_note_80_crop_4.jpg	Consumption;
crop_img/micro_econ_note_80_crop_5.jpg	Positive Externality: create a benefit
crop_img/micro_econ_note_80_crop_6.jpg	、
crop_img/micro_econ_note_80_crop_7.jpg	. Production: new technologies
crop_img/micro_econ_note_80_crop_8.jpg	. Consumption: plant tree
crop_img/micro_econ_note_80_crop_9.jpg	(MLC)
crop_img/micro_econ_note_80_crop_10.jpg	Marginal private cost: the cost of an additional unit that is taken by
crop_img/micro_econ_note_80_crop_11.jpg	the producer
crop_img/micro_econ_note_80_crop_12.jpg	(MEC)
crop_img/micro_econ_note_80_crop_13.jpg	Marginal external cost:
crop_img/micro_econ_note_80_crop_14.jpg	by others except the producers
crop_img/micro_econ_note_80_crop_15.jpg	Without externalities, MEC = 0
crop_img/micro_econ_note_80_crop_16.jpg	(MSC)
crop_img/micro_econ_note_80_crop_17.jpg	Marginal social cost: the marginal cost caused by everyone
crop_img/micro_econ_note_80_crop_18.jpg	. MSC = MC + MEC
crop_img/micro_econ_note_80_crop_19.jpg	MSC
crop_img/micro_econ_note_80_crop_20.jpg	MEC
crop_img/micro_econ_note_80_crop_21.jpg	MC (S)
crop_img/micro_econ_note_80_crop_22.jpg	eff
crop_img/micro_econ_note_80_crop_23.jpg	equi (not efficient because the external
crop_img/micro_econ_note_80_crop_24.jpg	producer's cause they don't count
crop_img/micro_econ_note_80_crop_25.jpg	Approaches to reducing inefficiency from () externalities
crop_img/micro_econ_note_80_crop_26.jpg	)
crop_img/micro_econ_note_80_crop_27.jpg	① Establish property right
crop_img/micro_econ_note_80_crop_28.jpg	. Ex: producer vs cause dmg to houses → get sued → has to count
crop_img/micro_econ_note_80_crop_29.jpg	this penalty fee into the private cost of l
crop_img/micro_econ_note_81_crop_0.jpg	2 Establish Gov mandates
crop_img/micro_econ_note_81_crop_1.jpg	When property right is too hard to enforce public choices are
crop_img/micro_econ_note_81_crop_2.jpg	made
crop_img/micro_econ_note_81_crop_3.jpg	③ Tax or cap the price of the externality
crop_img/micro_econ_note_81_crop_4.jpg	(Not in exam)
crop_img/micro_econ_note_81_crop_5.jpg	. Pigouvian Taxes: Taxes on (-) externality
crop_img/micro_econ_note_81_crop_6.jpg	MSC
crop_img/micro_econ_note_81_crop_7.jpg	MC+Tax
crop_img/micro_econ_note_81_crop_8.jpg	eff
crop_img/micro_econ_note_81_crop_9.jpg	MC(S)
crop_img/micro_econ_note_81_crop_10.jpg	equi
crop_img/micro_econ_note_81_crop_11.jpg	MSB
crop_img/micro_econ_note_81_crop_12.jpg	→
crop_img/micro_econ_note_81_crop_13.jpg	. cap quota - a pollution quota
crop_img/micro_econ_note_81_crop_14.jpg	• Cap at Msc= Mse
crop_img/micro_econ_note_81_crop_15.jpg	Marginal abatement cost: cost of reducing one additional pollution
crop_img/micro_econ_note_81_crop_16.jpg	unit
crop_img/micro_econ_note_81_crop_17.jpg	) Coase Theorem: if property right exist, and transaction cost of
crop_img/micro_econ_note_81_crop_18.jpg	enforcing them are low, then private transactions are efficient and
crop_img/micro_econ_note_81_crop_19.jpg	it
crop_img/micro_econ_note_81_crop_20.jpg	doesn't matter who has property rights
crop_img/micro_econ_note_81_crop_21.jpg	Polluter gt property right efficient (they have to deal with it)
crop_img/micro_econ_note_81_crop_22.jpg	Jf
crop_img/micro_econ_note_81_crop_23.jpg	people expect Polluter get property rights efficient if only
crop_img/micro_econ_note_81_crop_24.jpg	low transaction cost of enforcing them (lawyer costs)
crop_img/micro_econ_note_81_crop_25.jpg	classification of goods:
crop_img/micro_econ_note_81_crop_26.jpg	. Excludable:
crop_img/micro_econ_note_81_crop_27.jpg	responsible to prevent someone from enjoying its benefits
crop_img/micro_econ_note_81_crop_28.jpg	。 Nonexcludable
crop_img/micro_econ_note_81_crop_29.jpg	. Rival
crop_img/micro_econ_note_81_crop_30.jpg	: one person's use ↓ available for others
crop_img/micro_econ_note_82_crop_0.jpg	• Nonrival
crop_img/micro_econ_note_82_crop_1.jpg	Excludable + Rival: Food
crop_img/micro_econ_note_82_crop_2.jpg	(private good)
crop_img/micro_econ_note_82_crop_3.jpg	Excludable + Nonrival: Internet (club good)
crop_img/micro_econ_note_82_crop_4.jpg	Nonexcludable + Rival: Fish in oceans (Common resource)
crop_img/micro_econ_note_82_crop_5.jpg	Nonexcludable + Nonrival: National defense (Public good)
crop_img/micro_econ_note_82_crop_6.jpg	) Freerider problem: people benefit from goods/services without paying
crop_img/micro_econ_note_82_crop_7.jpg	for them → Market failure
crop_img/micro_econ_note_82_crop_8.jpg	DWL from overfishing
crop_img/micro_econ_note_82_crop_9.jpg	MSC
crop_img/micro_econ_note_82_crop_10.jpg	Price
crop_img/micro_econ_note_82_crop_11.jpg	the larger fish caught, the larger the cost (harder
crop_img/micro_econ_note_82_crop_12.jpg	(tuna)
crop_img/micro_econ_note_82_crop_13.jpg	for others to catch fish)
crop_img/micro_econ_note_82_crop_14.jpg	MC=S
crop_img/micro_econ_note_82_crop_15.jpg	efficient
crop_img/micro_econ_note_82_crop_16.jpg	P
crop_img/micro_econ_note_82_crop_17.jpg	-----DWL
crop_img/micro_econ_note_82_crop_18.jpg	actual
crop_img/micro_econ_note_82_crop_19.jpg	p
crop_img/micro_econ_note_82_crop_20.jpg	I
crop_img/micro_econ_note_82_crop_21.jpg	1
crop_img/micro_econ_note_82_crop_22.jpg	1
crop_img/micro_econ_note_82_crop_23.jpg	MSB=D
crop_img/micro_econ_note_82_crop_24.jpg	|
crop_img/micro_econ_note_82_crop_25.jpg	1
crop_img/micro_econ_note_82_crop_26.jpg	efficient
crop_img/micro_econ_note_82_crop_27.jpg	actual
crop_img/micro_econ_note_82_crop_28.jpg	Quantity
crop_img/micro_econ_note_82_crop_29.jpg	Q
crop_img/micro_econ_note_82_crop_30.jpg	Q
crop_img/micro_econ_note_82_crop_31.jpg	(tuna)
crop_img/micro_econ_note_82_crop_32.jpg	Overfishing
crop_img/micro_econ_note_82_crop_33.jpg	(MB)
crop_img/micro_econ_note_82_crop_34.jpg	 Marginal private benefit
crop_img/micro_econ_note_82_crop_35.jpg	: the benefit that the consumer of a good
crop_img/micro_econ_note_82_crop_36.jpg	or service receives from an additional unit
crop_img/micro_econ_note_82_crop_37.jpg	(MEB)
crop_img/micro_econ_note_82_crop_38.jpg	) Marginal external benefit: the benefit that people except consumers
crop_img/micro_econ_note_82_crop_39.jpg	receive from an additional unit of a good/service
crop_img/micro_econ_note_82_crop_40.jpg	(MSB)
crop_img/micro_econ_note_82_crop_41.jpg	0) Marginal social benefit:
crop_img/micro_econ_note_82_crop_42.jpg	the marginal benefit that everyone receives
crop_img/micro_econ_note_83_crop_0.jpg	P
crop_img/micro_econ_note_83_crop_1.jpg	MSC(S)
crop_img/micro_econ_note_83_crop_2.jpg	MEB
crop_img/micro_econ_note_83_crop_3.jpg	DWL
crop_img/micro_econ_note_83_crop_4.jpg	7
crop_img/micro_econ_note_83_crop_5.jpg	e88
crop_img/micro_econ_note_83_crop_6.jpg	because at this point people also
crop_img/micro_econ_note_83_crop_7.jpg	equi
crop_img/micro_econ_note_83_crop_8.jpg	create benefits for others, not
crop_img/micro_econ_note_83_crop_9.jpg	only themselves
crop_img/micro_econ_note_83_crop_10.jpg	MSB
crop_img/micro_econ_note_83_crop_11.jpg	MB(0)
crop_img/micro_econ_note_83_crop_12.jpg	→
crop_img/micro_econ_note_83_crop_13.jpg	Q
crop_img/micro_econ_note_83_crop_14.jpg	(ETN)
crop_img/micro_econ_note_83_crop_15.jpg	Approaches to increase eff using (t) externalities:
crop_img/micro_econ_note_83_crop_16.jpg	① Public production: public authority given revenue by gov to produce
crop_img/micro_econ_note_83_crop_17.jpg	a good/service
crop_img/micro_econ_note_83_crop_18.jpg	Subsidies: payment to private producers by gov
crop_img/micro_econ_note_83_crop_19.jpg	③
crop_img/micro_econ_note_83_crop_20.jpg	Vouchers: a token gov gives households to buy a specific
crop_img/micro_econ_note_83_crop_21.jpg	good/service
crop_img/micro_econ_note_83_crop_22.jpg	Note: All of these cost money (gov user taxes), but if done right
crop_img/micro_econ_note_83_crop_23.jpg	can achieve an efficient outcome
crop_img/micro_econ_note_83_crop_24.jpg	)The tragedy of commons: A person uses too much of a common resource & 
crop_img/micro_econ_note_83_crop_25.jpg	they cause others in the city to suffer
crop_img/micro_econ_note_83_crop_26.jpg	Chap11
crop_img/micro_econ_note_83_crop_27.jpg	) Short run: Capital, land, entrepreneurship fixed
crop_img/micro_econ_note_83_crop_28.jpg	Labor is variable
crop_img/micro_econ_note_83_crop_29.jpg	) Long run: all factors of production can be varied
crop_img/micro_econ_note_84_crop_0.jpg	 Marginal product of labor: D total output results from an additional
crop_img/micro_econ_note_84_crop_1.jpg	unit of labor
crop_img/micro_econ_note_84_crop_2.jpg	 Diminishing marginal return: occur when the marginal product of
crop_img/micro_econ_note_84_crop_3.jpg	an additional worker is less than that of the previous worker
crop_img/micro_econ_note_84_crop_4.jpg	Output  
crop_img/micro_econ_note_84_crop_5.jpg	个  
crop_img/micro_econ_note_84_crop_6.jpg	V  
crop_img/micro_econ_note_84_crop_7.jpg	Labon  
crop_img/micro_econ_note_84_crop_8.jpg	) short-run cost:  
crop_img/micro_econ_note_84_crop_9.jpg	(TFC)  
crop_img/micro_econ_note_84_crop_10.jpg	.Total fixed cost: the cost of the firm fixed factor  
crop_img/micro_econ_note_84_crop_11.jpg	(TVC)  
crop_img/micro_econ_note_84_crop_12.jpg	. Total  
crop_img/micro_econ_note_84_crop_13.jpg	variable cost: the cost of the firm's variable factor  
crop_img/micro_econ_note_84_crop_14.jpg	(TC)  
crop_img/micro_econ_note_84_crop_15.jpg	·Total cost; TC=TFC+TVC  
crop_img/micro_econ_note_84_crop_16.jpg	(AFC)  
crop_img/micro_econ_note_84_crop_17.jpg	TFC  
crop_img/micro_econ_note_84_crop_18.jpg	• Average fixed cost  
crop_img/micro_econ_note_84_crop_19.jpg	…  
crop_img/micro_econ_note_84_crop_20.jpg	Q  
crop_img/micro_econ_note_84_crop_21.jpg	(AVC)  
crop_img/micro_econ_note_84_crop_22.jpg	TVC  
crop_img/micro_econ_note_84_crop_23.jpg	Average variable cost:  
crop_img/micro_econ_note_84_crop_24.jpg	Q  
crop_img/micro_econ_note_84_crop_25.jpg	(ATC)  
crop_img/micro_econ_note_84_crop_26.jpg	Average total cost: ATC= AFC +AVC  
crop_img/micro_econ_note_84_crop_27.jpg	Marginal Cost: The increase in total cost from a one-unit increase  
crop_img/micro_econ_note_84_crop_28.jpg	in output  
crop_img/micro_econ_note_84_crop_29.jpg	ΔTC  
crop_img/micro_econ_note_84_crop_30.jpg	.MC  
crop_img/micro_econ_note_84_crop_31.jpg	△Q  
crop_img/micro_econ_note_85_crop_0.jpg	cost  
crop_img/micro_econ_note_85_crop_1.jpg	ATC  
crop_img/micro_econ_note_85_crop_2.jpg	个  
crop_img/micro_econ_note_85_crop_3.jpg	MC  
crop_img/micro_econ_note_85_crop_4.jpg	AVC (variable cost keep  
crop_img/micro_econ_note_85_crop_5.jpg	lowest  
crop_img/micro_econ_note_85_crop_6.jpg	increasing)  
crop_img/micro_econ_note_85_crop_7.jpg	lowest  
crop_img/micro_econ_note_85_crop_8.jpg	AFC  
crop_img/micro_econ_note_85_crop_9.jpg	output (Q)  
crop_img/micro_econ_note_85_crop_10.jpg	) Short-run cost:  
crop_img/micro_econ_note_85_crop_11.jpg	cost  
crop_img/micro_econ_note_85_crop_12.jpg	个  
crop_img/micro_econ_note_85_crop_13.jpg	(1 machine)  
crop_img/micro_econ_note_85_crop_14.jpg	(2ma)  
crop_img/micro_econ_note_85_crop_15.jpg	(3ma)  
crop_img/micro_econ_note_85_crop_16.jpg	(4ma  
crop_img/micro_econ_note_85_crop_17.jpg	ATC2  
crop_img/micro_econ_note_85_crop_18.jpg	ATC  
crop_img/micro_econ_note_85_crop_19.jpg	ATC  
crop_img/micro_econ_note_85_crop_20.jpg	ATC  
crop_img/micro_econ_note_85_crop_21.jpg	3  
crop_img/micro_econ_note_85_crop_22.jpg	output (Q)  
crop_img/micro_econ_note_85_crop_23.jpg	. ↑capital→↑output  
crop_img/micro_econ_note_85_crop_24.jpg	(LRAC)  
crop_img/micro_econ_note_85_crop_25.jpg	Long-Run Average Cost Curve: a firm operates on its LRAC when it  
crop_img/micro_econ_note_85_crop_26.jpg	produces a given output at the least possible cost  
crop_img/micro_econ_note_85_crop_27.jpg	cost  
crop_img/micro_econ_note_85_crop_28.jpg	(1 machine)  
crop_img/micro_econ_note_85_crop_29.jpg	(2ma) (3ma)  
crop_img/micro_econ_note_85_crop_30.jpg	(4ma  
crop_img/micro_econ_note_85_crop_31.jpg	ATC  
crop_img/micro_econ_note_85_crop_32.jpg	ATC  
crop_img/micro_econ_note_85_crop_33.jpg	ATC  
crop_img/micro_econ_note_85_crop_34.jpg	LRAC  
crop_img/micro_econ_note_85_crop_35.jpg	3  
crop_img/micro_econ_note_85_crop_36.jpg	output()  
crop_img/micro_econ_note_86_crop_0.jpg	Economies of scale: features of a firm's technology that makes  
crop_img/micro_econ_note_86_crop_1.jpg	ATC fall as Q increases  
crop_img/micro_econ_note_86_crop_2.jpg	. Where LRAC falls  
crop_img/micro_econ_note_86_crop_3.jpg	maker  
crop_img/micro_econ_note_86_crop_4.jpg	) Diseconomies of scale:  
crop_img/micro_econ_note_86_crop_5.jpg	ATC rises  
crop_img/micro_econ_note_86_crop_6.jpg	. Where LRAC increases  
crop_img/micro_econ_note_86_crop_7.jpg	) Constant return to scale:  
crop_img/micro_econ_note_86_crop_8.jpg	maker  
crop_img/micro_econ_note_86_crop_9.jpg	ATC constant  
crop_img/micro_econ_note_86_crop_10.jpg	. Where LRAC is horizontal  
crop_img/micro_econ_note_86_crop_11.jpg	Minimum Efficient Scale: the smallest output at which long-run  
crop_img/micro_econ_note_86_crop_12.jpg	.  
crop_img/micro_econ_note_86_crop_13.jpg	average cost reaches minimum  
crop_img/micro_econ_note_86_crop_14.jpg	cost  
crop_img/micro_econ_note_86_crop_15.jpg	(1 machine)  
crop_img/micro_econ_note_86_crop_16.jpg	(2ma) (3ma)  
crop_img/micro_econ_note_86_crop_17.jpg	(4ma  
crop_img/micro_econ_note_86_crop_18.jpg	ATC  
crop_img/micro_econ_note_86_crop_19.jpg	ATC  
crop_img/micro_econ_note_86_crop_20.jpg	ATC  
crop_img/micro_econ_note_86_crop_21.jpg	ATC  
crop_img/micro_econ_note_86_crop_22.jpg	2  
crop_img/micro_econ_note_86_crop_23.jpg	LRAC  
crop_img/micro_econ_note_86_crop_24.jpg	3  
crop_img/micro_econ_note_86_crop_25.jpg	output (Q)  
crop_img/micro_econ_note_86_crop_26.jpg	min efficient  
crop_img/micro_econ_note_86_crop_27.jpg	scale  
crop_img/micro_econ_note_86_crop_28.jpg	Chap 10:  
crop_img/micro_econ_note_86_crop_29.jpg	Intro to Firm  
crop_img/micro_econ_note_86_crop_30.jpg	Business organization  
crop_img/micro_econ_note_86_crop_31.jpg	4 market types: perfect competition, monopolistic competition, monopoly, oligopoly  
crop_img/micro_econ_note_86_crop_32.jpg	) Perfect competition:  
crop_img/micro_econ_note_86_crop_33.jpg	. Many buyers and sellers with an identical product  
crop_img/micro_econ_note_87_crop_0.jpg	. No individual buyer or seller can affect price (price-taker)  
crop_img/micro_econ_note_87_crop_1.jpg	. No barrier to entry of new firms
crop_img/micro_econ_note_87_crop_2.jpg	Ex: wheat, cotton ) price
crop_img/micro_econ_note_87_crop_3.jpg	.)
crop_img/micro_econ_note_87_crop_4.jpg	Monopolistic comp:
crop_img/micro_econ_note_87_crop_5.jpg	A large number of firms compete by making similar but slightly
crop_img/micro_econ_note_87_crop_6.jpg	diff from dot (product differentiation)
crop_img/micro_econ_note_87_crop_7.jpg	)Monopoly:
crop_img/micro_econ_note_87_crop_8.jpg	One firm
crop_img/micro_econ_note_87_crop_9.jpg	. produce good I service with no close substitute
crop_img/micro_econ_note_87_crop_10.jpg	. a barrier to entry
crop_img/micro_econ_note_87_crop_11.jpg	Can be local or global
crop_img/micro_econ_note_87_crop_12.jpg	Ex of local monopoly : water suppliers
crop_img/micro_econ_note_87_crop_13.jpg	) oligopoly
crop_img/micro_econ_note_87_crop_14.jpg	. A small # firms compete
crop_img/micro_econ_note_87_crop_15.jpg	. Might produce differentiated products
crop_img/micro_econ_note_87_crop_16.jpg	.Firms act strategically by anticipating actions of other player
crop_img/micro_econ_note_87_crop_17.jpg	-) comp level of the 4 market types:
crop_img/micro_econ_note_87_crop_18.jpg	perfect comp
crop_img/micro_econ_note_87_crop_19.jpg	>mono comp>
crop_img/micro_econ_note_87_crop_20.jpg	oligopoly
crop_img/micro_econ_note_87_crop_21.jpg	>mono
crop_img/micro_econ_note_87_crop_22.jpg	4-firm%
crop_img/micro_econ_note_87_crop_23.jpg	↑
crop_img/micro_econ_note_87_crop_24.jpg	) Four-firm concentration ratio: % of total value of sales accounted
crop_img/micro_econ_note_87_crop_25.jpg	for by the 4 largest firms in an industry
crop_img/micro_econ_note_87_crop_26.jpg	.o for perfect comp
crop_img/micro_econ_note_88_crop_0.jpg	1o0o for monopoly
crop_img/micro_econ_note_88_crop_1.jpg	.>6o : highly concentrated and dominated by a few firms
crop_img/micro_econ_note_88_crop_2.jpg	 <60% : indicate a comp market
crop_img/micro_econ_note_88_crop_3.jpg	(UH index)
crop_img/micro_econ_note_88_crop_4.jpg	Herfindahl-Hirschman Index:
crop_img/micro_econ_note_88_crop_5.jpg	squared percentage market share
crop_img/micro_econ_note_88_crop_6.jpg	of each firm summed over the largest 5o firms in the market
crop_img/micro_econ_note_88_crop_7.jpg	 HHI is small in perfect competition
crop_img/micro_econ_note_88_crop_8.jpg	. Monopoly HHI = 100 = 10000
crop_img/micro_econ_note_88_crop_9.jpg	. A market where HHI > 2500 is uncompetitive
crop_img/micro_econ_note_88_crop_10.jpg	) Limitations of concentration measure: fail to account for
crop_img/micro_econ_note_88_crop_11.jpg	① Geographical scope of the market: because it takes on the whole
crop_img/micro_econ_note_88_crop_12.jpg	nation
crop_img/micro_econ_note_88_crop_13.jpg	Ex: concentration measure for newspaper is low, but in cities it is
crop_img/micro_econ_note_88_crop_14.jpg	highly
crop_img/micro_econ_note_88_crop_15.jpg	concentrated
crop_img/micro_econ_note_88_crop_16.jpg	2
crop_img/micro_econ_note_88_crop_17.jpg	Barriers to entry and firm turnover :
crop_img/micro_econ_note_88_crop_18.jpg	. Some market are highly concentrated but entry is easy and turnover
crop_img/micro_econ_note_88_crop_19.jpg	large
crop_img/micro_econ_note_88_crop_20.jpg	.A market with few firms might be competitive because of potential
crop_img/micro_econ_note_88_crop_21.jpg	entry
crop_img/micro_econ_note_88_crop_22.jpg	③
crop_img/micro_econ_note_88_crop_23.jpg	Market doesn't equate to industry
crop_img/micro_econ_note_88_crop_24.jpg	. Concentration ratio based on industry, but market is usually smaller
crop_img/micro_econ_note_88_crop_25.jpg	than industries
crop_img/micro_econ_note_89_crop_0.jpg	Ex: Pharmaceutical industry has a low concentration ratio but
crop_img/micro_econ_note_89_crop_1.jpg	the measles vaccine and AIDS fighting drug don't compete
crop_img/micro_econ_note_89_crop_2.jpg	With each other ( many monopolies)
crop_img/micro_econ_note_89_crop_3.jpg	.Firms assigned to one industry even if operate in many markets
crop_img/micro_econ_note_89_crop_4.jpg	. Firms switch from one market to another for opportunities
crop_img/micro_econ_note_89_crop_5.jpg	 Economies of Scope: when a firm uses specialized (often expensive)
crop_img/micro_econ_note_89_crop_6.jpg	resource to produce a range of goods and services
crop_img/micro_econ_note_89_crop_7.jpg	Chap 2:
crop_img/micro_econ_note_89_crop_8.jpg	Perfect Competition
crop_img/micro_econ_note_89_crop_9.jpg	) Perfect Competition : a market w/
crop_img/micro_econ_note_89_crop_10.jpg	• Many buyers and sellers
crop_img/micro_econ_note_89_crop_11.jpg	Identical product
crop_img/micro_econ_note_89_crop_12.jpg	a No restrictions on entry to the market
crop_img/micro_econ_note_89_crop_13.jpg	) Price takers: firms that cannot influence the market price because
crop_img/micro_econ_note_89_crop_14.jpg	its production is an insignificant part of the total market
crop_img/micro_econ_note_89_crop_15.jpg	In perfect comp market, all firms are price takers, f= market P
crop_img/micro_econ_note_89_crop_16.jpg	(charge higher → no one will buy)
crop_img/micro_econ_note_89_crop_17.jpg	(TR)
crop_img/micro_econ_note_89_crop_18.jpg	-) Total Revenue =  ×Q
crop_img/micro_econ_note_89_crop_19.jpg	(TC)
crop_img/micro_econ_note_89_crop_20.jpg	) total cost
crop_img/micro_econ_note_89_crop_21.jpg	=+VC+TFC
crop_img/micro_econ_note_89_crop_22.jpg	(EL)
crop_img/micro_econ_note_89_crop_23.jpg	If TR-TC<0
crop_img/micro_econ_note_89_crop_24.jpg	 Economic profit = TR-TC when TR-TC>0
crop_img/micro_econ_note_89_crop_25.jpg	→
crop_img/micro_econ_note_89_crop_26.jpg	(MR)
crop_img/micro_econ_note_89_crop_27.jpg	△TR
crop_img/micro_econ_note_89_crop_28.jpg	.) Marginal Revenue
crop_img/micro_econ_note_89_crop_29.jpg	=
crop_img/micro_econ_note_89_crop_30.jpg	△Q
crop_img/micro_econ_note_90_crop_0.jpg	Market for Corn
crop_img/micro_econ_note_90_crop_1.jpg	P
crop_img/micro_econ_note_90_crop_2.jpg	S
crop_img/micro_econ_note_90_crop_3.jpg	D
crop_img/micro_econ_note_90_crop_4.jpg	I=Imarket
crop_img/micro_econ_note_90_crop_5.jpg	(for all
crop_img/micro_econ_note_90_crop_6.jpg	firm)
crop_img/micro_econ_note_90_crop_7.jpg	→
crop_img/micro_econ_note_90_crop_8.jpg	Q
crop_img/micro_econ_note_90_crop_9.jpg	TR
crop_img/micro_econ_note_90_crop_10.jpg	(I =I market = const)
crop_img/micro_econ_note_90_crop_11.jpg	TR
crop_img/micro_econ_note_90_crop_12.jpg	Q
crop_img/micro_econ_note_90_crop_13.jpg	MR = market
crop_img/micro_econ_note_90_crop_14.jpg	(slope of TR os.a)
crop_img/micro_econ_note_90_crop_15.jpg	→
crop_img/micro_econ_note_90_crop_16.jpg	Q
crop_img/micro_econ_note_90_crop_17.jpg	Illustrating econ profit and loss:
crop_img/micro_econ_note_91_crop_0.jpg	→
crop_img/micro_econ_note_91_crop_1.jpg	Q
crop_img/micro_econ_note_91_crop_2.jpg	J
crop_img/micro_econ_note_91_crop_3.jpg	firm should
crop_img/micro_econ_note_91_crop_4.jpg	produce at
crop_img/micro_econ_note_91_crop_5.jpg	this Q
crop_img/micro_econ_note_91_crop_6.jpg	0) Illustrating MR,MC:
crop_img/micro_econ_note_91_crop_7.jpg	MR, MC
crop_img/micro_econ_note_91_crop_8.jpg	MC
crop_img/micro_econ_note_91_crop_9.jpg	MR
crop_img/micro_econ_note_91_crop_10.jpg	→
crop_img/micro_econ_note_91_crop_11.jpg	Q
crop_img/micro_econ_note_91_crop_12.jpg	) Shutdown Decision: When I< ATC → econ loss. Consider;
crop_img/micro_econ_note_91_crop_13.jpg	.If I>AVC : can recover in a long run
crop_img/micro_econ_note_91_crop_14.jpg	→ No shut down
crop_img/micro_econ_note_91_crop_15.jpg	.Is I< AVC : the longer operating, the more losing
crop_img/micro_econ_note_91_crop_16.jpg	→ Shut down
crop_img/micro_econ_note_92_crop_0.jpg	)Breakeven:
crop_img/micro_econ_note_92_crop_1.jpg	where I=ATC
crop_img/micro_econ_note_92_crop_2.jpg	MC
crop_img/micro_econ_note_92_crop_3.jpg	P
crop_img/micro_econ_note_92_crop_4.jpg	ATC
crop_img/micro_econ_note_92_crop_5.jpg	个
crop_img/micro_econ_note_92_crop_6.jpg	/AVC
crop_img/micro_econ_note_92_crop_7.jpg	breakeven
crop_img/micro_econ_note_92_crop_8.jpg	shut down
crop_img/micro_econ_note_92_crop_9.jpg	→
crop_img/micro_econ_note_92_crop_10.jpg	Q
crop_img/micro_econ_note_92_crop_11.jpg	When firm decides to shut down:
crop_img/micro_econ_note_92_crop_12.jpg	MC
crop_img/micro_econ_note_92_crop_13.jpg	f
crop_img/micro_econ_note_92_crop_14.jpg	shortrun
crop_img/micro_econ_note_92_crop_15.jpg	个
crop_img/micro_econ_note_92_crop_16.jpg	supply curve
crop_img/micro_econ_note_92_crop_17.jpg	AVC
crop_img/micro_econ_note_92_crop_18.jpg	→
crop_img/micro_econ_note_92_crop_19.jpg	Q
crop_img/micro_econ_note_92_crop_20.jpg	In the short run, firm's capital  # firm stay the same)
crop_img/micro_econ_note_92_crop_21.jpg	and I stays the same (at market)
crop_img/micro_econ_note_92_crop_22.jpg	 Short-run Market Supply curve : shows the quantity supplied by
crop_img/micro_econ_note_92_crop_23.jpg	all firms at each price in the short run
crop_img/micro_econ_note_92_crop_24.jpg	.) Possible Short-run outcomes :
crop_img/micro_econ_note_93_crop_0.jpg	Q
crop_img/micro_econ_note_93_crop_1.jpg	efficient
crop_img/micro_econ_note_93_crop_2.jpg	• Econ profit:
crop_img/micro_econ_note_93_crop_3.jpg	P>ATC
crop_img/micro_econ_note_93_crop_4.jpg	↑P
crop_img/micro_econ_note_93_crop_5.jpg	econ profit
crop_img/micro_econ_note_93_crop_6.jpg	MC
crop_img/micro_econ_note_93_crop_7.jpg	MR( Revenue/ unit)
crop_img/micro_econ_note_93_crop_8.jpg	V
crop_img/micro_econ_note_93_crop_9.jpg	ATC
crop_img/micro_econ_note_93_crop_10.jpg	(cost/unit)
crop_img/micro_econ_note_93_crop_11.jpg	Q
crop_img/micro_econ_note_93_crop_12.jpg	efficient
crop_img/micro_econ_note_93_crop_13.jpg	. Econ Loss: I<ATC
crop_img/micro_econ_note_93_crop_14.jpg	↑p
crop_img/micro_econ_note_93_crop_15.jpg	MC
crop_img/micro_econ_note_93_crop_16.jpg	ATC
crop_img/micro_econ_note_93_crop_17.jpg	econ loss
crop_img/micro_econ_note_93_crop_18.jpg	(cost/unit)
crop_img/micro_econ_note_93_crop_19.jpg	MR
crop_img/micro_econ_note_93_crop_20.jpg	Q
crop_img/micro_econ_note_93_crop_21.jpg	efficient
crop_img/micro_econ_note_94_crop_0.jpg	 Note: In the short-run, a firm can make an econ loss,
crop_img/micro_econ_note_94_crop_1.jpg	econ profit, or break even
crop_img/micro_econ_note_94_crop_2.jpg	In the long-run, a perfectly competitive firm can only
crop_img/micro_econ_note_94_crop_3.jpg	make zero econ profit due to entry and exit into the market
crop_img/micro_econ_note_94_crop_4.jpg	) Enter: when firms make econ profit (I>ATC), new firms
crop_img/micro_econ_note_94_crop_5.jpg	will enter the market
crop_img/micro_econ_note_94_crop_6.jpg	→ I market ↓ and econ profit ↓
crop_img/micro_econ_note_94_crop_7.jpg	 Exit: when firms have econ loss (I<ATC) firms exit market
crop_img/micro_econ_note_94_crop_8.jpg	→ I market ↑ and econ profit ↑
crop_img/micro_econ_note_94_crop_9.jpg	 Note: At equilibrium (no econ profit or loss) enter and exit stop
crop_img/micro_econ_note_94_crop_10.jpg	. In the long run, I=ATC
crop_img/micro_econ_note_94_crop_11.jpg	)Demand ↑:
crop_img/micro_econ_note_94_crop_12.jpg	Short run
crop_img/micro_econ_note_94_crop_13.jpg	Long run
crop_img/micro_econ_note_94_crop_14.jpg	P
crop_img/micro_econ_note_94_crop_15.jpg	S
crop_img/micro_econ_note_94_crop_16.jpg	P
crop_img/micro_econ_note_94_crop_17.jpg	S
crop_img/micro_econ_note_94_crop_18.jpg	S1
crop_img/micro_econ_note_94_crop_19.jpg	fP_{1 } ATC
crop_img/micro_econ_note_94_crop_20.jpg	B
crop_img/micro_econ_note_94_crop_21.jpg	$f_1}$
crop_img/micro_econ_note_94_crop_22.jpg	B
crop_img/micro_econ_note_94_crop_23.jpg	$_{1}$
crop_img/micro_econ_note_94_crop_24.jpg	L。
crop_img/micro_econ_note_94_crop_25.jpg	=ATC
crop_img/micro_econ_note_94_crop_26.jpg	\_}$
crop_img/micro_econ_note_94_crop_27.jpg	P_}$
crop_img/micro_econ_note_94_crop_28.jpg	A
crop_img/micro_econ_note_94_crop_29.jpg	A
crop_img/micro_econ_note_94_crop_30.jpg	(
crop_img/micro_econ_note_94_crop_31.jpg	2
crop_img/micro_econ_note_94_crop_32.jpg	1
crop_img/micro_econ_note_94_crop_33.jpg	D}$
crop_img/micro_econ_note_94_crop_34.jpg	D
crop_img/micro_econ_note_94_crop_35.jpg	4
crop_img/micro_econ_note_94_crop_36.jpg	1
crop_img/micro_econ_note_94_crop_37.jpg	→
crop_img/micro_econ_note_94_crop_38.jpg	0
crop_img/micro_econ_note_94_crop_39.jpg	Q
crop_img/micro_econ_note_94_crop_40.jpg	Q
crop_img/micro_econ_note_94_crop_41.jpg	Short run .0T→eT,Q个，econ profit occurs
crop_img/micro_econ_note_95_crop_0.jpg	Long run: new firms enter →S shift8 sight,pv, OT, zero
crop_img/micro_econ_note_95_crop_1.jpg	econ profit,# firms
crop_img/micro_econ_note_95_crop_2.jpg	)Demand:
crop_img/micro_econ_note_95_crop_3.jpg	Short run
crop_img/micro_econ_note_95_crop_4.jpg	Long run
crop_img/micro_econ_note_95_crop_5.jpg	P
crop_img/micro_econ_note_95_crop_6.jpg	P
crop_img/micro_econ_note_95_crop_7.jpg	S0
crop_img/micro_econ_note_95_crop_8.jpg	个
crop_img/micro_econ_note_95_crop_9.jpg	B
crop_img/micro_econ_note_95_crop_10.jpg	$_1$
crop_img/micro_econ_note_95_crop_11.jpg	P
crop_img/micro_econ_note_95_crop_12.jpg	A
crop_img/micro_econ_note_95_crop_13.jpg	P
crop_img/micro_econ_note_95_crop_14.jpg	A
crop_img/micro_econ_note_95_crop_15.jpg	6
crop_img/micro_econ_note_95_crop_16.jpg	B
crop_img/micro_econ_note_95_crop_17.jpg	1
crop_img/micro_econ_note_95_crop_18.jpg	D{}$
crop_img/micro_econ_note_95_crop_19.jpg	$P_1}$
crop_img/micro_econ_note_95_crop_20.jpg	D_{1$
crop_img/micro_econ_note_95_crop_21.jpg	0o
crop_img/micro_econ_note_95_crop_22.jpg	Do
crop_img/micro_econ_note_95_crop_23.jpg	→
crop_img/micro_econ_note_95_crop_24.jpg	>
crop_img/micro_econ_note_95_crop_25.jpg	a_{，Q。
crop_img/micro_econ_note_95_crop_26.jpg	Q
crop_img/micro_econ_note_95_crop_27.jpg	Q
crop_img/micro_econ_note_95_crop_28.jpg	Ch 13:
crop_img/micro_econ_note_95_crop_29.jpg	Monopoly
crop_img/micro_econ_note_95_crop_30.jpg	3 types of barrier to entry:
crop_img/micro_econ_note_95_crop_31.jpg	① Natural: economies of scale enable one firm to supply the entire
crop_img/micro_econ_note_95_crop_32.jpg	market
crop_img/micro_econ_note_95_crop_33.jpg	2
crop_img/micro_econ_note_95_crop_34.jpg	ownership: one firm owns a significant portion of key resource
crop_img/micro_econ_note_95_crop_35.jpg	③
crop_img/micro_econ_note_95_crop_36.jpg	legal: competition and entry are limited by granting of
crop_img/micro_econ_note_95_crop_37.jpg	public franchise: exclusive right to supply a good/service (uses
crop_img/micro_econ_note_95_crop_38.jpg	gov license: control entry into occupations/industries (med,law)
crop_img/micro_econ_note_95_crop_39.jpg	patent: right for invention
crop_img/micro_econ_note_95_crop_40.jpg	copyright: right granted to an author/composer for some
crop_img/micro_econ_note_96_crop_0.jpg	artistic work
crop_img/micro_econ_note_96_crop_1.jpg	。)
crop_img/micro_econ_note_96_crop_2.jpg	Monopoly Price-Setting Strategies:
crop_img/micro_econ_note_96_crop_3.jpg	. single price monopoly: all units have the same I
crop_img/micro_econ_note_96_crop_4.jpg	unity
crop_img/micro_econ_note_96_crop_5.jpg	diff
crop_img/micro_econ_note_96_crop_6.jpg	P
crop_img/micro_econ_note_96_crop_7.jpg	For Single I mono:
crop_img/micro_econ_note_96_crop_8.jpg	) Marginal Revenue curve:
crop_img/micro_econ_note_96_crop_9.jpg	always less than price
crop_img/micro_econ_note_96_crop_10.jpg	P
crop_img/micro_econ_note_96_crop_11.jpg	个
crop_img/micro_econ_note_96_crop_12.jpg	D
crop_img/micro_econ_note_96_crop_13.jpg	MR
crop_img/micro_econ_note_96_crop_14.jpg	Q
crop_img/micro_econ_note_96_crop_15.jpg	Marginal Revenue and Elasticity: monopoly never produces on inelastic
crop_img/micro_econ_note_96_crop_16.jpg	portion of D because at inelastic
crop_img/micro_econ_note_96_crop_17.jpg	P
crop_img/micro_econ_note_96_crop_18.jpg	portion,T→&maller T@puichared
crop_img/micro_econ_note_96_crop_19.jpg	个
crop_img/micro_econ_note_96_crop_20.jpg	Ed>1$
crop_img/micro_econ_note_96_crop_21.jpg	production happens
crop_img/micro_econ_note_96_crop_22.jpg	Ed<1
crop_img/micro_econ_note_96_crop_23.jpg	MR
crop_img/micro_econ_note_96_crop_24.jpg	D
crop_img/micro_econ_note_96_crop_25.jpg	Q
crop_img/micro_econ_note_96_crop_26.jpg	Monopoly can decrease a and T I to T profit
crop_img/micro_econ_note_97_crop_0.jpg	Vprofit =tR-tc
crop_img/micro_econ_note_97_crop_1.jpg	Qmonopoly
crop_img/micro_econ_note_97_crop_2.jpg	Q
crop_img/micro_econ_note_97_crop_3.jpg	.) max profit occurs at MR= MC
crop_img/micro_econ_note_97_crop_4.jpg	P
crop_img/micro_econ_note_97_crop_5.jpg	个
crop_img/micro_econ_note_97_crop_6.jpg	MC
crop_img/micro_econ_note_97_crop_7.jpg	90s
crop_img/micro_econ_note_97_crop_8.jpg	p*
crop_img/micro_econ_note_97_crop_9.jpg	ATC
crop_img/micro_econ_note_97_crop_10.jpg	1
crop_img/micro_econ_note_97_crop_11.jpg	MC=MR
crop_img/micro_econ_note_97_crop_12.jpg	0
crop_img/micro_econ_note_97_crop_13.jpg	MR
crop_img/micro_econ_note_97_crop_14.jpg	7
crop_img/micro_econ_note_97_crop_15.jpg	efficient
crop_img/micro_econ_note_97_crop_16.jpg	. p* doesn't have to →l。 because no firms can enter
crop_img/micro_econ_note_97_crop_17.jpg	→make profit even in the long run
crop_img/micro_econ_note_97_crop_18.jpg	A single-price monopoly produces a &maller output and charges
crop_img/micro_econ_note_97_crop_19.jpg	higher I than perfect comp market
crop_img/micro_econ_note_97_crop_20.jpg	) Perfect comp surplus: just like the simple market prototype)
crop_img/micro_econ_note_97_crop_21.jpg	except s can shut down
crop_img/micro_econ_note_98_crop_0.jpg	Q
crop_img/micro_econ_note_98_crop_1.jpg	) Monopoly
crop_img/micro_econ_note_98_crop_2.jpg	S
crop_img/micro_econ_note_98_crop_3.jpg	*
crop_img/micro_econ_note_98_crop_4.jpg	*
crop_img/micro_econ_note_98_crop_5.jpg	f
crop_img/micro_econ_note_98_crop_6.jpg	L
crop_img/micro_econ_note_98_crop_7.jpg	N
crop_img/micro_econ_note_98_crop_8.jpg	DWL
crop_img/micro_econ_note_98_crop_9.jpg	D
crop_img/micro_econ_note_98_crop_10.jpg	Q*
crop_img/micro_econ_note_98_crop_11.jpg	For price dix orimination monopoly
crop_img/micro_econ_note_98_crop_12.jpg	)& kinds of I disc:
crop_img/micro_econ_note_98_crop_13.jpg	Digf l for diff buyer
crop_img/micro_econ_note_98_crop_14.jpg	.Digg s for diff units of goods
crop_img/micro_econ_note_98_crop_15.jpg	0
crop_img/micro_econ_note_98_crop_16.jpg	Baopertier
crop_img/micro_econ_note_98_crop_17.jpg	By getting buyer to pay I dsert to the max willingness
crop_img/micro_econ_note_98_crop_18.jpg	→ Cap tue some Cs into fs
crop_img/micro_econ_note_98_crop_19.jpg	→T ls and eion profit
crop_img/micro_econ_note_99_crop_0.jpg	perfect I disc : an extreme case where each unit ins sold at max
crop_img/micro_econ_note_99_crop_1.jpg	)
crop_img/micro_econ_note_99_crop_2.jpg	willingness
crop_img/micro_econ_note_99_crop_3.jpg	→ No Cs, all become LS
crop_img/micro_econ_note_99_crop_4.jpg	.No OL → efficient
crop_img/micro_econ_note_99_crop_5.jpg	.The more perfectly the monopoly can I disc) the more efficient
crop_img/micro_econ_note_99_crop_6.jpg	) Regulating monopolies:
crop_img/micro_econ_note_99_crop_7.jpg	. MC pricing : L=MC → econ loN
crop_img/micro_econ_note_99_crop_8.jpg	. AVC pricing:L=AVC→ breakeven
crop_img/micro_econ_note_99_crop_9.jpg	. a methods to implement AVC pricing :
crop_img/micro_econ_note_99_crop_10.jpg	① Rate of return regulation: A firm must justify it I by
crop_img/micro_econ_note_99_crop_11.jpg	justify its rate of return
crop_img/micro_econ_note_99_crop_12.jpg	f cap regulation : I ceiling
crop_img/micro_econ_note_99_crop_13.jpg	2
crop_img/micro_econ_note_99_crop_14.jpg	Chap 14:
crop_img/micro_econ_note_99_crop_15.jpg	Monopolistic Competition
crop_img/micro_econ_note_99_crop_16.jpg	) Mono comp :
crop_img/micro_econ_note_99_crop_17.jpg	. A large # firms
crop_img/micro_econ_note_99_crop_18.jpg	producing a differentiated product
crop_img/micro_econ_note_99_crop_19.jpg	. No barriers to entry
crop_img/micro_econ_note_99_crop_20.jpg	)and a decision:
crop_img/micro_econ_note_99_crop_21.jpg	 A firm in mono po comp produce like a single-price mono
crop_img/micro_econ_note_99_crop_22.jpg	. In a short run, may earn econ profit /los/breakeven
crop_img/micro_econ_note_99_crop_23.jpg	. In a long run) only earn breakeven (due to enter/ leave)
crop_img/micro_econ_note_100_crop_0.jpg	.) Markup = s- MC
crop_img/micro_econ_note_100_crop_1.jpg	For perfect comp , Markup =0
crop_img/micro_econ_note_100_crop_2.jpg	 For mono comp)
crop_img/micro_econ_note_100_crop_3.jpg	Markup >0
crop_img/micro_econ_note_100_crop_4.jpg	) Excess capacity
crop_img/micro_econ_note_100_crop_5.jpg	Qesf
crop_img/micro_econ_note_100_crop_6.jpg	-Qprod ( es when I=ATC)
crop_img/micro_econ_note_100_crop_7.jpg	=1
crop_img/micro_econ_note_100_crop_8.jpg	=Qprod
crop_img/micro_econ_note_100_crop_9.jpg	 For mono comp)
crop_img/micro_econ_note_100_crop_10.jpg	Qeff
crop_img/micro_econ_note_100_crop_11.jpg	∠Q
crop_img/micro_econ_note_100_crop_12.jpg	prod
crop_img/micro_econ_note_100_crop_13.jpg	P
crop_img/micro_econ_note_100_crop_14.jpg	MC
crop_img/micro_econ_note_100_crop_15.jpg	p
crop_img/micro_econ_note_100_crop_16.jpg	MC
crop_img/micro_econ_note_100_crop_17.jpg	ATC
crop_img/micro_econ_note_100_crop_18.jpg	个
crop_img/micro_econ_note_100_crop_19.jpg	ATC
crop_img/micro_econ_note_100_crop_20.jpg	fsell
crop_img/micro_econ_note_100_crop_21.jpg	lsll
crop_img/micro_econ_note_100_crop_22.jpg	D=MR
crop_img/micro_econ_note_100_crop_23.jpg	I markup
crop_img/micro_econ_note_100_crop_24.jpg	大
crop_img/micro_econ_note_100_crop_25.jpg	=be88
crop_img/micro_econ_note_100_crop_26.jpg	lest
crop_img/micro_econ_note_100_crop_27.jpg	MRi
crop_img/micro_econ_note_100_crop_28.jpg	D
crop_img/micro_econ_note_100_crop_29.jpg	>
crop_img/micro_econ_note_100_crop_30.jpg	aeff
crop_img/micro_econ_note_100_crop_31.jpg	Q
crop_img/micro_econ_note_100_crop_32.jpg	aprod
crop_img/micro_econ_note_100_crop_33.jpg	Q
crop_img/micro_econ_note_100_crop_34.jpg	aprod
crop_img/micro_econ_note_100_crop_35.jpg	=aegs
crop_img/micro_econ_note_100_crop_36.jpg	) Efficiency :
crop_img/micro_econ_note_100_crop_37.jpg	when MSB=MSC
crop_img/micro_econ_note_100_crop_38.jpg	MSB =L
crop_img/micro_econ_note_100_crop_39.jpg	. MSC = MC
crop_img/micro_econ_note_100_crop_40.jpg	.And 2>MC
crop_img/micro_econ_note_100_crop_41.jpg	But product variety comes w/a cost→ Cvar
crop_img/micro_econ_note_100_crop_42.jpg	⇒Igl=MC+CorEf
crop_img/micro_econ_note_100_crop_43.jpg	o therwise not eff
crop_img/micro_econ_note_101_crop_0.jpg	Oligopoly
crop_img/micro_econ_note_101_crop_1.jpg	Chap 15:
crop_img/micro_econ_note_101_crop_2.jpg	) Oligopoly:
crop_img/micro_econ_note_101_crop_3.jpg	. A small # firm&
crop_img/micro_econ_note_101_crop_4.jpg	 Natural or legal barriers to entry
crop_img/micro_econ_note_101_crop_5.jpg	. Identical / differentiated product
crop_img/micro_econ_note_101_crop_6.jpg	. Compete on I,a, and marketing
crop_img/micro_econ_note_101_crop_7.jpg	 Duopoly: market w/ only 2 firm
crop_img/micro_econ_note_101_crop_8.jpg	)2ro pertiey:
crop_img/micro_econ_note_101_crop_9.jpg	.Interdependence : I and decision of firms affect the result
crop_img/micro_econ_note_101_crop_10.jpg	.Temptation to cooperate ; firms can together cooperate → form
crop_img/micro_econ_note_101_crop_11.jpg	a cartel, act like monopoly
crop_img/micro_econ_note_101_crop_12.jpg	cartel
crop_img/micro_econ_note_101_crop_13.jpg	a group of firms colluding to limit output and Te
crop_img/micro_econ_note_101_crop_15.jpg	to beat econ profit
crop_img/micro_econ_note_101_crop_16.jpg	game theory: a set of tools for studying strategic behavior
crop_img/micro_econ_note_101_crop_17.jpg	) game: have rules) strategies, payoffs, and outcome
crop_img/micro_econ_note_101_crop_18.jpg	) the prisoner's Dilemma: d prisoners committed a crime and are
crop_img/micro_econ_note_101_crop_19.jpg	put into d separate rooms for questioning
crop_img/micro_econ_note_101_crop_20.jpg	Rules:
crop_img/micro_econ_note_101_crop_21.jpg	If both confess, each receives 5-year sentence
crop_img/micro_econ_note_101_crop_22.jpg	If one confesses and one doesn't, the confessed receives 1-year
crop_img/micro_econ_note_101_crop_23.jpg	sentence, and the other receives 10-year sentence
crop_img/micro_econ_note_101_crop_24.jpg	If both deny, each receives 6-year sentence
crop_img/micro_econ_note_102_crop_0.jpg	strategies: confess/deny
crop_img/micro_econ_note_102_crop_1.jpg	. outcomes
crop_img/micro_econ_note_102_crop_2.jpg	. Both confess: 5-years each
crop_img/micro_econ_note_102_crop_3.jpg	deny: 6-years
crop_img/micro_econ_note_102_crop_4.jpg	。
crop_img/micro_econ_note_102_crop_5.jpg	A confesses, B denies: A→1 year, B→10 years
crop_img/micro_econ_note_102_crop_6.jpg	A denies, B confesses: A→10 years, B→1 year
crop_img/micro_econ_note_102_crop_7.jpg	.payoff matrix: show the outcome for every possible action done
crop_img/micro_econ_note_102_crop_8.jpg	by a player given the action of the other
crop_img/micro_econ_note_102_crop_9.jpg	A's strategy
crop_img/micro_econ_note_102_crop_10.jpg	C
crop_img/micro_econ_note_102_crop_11.jpg	D
crop_img/micro_econ_note_102_crop_12.jpg	C
crop_img/micro_econ_note_102_crop_13.jpg	A
crop_img/micro_econ_note_102_crop_14.jpg	A.
crop_img/micro_econ_note_102_crop_15.jpg	10
crop_img/micro_econ_note_102_crop_16.jpg	5
crop_img/micro_econ_note_102_crop_17.jpg	B's strategy
crop_img/micro_econ_note_102_crop_18.jpg	B:
crop_img/micro_econ_note_102_crop_19.jpg	B: 1
crop_img/micro_econ_note_102_crop_20.jpg	6
crop_img/micro_econ_note_102_crop_21.jpg	A: 1
crop_img/micro_econ_note_102_crop_22.jpg	A: 2
crop_img/micro_econ_note_102_crop_23.jpg	D
crop_img/micro_econ_note_102_crop_24.jpg	B: 10
crop_img/micro_econ_note_102_crop_25.jpg	B: 2
crop_img/micro_econ_note_102_crop_26.jpg	Nash equilibrium: each player takes the best possible action
crop_img/micro_econ_note_102_crop_27.jpg	given the action of the other player
crop_img/micro_econ_note_102_crop_28.jpg	) collusive agreement: agreement between firms to form a cartel
crop_img/micro_econ_note_102_crop_29.jpg	) cheat: one tries to ↓ profit of other seller and ↑ profit
crop_img/micro_econ_note_102_crop_30.jpg	of their own
crop_img/micro_econ_note_102_crop_31.jpg	Note: If game repeated, cooperative equilibrium can occur
crop_img/micro_econ_note_102_crop_32.jpg	) Mindsets:
crop_img/micro_econ_note_102_crop_33.jpg	①Tit-for-tat: cooperate if the other cooperated last time
crop_img/showcase_website_prepare_105_crop_0.jpg	Roles & Contributions
crop_img/showcase_website_prepare_105_crop_1.jpg	Duc Minho - Scrum Master
crop_img/showcase_website_prepare_105_crop_2.jpg	. Divide Tasks & assign deadline
crop_img/showcase_website_prepare_105_crop_3.jpg	Implement database model using
crop_img/showcase_website_prepare_105_crop_4.jpg	Implement reset password
crop_img/showcase_website_prepare_105_crop_5.jpg	Adjust admin page
crop_img/showcase_website_prepare_105_crop_6.jpg	Helped making the showcase Website
crop_img/showcase_website_prepare_105_crop_7.jpg	John Thai - Back-End
crop_img/showcase_website_prepare_105_crop_8.jpg	Implement user authentication account assign
crop_img/showcase_website_prepare_105_crop_9.jpg	login page, log out functionality
crop_img/showcase_website_prepare_105_crop_10.jpg	Implement the purchase functionality
crop_img/showcase_website_prepare_105_crop_11.jpg	the orders page
crop_img/showcase_website_prepare_105_crop_12.jpg	Implement
crop_img/showcase_website_prepare_105_crop_13.jpg	Helped making the showcase website
crop_img/showcase_website_prepare_105_crop_14.jpg	Sunny Lin - Front-End
crop_img/showcase_website_prepare_105_crop_15.jpg	operations of
crop_img/showcase_website_prepare_105_crop_16.jpg	. Implement the base template
crop_img/showcase_website_prepare_105_crop_17.jpg	Implement the Creating, Reading, Updating, Deleting (CRUD)
crop_img/showcase_website_prepare_105_crop_18.jpg	movie
crop_img/showcase_website_prepare_105_crop_19.jpg	review model
crop_img/showcase_website_prepare_105_crop_20.jpg	. Make the showcase video for the showcase website
crop_img/showcase_website_prepare_105_crop_21.jpg	Ierac Kwook - Full-Stack
crop_img/showcase_website_prepare_105_crop_22.jpg	Implement the cart app
crop_img/showcase_website_prepare_105_crop_23.jpg	Implement the CRUD
crop_img/showcase_website_prepare_105_crop_24.jpg	of movie cart
crop_img/showcase_website_prepare_105_crop_25.jpg	Implement the order and item model
crop_img/showcase_website_prepare_105_crop_26.jpg	Helped make the showcase website
crop_img/showcase_website_prepare_106_crop_0.jpg	Thinh Nguyen - Full-stack
crop_img/showcase_website_prepare_106_crop_1.jpg	. Implement the movies app (listing movies) enable user to click and
crop_img/showcase_website_prepare_106_crop_2.jpg	see their data
crop_img/showcase_website_prepare_106_crop_3.jpg	Update
crop_img/showcase_website_prepare_106_crop_4.jpg	the movie listing page and individual movie pages
crop_img/showcase_website_prepare_106_crop_5.jpg	with data from database
crop_img/showcase_website_prepare_106_crop_6.jpg	Implement a search functionality
crop_img/showcase_website_prepare_106_crop_7.jpg	Helped make the showcase website
crop_img/showcase_website_prepare_106_crop_8.jpg	Description:
crop_img/showcase_website_prepare_106_crop_9.jpg	How your team follows scrum and the design decision behind your
crop_img/showcase_website_prepare_106_crop_10.jpg	solutions (principles, patterns, etc.). Use diagram as tools to
crop_img/showcase_website_prepare_106_crop_11.jpg	communicate your rationale
crop_img/showcase_website_prepare_106_crop_12.jpg	• Discussion
crop_img/showcase_website_prepare_106_crop_13.jpg	. We discuss and finalize what our movie store should look like
crop_img/showcase_website_prepare_106_crop_14.jpg	Pages
crop_img/showcase_website_prepare_106_crop_15.jpg	●
crop_img/showcase_website_prepare_106_crop_16.jpg	Models
crop_img/showcase_website_prepare_106_crop_17.jpg	Functionalities
crop_img/showcase_website_prepare_106_crop_18.jpg	etc.
crop_img/showcase_website_prepare_106_crop_19.jpg	●
crop_img/showcase_website_prepare_106_crop_20.jpg	. Plan out major stages of the project:
crop_img/showcase_website_prepare_106_crop_21.jpg	. List small tasks on scrum board and assign deadlines every week
crop_img/showcase_website_prepare_106_crop_22.jpg	When we stuck at some point, we say it out during meeting
crop_img/showcase_website_prepare_106_crop_23.jpg	then together we find a way to resolve it. Usually, the
crop_img/showcase_website_prepare_106_crop_24.jpg	solution comes from the textbook and YouTube.
crop_img/software_description_214_crop_0.jpg	User stories for a GT Blog Website
crop_img/software_description_214_crop_1.jpg	①As a user I want to see the information about the GT Blog
crop_img/software_description_214_crop_2.jpg	so I can understand the app's purpose
crop_img/software_description_214_crop_4.jpg	As a user, I want to register an account using my GT
crop_img/software_description_214_crop_5.jpg	username
crop_img/software_description_214_crop_6.jpg	3
crop_img/software_description_214_crop_7.jpg	As a user, I want to log in so that I can access my account's data
crop_img/software_description_214_crop_8.jpg	4
crop_img/software_description_214_crop_9.jpg	As a user, I want to see the list of blogs other students
crop_img/software_description_214_crop_10.jpg	made with categorization keywords channel, inch
crop_img/software_description_214_crop_11.jpg	4CULC”,…
crop_img/software_description_214_crop_12.jpg	5
crop_img/software_description_214_crop_13.jpg	As a user, I want to search blogs based on categorization
crop_img/software_description_214_crop_14.jpg	key word, author name, blog title, date
crop_img/software_description_214_crop_15.jpg	As a user, I want to reset my password so that I can regain
crop_img/software_description_214_crop_16.jpg	⑥
crop_img/software_description_214_crop_17.jpg	access to my account if I forget it
crop_img/software_description_214_crop_18.jpg	As a user, I want to read what others comment on a blog
crop_img/software_description_214_crop_19.jpg	As a user, I want to make comments on others' blogs
crop_img/software_description_214_crop_20.jpg	8
crop_img/software_description_214_crop_21.jpg	9
crop_img/software_description_214_crop_22.jpg	As a user, I want to make my blog private only myself
crop_img/software_description_214_crop_23.jpg	can read them
crop_img/software_description_214_crop_24.jpg	As a user, I want to insert images into my blog
crop_img/software_description_214_crop_25.jpg	11
crop_img/software_description_214_crop_26.jpg	As a user, I want to change my profile picture
crop_img/software_design_cheatsheet_219_crop_0.jpg	SOLID:
crop_img/software_design_cheatsheet_219_crop_1.jpg	Design principle: guideline for designing software based on OO
crop_img/software_design_cheatsheet_219_crop_2.jpg	.Aims: understandability, extendability, maintainability
crop_img/software_design_cheatsheet_219_crop_3.jpg	.Avoid: rigidity, fragility, immobility, and viscosity
crop_img/software_design_cheatsheet_219_crop_4.jpg	Single Responsibility (S): Each class only has 1 job
crop_img/software_design_cheatsheet_219_crop_5.jpg	open/closed (O): open for extension, closed for modification
crop_img/software_design_cheatsheet_219_crop_6.jpg	.Meaning: We can add new functionality without altering old code
crop_img/software_design_cheatsheet_219_crop_7.jpg	Liskov Substitution (L): object of a superclass can be replaced by its
crop_img/software_design_cheatsheet_219_crop_8.jpg	subclass objects without damaging the program
crop_img/software_design_cheatsheet_219_crop_9.jpg	Interface Segregation (I): Don't force the clients to depend on things they don't use
crop_img/software_design_cheatsheet_219_crop_10.jpg	)
crop_img/software_design_cheatsheet_219_crop_11.jpg	Dependency Inversion (D): High-level classes don't depend on low-level ones
crop_img/software_design_cheatsheet_219_crop_12.jpg	GRASP: principles
crop_img/software_design_cheatsheet_219_crop_13.jpg	focus on assigning responsibilities to classes and objects
crop_img/software_design_cheatsheet_219_crop_14.jpg	Creator (pattern): object created by the class that has the most info to create it
crop_img/software_design_cheatsheet_219_crop_15.jpg	.When? aggregation or containment, tracking, close use initialization
crop_img/software_design_cheatsheet_219_crop_16.jpg	80
crop_img/software_design_cheatsheet_219_crop_17.jpg	data
crop_img/software_design_cheatsheet_219_crop_18.jpg	Information Expert: assign responsibility to the class that has the essential info to create it
crop_img/software_design_cheatsheet_219_crop_19.jpg	.Note: consider the type of support and what info are needed
crop_img/software_design_cheatsheet_219_crop_20.jpg	Low Coupling
crop_img/software_design_cheatsheet_219_crop_21.jpg	: reduce dependencies between classes as much as possible
crop_img/software_design_cheatsheet_219_crop_22.jpg	.How? use interfaces, abstract class, dependency injection, composition > inheritance,
crop_img/software_design_cheatsheet_219_crop_23.jpg	behavior encapsulation, avoid bidirectional relationship
crop_img/software_design_cheatsheet_220_crop_0.jpg	High Cohesion: Similar to S in SOLID
crop_img/software_design_cheatsheet_220_crop_1.jpg	,
crop_img/software_design_cheatsheet_220_crop_2.jpg	Controller: Keep the UI separate from the Model
crop_img/software_design_cheatsheet_220_crop_3.jpg	.How? when handling a system event, assign it to a non-UI class that
crop_img/software_design_cheatsheet_220_crop_4.jpg	helps the whole system / a use case scenario the system responds
crop_img/software_design_cheatsheet_220_crop_5.jpg	Polymorphism: Flexible and dynamic behavior in an application
crop_img/software_design_cheatsheet_220_crop_6.jpg	.Essential for low coupling
crop_img/software_design_cheatsheet_220_crop_7.jpg	Pure Fabrication: assign responsibility to classes that don't represent a concept
crop_img/software_design_cheatsheet_220_crop_8.jpg	When? when we cannot find a solution within the problem domain
crop_img/software_design_cheatsheet_220_crop_9.jpg	middle party
crop_img/software_design_cheatsheet_220_crop_10.jpg	) Indirection: Introduce an intermediate class or object to mediate between classes
crop_img/software_design_cheatsheet_220_crop_11.jpg	.When? when coupling is high
crop_img/software_design_cheatsheet_220_crop_12.jpg	. Similar to "Don't talk to strangers"
crop_img/software_design_cheatsheet_220_crop_13.jpg	Protected Variation: Protecting elements from the change of others
crop_img/software_design_cheatsheet_220_crop_14.jpg	.How? one element's change doesn't make others change
crop_img/software_design_cheatsheet_220_crop_15.jpg	Refactoring: small and technique to reorganize and understand
crop_img/software_design_cheatsheet_220_crop_16.jpg	maintain, improving design without changing functionality
crop_img/software_design_cheatsheet_220_crop_17.jpg	. Key feature: ensure program works at every detailed step
crop_img/software_design_cheatsheet_220_crop_18.jpg	why? Regular change, design improvement, programmer's topping
crop_img/software_design_cheatsheet_220_crop_19.jpg	Outcome: make program more flexible
crop_img/software_design_cheatsheet_220_crop_20.jpg	Ex: renaming, collapse hierarchy, consolidate/decompose conditions
crop_img/software_design_cheatsheet_220_crop_21.jpg	(ex: merge)
crop_img/software_design_cheatsheet_220_crop_22.jpg	(ex: combine conditions that → same result
crop_img/software_design_cheatsheet_220_crop_23.jpg	· replace complex conditions by method)
crop_img/software_design_cheatsheet_220_crop_24.jpg	extract class/method
crop_img/software_design_cheatsheet_220_crop_25.jpg	(ex: replace code fragment by method)
crop_img/software_design_cheatsheet_220_crop_26.jpg	(ex: a class doing ≥ a work → make a new class
crop_img/software_design_cheatsheet_221_crop_0.jpg	.When? when adding a new feature/review code/fixing bug
crop_img/software_design_cheatsheet_221_crop_1.jpg	.When not? broken code / close deadline / no need to
crop_img/software_design_cheatsheet_221_crop_2.jpg	Code Smell: A surface indication that usually corresponds to a deeper problem in systems
crop_img/software_design_cheatsheet_221_crop_3.jpg	.Usually found when refactoring / examining code
crop_img/software_design_cheatsheet_221_crop_4.jpg	.How come? rushed design/technical debt (lazy list → more work
crop_img/software_design_cheatsheet_221_crop_5.jpg	disregard
crop_img/software_design_cheatsheet_221_crop_6.jpg	later)
crop_img/software_design_cheatsheet_221_crop_7.jpg	Right way: use best practices + develop a design that can scale
crop_img/software_design_cheatsheet_221_crop_8.jpg	Fast way:
crop_img/software_design_cheatsheet_221_crop_9.jpg	"hacked together design) faster
crop_img/software_design_cheatsheet_221_crop_10.jpg	identical
crop_img/software_design_cheatsheet_221_crop_11.jpg	(group of two)
crop_img/software_design_cheatsheet_221_crop_12.jpg	Bloaters: Something too large and out of control
crop_img/software_design_cheatsheet_221_crop_13.jpg	(>10 lines)
crop_img/software_design_cheatsheet_221_crop_14.jpg	.sign: contain long / duplicated code, long data/method, data clump;
crop_img/software_design_cheatsheet_221_crop_15.jpg	long parameter list
crop_img/software_design_cheatsheet_221_crop_16.jpg	. How come? devs
crop_img/software_design_cheatsheet_221_crop_17.jpg	may be tempted to put new features into an
crop_img/software_design_cheatsheet_221_crop_18.jpg	existing class
crop_img/software_design_cheatsheet_221_crop_19.jpg	.statement: extract class/sub-class/method; try deleting a number
crop_img/software_design_cheatsheet_221_crop_20.jpg	to see if code still makes sense, extract data; breakup algorithm)
crop_img/software_design_cheatsheet_221_crop_21.jpg	use methods) pass the whole object as data (preserve whole
crop_img/software_design_cheatsheet_221_crop_22.jpg	object)
crop_img/software_design_cheatsheet_221_crop_23.jpg	.OO Abusers: so don't fully exploit OO designs
crop_img/software_design_cheatsheet_221_crop_24.jpg	.Sign: complex with sequence; refactored because
crop_img/software_design_cheatsheet_221_crop_25.jpg	subclass refactored to use all parent's methods)
crop_img/software_design_cheatsheet_221_crop_26.jpg	.why? For refused bequest, don't be tempted to use inheritance
crop_img/software_design_cheatsheet_221_crop_27.jpg	to reuseability
crop_img/software_design_cheatsheet_221_crop_28.jpg	.Theat ment : Extract method) polymorphism j push down method
crop_img/software_design_cheatsheet_221_crop_29.jpg	use interface , eliminate inheritance
crop_img/software_design_cheatsheet_222_crop_0.jpg	change Prevent rust that hinders changing /upgrading
crop_img/software_design_cheatsheet_222_crop_1.jpg	(Shotgun surgery)
crop_img/software_design_cheatsheet_222_crop_2.jpg	.sign: make modifi regs make small changes to many others j
crop_img/software_design_cheatsheet_222_crop_3.jpg	many changes made to only one case (Divergent change)
crop_img/software_design_cheatsheet_222_crop_4.jpg	.Why? Foientage: cost copy paste
crop_img/software_design_cheatsheet_222_crop_5.jpg	.Treatment : Combine to a single class ; Extract class/method
crop_img/software_design_cheatsheet_222_crop_6.jpg	Dispensable
crop_img/software_design_cheatsheet_222_crop_7.jpg	:unnecessary things
crop_img/software_design_cheatsheet_222_crop_8.jpg	• Sign: duplicated codes ; lazy data j data clump
crop_img/software_design_cheatsheet_222_crop_9.jpg	.Why? For lazy class, a class may become very small after several
crop_img/software_design_cheatsheet_222_crop_10.jpg	refactoring, or it 's designed for future dev that is never done
crop_img/software_design_cheatsheet_222_crop_11.jpg	. Treatment: Extract method ; Inline class ; Move/Extract method,
crop_img/software_design_cheatsheet_222_crop_12.jpg	encapsulation
crop_img/software_design_cheatsheet_222_crop_13.jpg	Coupler : closely connected routines /modules
crop_img/software_design_cheatsheet_222_crop_14.jpg	(Feature envy)
crop_img/software_design_cheatsheet_222_crop_15.jpg	.sign: a method seems more interested in a class than the one it's in)
crop_img/software_design_cheatsheet_222_crop_16.jpg	classes know too much about each other; class only do one action and
crop_img/software_design_cheatsheet_222_crop_17.jpg	1
crop_img/software_design_cheatsheet_222_crop_18.jpg	J
crop_img/software_design_cheatsheet_222_crop_19.jpg	delegate work to other classes
crop_img/software_design_cheatsheet_222_crop_20.jpg	middle
crop_img/software_design_cheatsheet_222_crop_21.jpg	Inappropriate intimacy
crop_img/software_design_cheatsheet_222_crop_22.jpg	man
crop_img/software_design_cheatsheet_222_crop_23.jpg	Why? For middle man, moving too much from a class resulting in
crop_img/software_design_cheatsheet_222_crop_24.jpg	it can only delegate work
crop_img/software_design_cheatsheet_222_crop_25.jpg	.Treatment: move method j move method/field change "association
crop_img/software_design_cheatsheet_222_crop_26.jpg	to"once=;inline class
crop_img/software_design_cheatsheet_222_crop_27.jpg	Design pattern: typical solutions to common problems in software design
crop_img/software_design_cheatsheet_222_crop_28.jpg	(like a blueprint if algo is like a recipe)
crop_img/software_design_cheatsheet_223_crop_0.jpg	Category of Lat
crop_img/software_design_cheatsheet_223_crop_1.jpg	-Generational fact: try to create suitable object→flexibility and code reuse
crop_img/software_design_cheatsheet_223_crop_2.jpg	Structural lat : explain how to assemble & carry larger structure
crop_img/software_design_cheatsheet_223_crop_3.jpg	(still flexible and
crop_img/software_design_cheatsheet_223_crop_4.jpg	efficient)
crop_img/software_design_cheatsheet_223_crop_5.jpg	Behavioral pattern: algorithm & assign of resp of object
crop_img/software_design_cheatsheet_223_crop_6.jpg	Singleton lat: Ensures we only one instance of a class ever gets
crop_img/software_design_cheatsheet_223_crop_7.jpg	created and all one global way to access it
crop_img/software_design_cheatsheet_223_crop_8.jpg	.Components: private constructor public static method, private static instance
crop_img/software_design_cheatsheet_223_crop_9.jpg	(to access)
crop_img/software_design_cheatsheet_223_crop_10.jpg	(store one
crop_img/software_design_cheatsheet_223_crop_11.jpg	variable
crop_img/software_design_cheatsheet_223_crop_12.jpg	instance
crop_img/software_design_cheatsheet_223_crop_13.jpg	only save an instance
crop_img/software_design_cheatsheet_223_crop_14.jpg	if null
crop_img/software_design_cheatsheet_223_crop_15.jpg	Strategy Lat:  Beh define a family of algo by putting them in separate
crop_img/software_design_cheatsheet_223_crop_16.jpg	classes and making their objects interchangeable
crop_img/software_design_cheatsheet_223_crop_17.jpg	. To maintain & grow
crop_img/software_design_cheatsheet_223_crop_18.jpg	(components :A strategy interface includes # concrete strategies)
crop_img/software_design_cheatsheet_223_crop_19.jpg	to use
crop_img/software_design_cheatsheet_223_crop_20.jpg	Factory Method lat: Ensures, using a factory method to create instances of
crop_img/software_design_cheatsheet_223_crop_21.jpg	a class instead of directly create them
crop_img/software_design_cheatsheet_223_crop_22.jpg	.Why? changing the type of object used can be challenging. We can
crop_img/software_design_cheatsheet_223_crop_23.jpg	decouple instance creation using factory method
crop_img/software_design_cheatsheet_223_crop_24.jpg	.Components: Interface product includes # concrete products a creator
crop_img/software_design_cheatsheet_223_crop_25.jpg	class that is inherited by concrete creator class or used to each concrete
crop_img/software_design_cheatsheet_223_crop_26.jpg	product
crop_img/software_design_cheatsheet_223_crop_27.jpg	Observer lat: Ensures, define a subscription mechanism to have multiple
crop_img/software_design_cheatsheet_223_crop_28.jpg	events issued by the “publisher" and multiple "observer" notified
crop_img/software_design_cheatsheet_223_crop_29.jpg	.Why? Sometimes a change to y needed to be notified to all
crop_img/software_design_cheatsheet_223_crop_30.jpg	other classes
crop_img/software_design_cheatsheet_224_crop_0.jpg	Component: publisher class that holds a list of subscribers, and
crop_img/software_design_cheatsheet_224_crop_1.jpg	concrete subscriber classes (implements the interface Subscriber)
crop_img/software_design_cheatsheet_224_crop_2.jpg	Composite lat: Ensures, all about creating true-like structure of objects.
crop_img/software_design_cheatsheet_224_crop_3.jpg	Treat individual objects and compositions uniformly
crop_img/software_design_cheatsheet_224_crop_4.jpg	components : delegate
crop_img/software_design_cheatsheet_224_crop_5.jpg	To all work to leaf
crop_img/software_design_cheatsheet_224_crop_6.jpg	. Components: interface Component, extended by
crop_img/software_design_cheatsheet_224_crop_7.jpg	V leaf: do all the work
crop_img/software_design_cheatsheet_224_crop_8.jpg	Visitor lat : Ensures, helps add operations to objects without altering
crop_img/software_design_cheatsheet_224_crop_9.jpg	those objects themselves (use an external class for this)
crop_img/software_design_cheatsheet_224_crop_10.jpg	• Component: Interface visitor, # concrete visitor classes implement Visitor
crop_img/software_design_cheatsheet_224_crop_11.jpg	# Concrete element used to each visitor class implements interface Element
crop_img/software_design_cheatsheet_224_crop_12.jpg	Decorator fact: Ensures, helps add features or behaviors to objects
crop_img/software_design_cheatsheet_224_crop_13.jpg	without changing the object's original class
crop_img/software_design_cheatsheet_224_crop_14.jpg	• Components : a Notifier class
crop_img/software_design_cheatsheet_224_crop_15.jpg	Base Decorator (where we will add features)
crop_img/software_design_cheatsheet_224_crop_16.jpg	Concrete Notifiers inherited from Base Decorator
crop_img/software_design_cheatsheet_224_crop_17.jpg	Why avoid an existing open
crop_img/software_design_cheatsheet_224_crop_18.jpg	lnin
crop_img/software_design_cheatsheet_224_crop_19.jpg	'
crop_img/software_design_cheatsheet_224_crop_20.jpg	Client
crop_img/software_design_cheatsheet_224_crop_21.jpg	interface
crop_img/software_design_cheatsheet_224_crop_22.jpg	DataSource
crop_img/software_design_cheatsheet_224_crop_23.jpg	+writeData(data)
crop_img/software_design_cheatsheet_224_crop_24.jpg	+readData()
crop_img/software_design_cheatsheet_224_crop_25.jpg	4
crop_img/software_design_cheatsheet_224_crop_26.jpg	FileDataSource
crop_img/software_design_cheatsheet_224_crop_27.jpg	DataSourceDecorator
crop_img/software_design_cheatsheet_224_crop_28.jpg	-filename
crop_img/software_design_cheatsheet_224_crop_29.jpg	-wrappee: DataSource
crop_img/software_design_cheatsheet_224_crop_30.jpg	+FileDataSource(filename)
crop_img/software_design_cheatsheet_224_crop_31.jpg	+DataSourceDecorator(s:DataSource)
crop_img/software_design_cheatsheet_224_crop_32.jpg	+writeData(data)
crop_img/software_design_cheatsheet_224_crop_33.jpg	+writeData(data)
crop_img/software_design_cheatsheet_224_crop_34.jpg	readData()
crop_img/software_design_cheatsheet_224_crop_35.jpg	+readData()
crop_img/software_design_cheatsheet_224_crop_36.jpg	4
crop_img/software_design_cheatsheet_224_crop_37.jpg	Encryption
crop_img/software_design_cheatsheet_224_crop_38.jpg	Compression
crop_img/software_design_cheatsheet_224_crop_39.jpg	Decorator
crop_img/software_design_cheatsheet_224_crop_40.jpg	Decorator
crop_img/software_design_cheatsheet_224_crop_41.jpg	.
crop_img/software_design_cheatsheet_224_crop_42.jpg	writeData(data)
crop_img/software_design_cheatsheet_224_crop_43.jpg	+writeData(data)
crop_img/software_design_cheatsheet_224_crop_44.jpg	+readData()
crop_img/software_design_cheatsheet_224_crop_45.jpg	+readData()
crop_img/software_design_cheatsheet_225_crop_0.jpg	Software Anre ment & Testing:
crop_img/software_design_cheatsheet_225_crop_1.jpg	) Dynamic Verification: test sys until it fail (executing code in a
crop_img/software_design_cheatsheet_225_crop_2.jpg	runtime env), include various levels
crop_img/software_design_cheatsheet_225_crop_3.jpg	static verification: examining code wl out executing it. Use tool to
crop_img/software_design_cheatsheet_225_crop_4.jpg	analyze code, Can be performed very early on. Doesn't tag runtime env
crop_img/software_design_cheatsheet_225_crop_5.jpg	on compiled code
crop_img/software_design_cheatsheet_225_crop_6.jpg	) Inspection/review/walk through:
crop_img/software_design_cheatsheet_225_crop_7.jpg	Human activity) group-based + manual
crop_img/software_design_cheatsheet_225_crop_8.jpg	Inspection: formal checklist + moderation
crop_img/software_design_cheatsheet_225_crop_9.jpg	Review: less formal + peers
crop_img/software_design_cheatsheet_225_crop_10.jpg	Walk through:
crop_img/software_design_cheatsheet_225_crop_11.jpg	informal + author
crop_img/software_design_cheatsheet_225_crop_12.jpg	Formal verification: Math -exhaustive can be time-consuming + expensive
crop_img/software_design_cheatsheet_225_crop_13.jpg	outside orga
crop_img/software_design_cheatsheet_225_crop_14.jpg	outside orga
crop_img/software_design_cheatsheet_225_crop_15.jpg	within orga
crop_img/software_design_cheatsheet_225_crop_16.jpg	within orga
crop_img/software_design_cheatsheet_225_crop_17.jpg	) Testing stages:
crop_img/software_design_cheatsheet_225_crop_18.jpg	Dev Test α Test β Test Product Release
crop_img/software_design_cheatsheet_225_crop_19.jpg	(open box)
crop_img/software_design_cheatsheet_225_crop_20.jpg	(black box)
crop_img/software_design_cheatsheet_225_crop_21.jpg	) Testing technique
crop_img/software_design_cheatsheet_225_crop_22.jpg	opaque box Test
crop_img/software_design_cheatsheet_225_crop_23.jpg	Clear Box Test
crop_img/software_design_cheatsheet_225_crop_24.jpg	) Test Driven Development (TDD): Test written before code) and ~ do
crop_img/software_design_cheatsheet_225_crop_25.jpg	production code have test unit
crop_img/software_design_cheatsheet_225_crop_26.jpg	. Rule: make it fail
crop_img/software_design_cheatsheet_225_crop_27.jpg	make it work (as simply as possible)
crop_img/software_design_cheatsheet_225_crop_28.jpg	make it better (refactor)
crop_img/software_design_cheatsheet_225_crop_29.jpg	Run Test → New req → Write new test → Run Test
crop_img/software_design_cheatsheet_225_crop_30.jpg	) Test Cycle:
crop_img/software_design_cheatsheet_225_crop_31.jpg	write new
crop_img/software_design_cheatsheet_225_crop_32.jpg	refactor to run test
crop_img/software_design_cheatsheet_225_crop_33.jpg	code
crop_img/software_design_cheatsheet_225_crop_34.jpg	AT dev disciplines
crop_img/software_design_cheatsheet_225_crop_35.jpg	a provide increment al specification
crop_img/software_design_cheatsheet_225_crop_36.jpg	) Why TDD?
crop_img/software_design_cheatsheet_225_crop_37.jpg	④个 confidence while changing
crop_img/software_design_cheatsheet_225_crop_38.jpg	Avoid regression
crop_img/software_design_cheatsheet_225_crop_39.jpg	3
crop_img/software_design_cheatsheet_225_crop_40.jpg	e2ok
crop_img/software_design_principles_cheatsheet_172_crop_0.jpg	SOLID:
crop_img/software_design_principles_cheatsheet_172_crop_1.jpg	Design principle: guideline for designing software based on oo
crop_img/software_design_principles_cheatsheet_172_crop_2.jpg	.Aim: understand ability, extendability, maintenance
crop_img/software_design_principles_cheatsheet_172_crop_3.jpg	.Avoid: rigidity fragility immobility and viscosity
crop_img/software_design_principles_cheatsheet_172_crop_4.jpg	Single Responsibility (s): Each class only has 1 job
crop_img/software_design_principles_cheatsheet_172_crop_5.jpg	open/closed(o): open for extension, closed for modification
crop_img/software_design_principles_cheatsheet_172_crop_6.jpg	.Meaning we can add new functionality without altering old code
crop_img/software_design_principles_cheatsheet_172_crop_7.jpg	Liskov Substitution (l): object of a superclass can be replaced by its
crop_img/software_design_principles_cheatsheet_172_crop_8.jpg	subclass objects without damaging the program
crop_img/software_design_principles_cheatsheet_172_crop_9.jpg	Interface Seg (I): Don't force the clients to dep on things they don't use
crop_img/software_design_principles_cheatsheet_172_crop_10.jpg	,
crop_img/software_design_principles_cheatsheet_172_crop_11.jpg	Dependency Inv (D); High-level does doesn't depend on low-level one
crop_img/software_design_principles_cheatsheet_172_crop_12.jpg	GRASP: principles
crop_img/software_design_principles_cheatsheet_172_crop_13.jpg	focus on assigning responsibility to class and e in o
crop_img/software_design_principles_cheatsheet_172_crop_14.jpg	Creator (pattern): object created by the class that has the most info to create it
crop_img/software_design_principles_cheatsheet_172_crop_15.jpg	.When? aggregation or containment tracking close use initialization
crop_img/software_design_principles_cheatsheet_172_crop_16.jpg	80
crop_img/software_design_principles_cheatsheet_172_crop_17.jpg	data
crop_img/software_design_principles_cheatsheet_172_crop_18.jpg	Info Expert: assign resp to the class that has the essential info to create it
crop_img/software_design_principles_cheatsheet_172_crop_19.jpg	. Note: consider the type of resp and what info are needed
crop_img/software_design_principles_cheatsheet_172_crop_20.jpg	Low Coupling
crop_img/software_design_principles_cheatsheet_172_crop_21.jpg	: reduce dep between classes as much as possible
crop_img/software_design_principles_cheatsheet_172_crop_22.jpg	.How? use interfaces abstract classes, dep injection, composition inheritance,
crop_img/software_design_principles_cheatsheet_172_crop_23.jpg	behavior encapsulation avoid bi-directional relationship
crop_img/software_design_principles_cheatsheet_173_crop_0.jpg	High Cohesion: Similar to S in SOLID
crop_img/software_design_principles_cheatsheet_173_crop_1.jpg	,
crop_img/software_design_principles_cheatsheet_173_crop_2.jpg	Controller: Keep the UI separate from the Model
crop_img/software_design_principles_cheatsheet_173_crop_3.jpg	.How? When handling a sys event assign it to a non-UI class that
crop_img/software_design_principles_cheatsheet_173_crop_4.jpg	helps the whole sys /a use case scenario the sys respond
crop_img/software_design_principles_cheatsheet_173_crop_5.jpg	Polymorphism: Flexible and dynamic behavior in an application
crop_img/software_design_principles_cheatsheet_173_crop_6.jpg	.Eventual for low coupling
crop_img/software_design_principles_cheatsheet_173_crop_7.jpg	Pure Fabrication: assign resp to classes that don't represent a concept
crop_img/software_design_principles_cheatsheet_173_crop_8.jpg	.When? when we cannot find a sol within the problem domain
crop_img/software_design_principles_cheatsheet_173_crop_9.jpg	middle party
crop_img/software_design_principles_cheatsheet_173_crop_10.jpg	) Indirection: Insert an intermediate class or object to mediate between classes
crop_img/software_design_principles_cheatsheet_173_crop_11.jpg	.When? when coupling is high
crop_img/software_design_principles_cheatsheet_173_crop_12.jpg	.Similar to "Don't talk to strangers"
crop_img/software_design_principles_cheatsheet_173_crop_13.jpg	Protected Variation: Protecting elements from the change of others
crop_img/software_design_principles_cheatsheet_173_crop_14.jpg	.How? one element's change doesn't make others change
crop_img/software_design_principles_cheatsheet_173_crop_15.jpg	Refactoring: small inline technique to keep program readable, understandable,
crop_img/software_design_principles_cheatsheet_173_crop_16.jpg	maintain, improving design without changing functionality
crop_img/software_design_principles_cheatsheet_173_crop_17.jpg	. Key feature: ensure program works at every detailed step
crop_img/software_design_principles_cheatsheet_173_crop_18.jpg	why? Reg change, design improvements program work optimize
crop_img/software_design_principles_cheatsheet_173_crop_19.jpg	outcome: make program more flexible
crop_img/software_design_principles_cheatsheet_173_crop_20.jpg	Ex: renaming, collapse hierarchy, consolidate/ decompose cond&
crop_img/software_design_principles_cheatsheet_173_crop_21.jpg	(ex: merge)
crop_img/software_design_principles_cheatsheet_173_crop_22.jpg	(ex: combine conds that → same result
crop_img/software_design_principles_cheatsheet_173_crop_23.jpg	· replace complex conds by method)
crop_img/software_design_principles_cheatsheet_173_crop_24.jpg	extract class/ method
crop_img/software_design_principles_cheatsheet_173_crop_25.jpg	(ex:replace code fgmnt y method)
crop_img/software_design_principles_cheatsheet_173_crop_26.jpg	(ex:a class doing≥a work→ make a new class
crop_img/software_design_principles_cheatsheet_174_crop_0.jpg	When? When adding a new feature/review code/fixing
crop_img/software_design_principles_cheatsheet_174_crop_1.jpg	.When not? broken code / close deadline / no need to
crop_img/software_design_principles_cheatsheet_174_crop_2.jpg	code Smell: A surface indication that usually crops to a deeper prob in sys
crop_img/software_design_principles_cheatsheet_174_crop_3.jpg	.Usually found when refactoring /examining code
crop_img/software_design_principles_cheatsheet_174_crop_4.jpg	How come? rushed design/ technical debt (lazy lst→ more work
crop_img/software_design_principles_cheatsheet_174_crop_5.jpg	disregard
crop_img/software_design_principles_cheatsheet_174_crop_6.jpg	later)
crop_img/software_design_principles_cheatsheet_174_crop_7.jpg	Right way : use best practices + develop a design that can scale
crop_img/software_design_principles_cheatsheet_174_crop_8.jpg	“hacked together design) factor
crop_img/software_design_principles_cheatsheet_174_crop_9.jpg	Fast way:
crop_img/software_design_principles_cheatsheet_174_crop_10.jpg	Identical
crop_img/software_design_principles_cheatsheet_174_crop_11.jpg	group of var
crop_img/software_design_principles_cheatsheet_174_crop_12.jpg	Bloaters: Something T so large and out of control
crop_img/software_design_principles_cheatsheet_174_crop_13.jpg	(>10 lines)
crop_img/software_design_principles_cheatsheet_174_crop_14.jpg	sign: contain long duplicated code along data method data clump;
crop_img/software_design_principles_cheatsheet_174_crop_15.jpg	long para list
crop_img/software_design_principles_cheatsheet_174_crop_16.jpg	. How come?. devs
crop_img/software_design_principles_cheatsheet_174_crop_17.jpg	may be tempted to put new feature into an
crop_img/software_design_principles_cheatsheet_174_crop_18.jpg	existing class
crop_img/software_design_principles_cheatsheet_174_crop_19.jpg	that meant:
crop_img/software_design_principles_cheatsheet_174_crop_20.jpg	extract data/Mnb-class/method j +try deleting a num
crop_img/software_design_principles_cheatsheet_174_crop_21.jpg	to see if code still makes sense extra data backup algo)
crop_img/software_design_principles_cheatsheet_174_crop_22.jpg	wash method) pass the whole object or data (free serve whole
crop_img/software_design_principles_cheatsheet_174_crop_23.jpg	object)
crop_img/software_design_principles_cheatsheet_174_crop_24.jpg	. oo Abusers: so don't fully exploit oo design
crop_img/software_design_principles_cheatsheet_174_crop_25.jpg	.Sign: complex switch sequence of if; refused bequest
crop_img/software_design_principles_cheatsheet_174_crop_26.jpg	subclass ref used to use full parent ' methods)
crop_img/software_design_principles_cheatsheet_174_crop_27.jpg	.Why? For refused bequest, devs are tempted to use inheritance
crop_img/software_design_principles_cheatsheet_174_crop_28.jpg	to reusability
crop_img/software_design_principles_cheatsheet_174_crop_29.jpg	.Treatment: Extract method) polymorphism i push down method
crop_img/software_design_principles_cheatsheet_174_crop_30.jpg	use interface , eliminate inheritance
crop_img/software_design_principles_cheatsheet_175_crop_0.jpg	change Prevention: that hinders changing/upgrading
crop_img/software_design_principles_cheatsheet_175_crop_1.jpg	(Shotgun surgery)
crop_img/software_design_principles_cheatsheet_175_crop_2.jpg	.sign: make modifies regs make small changes to many other j
crop_img/software_design_principles_cheatsheet_175_crop_3.jpg	many changes made to only one class (divergent change)
crop_img/software_design_principles_cheatsheet_175_crop_4.jpg	. Why? For divergent change: poor structure /copy paste too much
crop_img/software_design_principles_cheatsheet_175_crop_5.jpg	.Treatment : Combine to a single class ; Extract class/method
crop_img/software_design_principles_cheatsheet_175_crop_6.jpg	Dispensable
crop_img/software_design_principles_cheatsheet_175_crop_7.jpg	:unnecessary things
crop_img/software_design_principles_cheatsheet_175_crop_8.jpg	• Sign: duplicated code ; lazy class j data clump
crop_img/software_design_principles_cheatsheet_175_crop_9.jpg	. Why For lazy class, a class may become very small after several
crop_img/software_design_principles_cheatsheet_175_crop_10.jpg	refactoring, or it's designed for future dev that is never done
crop_img/software_design_principles_cheatsheet_175_crop_11.jpg	. Treatment: Extract method; Inline class ; Move/Extract method,
crop_img/software_design_principles_cheatsheet_175_crop_12.jpg	encapsulation
crop_img/software_design_principles_cheatsheet_175_crop_13.jpg	Couplers : closely connected routines/ modules
crop_img/software_design_principles_cheatsheet_175_crop_14.jpg	(Feature envy)
crop_img/software_design_principles_cheatsheet_175_crop_15.jpg	.sign: a method looks more interested in a class than the one it's in
crop_img/software_design_principles_cheatsheet_175_crop_16.jpg	classes know too much about each other ; class only do one action and
crop_img/software_design_principles_cheatsheet_175_crop_17.jpg	1
crop_img/software_design_principles_cheatsheet_175_crop_18.jpg	)
crop_img/software_design_principles_cheatsheet_175_crop_19.jpg	delegate work to other classes
crop_img/software_design_principles_cheatsheet_175_crop_20.jpg	Inappropriate intimacy
crop_img/software_design_principles_cheatsheet_175_crop_21.jpg	middle
crop_img/software_design_principles_cheatsheet_175_crop_22.jpg	man
crop_img/software_design_principles_cheatsheet_175_crop_23.jpg	Why? For middle man, moving too much from a class resulting in
crop_img/software_design_principles_cheatsheet_175_crop_24.jpg	it can only delegate work
crop_img/software_design_principles_cheatsheet_175_crop_25.jpg	.Treatment : move method j move method/field change association
crop_img/software_design_principles_cheatsheet_175_crop_26.jpg	to once; inline class
crop_img/software_design_principles_cheatsheet_175_crop_27.jpg	Design pattern: typical solutions to common probs in software design
crop_img/software_design_principles_cheatsheet_175_crop_28.jpg	(like a blueprint if algo is like a recipe)
crop_img/software_design_principles_cheatsheet_176_crop_0.jpg	Category of Lat
crop_img/software_design_principles_cheatsheet_176_crop_1.jpg	Creational lat: try to create suitable objects flexibility and reuse
crop_img/software_design_principles_cheatsheet_176_crop_2.jpg	) Structural lat : explain how to assemble & larger structure
crop_img/software_design_principles_cheatsheet_176_crop_3.jpg	still flexible and
crop_img/software_design_principles_cheatsheet_176_crop_4.jpg	efficient)
crop_img/software_design_principles_cheatsheet_176_crop_5.jpg	Behavioral Lat: algorithms & assign of rest of objects
crop_img/software_design_principles_cheatsheet_176_crop_6.jpg	)
crop_img/software_design_principles_cheatsheet_176_crop_7.jpg	Singleton lat: Ensures there only one instance of a do ever exists
crop_img/software_design_principles_cheatsheet_176_crop_8.jpg	created and a! one global way to access it
crop_img/software_design_principles_cheatsheet_176_crop_9.jpg	.Components : private constructor, public static method private static instance
crop_img/software_design_principles_cheatsheet_176_crop_10.jpg	(to access)
crop_img/software_design_principles_cheatsheet_176_crop_11.jpg	(store one
crop_img/software_design_principles_cheatsheet_176_crop_12.jpg	variable
crop_img/software_design_principles_cheatsheet_176_crop_13.jpg	instance
crop_img/software_design_principles_cheatsheet_176_crop_14.jpg	only create an instance
crop_img/software_design_principles_cheatsheet_176_crop_15.jpg	is null
crop_img/software_design_principles_cheatsheet_176_crop_16.jpg	Strategy Lat:  Beh define a fam of algo by putting them in separate
crop_img/software_design_principles_cheatsheet_176_crop_17.jpg	classes and making their objects interchangeable
crop_img/software_design_principles_cheatsheet_176_crop_18.jpg	. To maintain & grow
crop_img/software_design_principles_cheatsheet_176_crop_19.jpg	Components: A strategy interface includes # concrete strategies
crop_img/software_design_principles_cheatsheet_176_crop_20.jpg	to use
crop_img/software_design_principles_cheatsheet_176_crop_21.jpg	Factory Method lat: Ensures using a factory method to create instances of
crop_img/software_design_principles_cheatsheet_176_crop_22.jpg	a class instead of directly create them
crop_img/software_design_principles_cheatsheet_176_crop_23.jpg	.Why? changing the type of object used can be challenging. We can
crop_img/software_design_principles_cheatsheet_176_crop_24.jpg	decouple instance creation using factory method
crop_img/software_design_principles_cheatsheet_176_crop_25.jpg	.Components: Interface Product includes # concrete products) a creator
crop_img/software_design_principles_cheatsheet_176_crop_26.jpg	class that is inherited by concrete creator class related to each concrete
crop_img/software_design_principles_cheatsheet_176_crop_27.jpg	product
crop_img/software_design_principles_cheatsheet_176_crop_28.jpg	Observer lat: Ensures, define a subscription mechanism to have multiple
crop_img/software_design_principles_cheatsheet_176_crop_29.jpg	events issued by the “publisher" and multiple "observer notified
crop_img/software_design_principles_cheatsheet_176_crop_30.jpg	.Why? Sometimes a change to y needed to be notified to all
crop_img/software_design_principles_cheatsheet_176_crop_31.jpg	other ways
crop_img/software_design_principles_cheatsheet_177_crop_0.jpg	Component: publisher class that holds a list of subscriptions) and
crop_img/software_design_principles_cheatsheet_177_crop_1.jpg	Concrete subscriber classes (implements the interface Subscriber)
crop_img/software_design_principles_cheatsheet_177_crop_2.jpg	Composite lat: Ensures all about creating tree-like structure of object.
crop_img/software_design_principles_cheatsheet_177_crop_3.jpg	Treat individual objects and compositions uniformly
crop_img/software_design_principles_cheatsheet_177_crop_4.jpg	Component's: delegate
crop_img/software_design_principles_cheatsheet_177_crop_5.jpg	Leaf: do all the work
crop_img/software_design_principles_cheatsheet_177_crop_6.jpg	Visitor lat: E Beh, helps add operations to objects without altering
crop_img/software_design_principles_cheatsheet_177_crop_7.jpg	those objects themselves (use an external class for this)
crop_img/software_design_principles_cheatsheet_177_crop_8.jpg	• Component: Interface visitor, concrete visitor classes implement visitor
crop_img/software_design_principles_cheatsheet_177_crop_9.jpg	Concrete element bound to each visitor class implements interface Element
crop_img/software_design_principles_cheatsheet_177_crop_10.jpg	Decorator lat: E struct, helps add features or behaviors to objects
crop_img/software_design_principles_cheatsheet_177_crop_11.jpg	without changing the object's original class
crop_img/software_design_principles_cheatsheet_177_crop_12.jpg	• Components: a Notifier class
crop_img/software_design_principles_cheatsheet_177_crop_13.jpg	base Decorator (where we will add features)
crop_img/software_design_principles_cheatsheet_177_crop_14.jpg	Concrete Notifiers inherited from Base Decorator
crop_img/software_design_principles_cheatsheet_177_crop_15.jpg	Wrong
crop_img/software_design_principles_cheatsheet_177_crop_16.jpg	Init
crop_img/software_design_principles_cheatsheet_177_crop_17.jpg	Client
crop_img/software_design_principles_cheatsheet_177_crop_18.jpg	interface
crop_img/software_design_principles_cheatsheet_177_crop_19.jpg	DataSource
crop_img/software_design_principles_cheatsheet_177_crop_20.jpg	+writeData(data)
crop_img/software_design_principles_cheatsheet_177_crop_21.jpg	+readData()
crop_img/software_design_principles_cheatsheet_177_crop_22.jpg	4
crop_img/software_design_principles_cheatsheet_177_crop_23.jpg	FileDataSource
crop_img/software_design_principles_cheatsheet_177_crop_24.jpg	DataSourceDecorator
crop_img/software_design_principles_cheatsheet_177_crop_25.jpg	-filename
crop_img/software_design_principles_cheatsheet_177_crop_26.jpg	-wrappee: DataSource
crop_img/software_design_principles_cheatsheet_177_crop_27.jpg	+FileDataSource(filename)
crop_img/software_design_principles_cheatsheet_177_crop_28.jpg	DataSourceDecorator(s:DataSource)
crop_img/software_design_principles_cheatsheet_177_crop_29.jpg	+writeData(data)
crop_img/software_design_principles_cheatsheet_177_crop_30.jpg	+writeData(data)
crop_img/software_design_principles_cheatsheet_177_crop_31.jpg	+readData()
crop_img/software_design_principles_cheatsheet_177_crop_32.jpg	+readData()
crop_img/software_design_principles_cheatsheet_177_crop_33.jpg	4
crop_img/software_design_principles_cheatsheet_177_crop_34.jpg	Encryption
crop_img/software_design_principles_cheatsheet_177_crop_35.jpg	Compression
crop_img/software_design_principles_cheatsheet_177_crop_36.jpg	Decorator
crop_img/software_design_principles_cheatsheet_177_crop_37.jpg	Decorator
crop_img/software_design_principles_cheatsheet_177_crop_38.jpg	+writeData(data)
crop_img/software_design_principles_cheatsheet_177_crop_39.jpg	+writeData(data)
crop_img/software_design_principles_cheatsheet_177_crop_40.jpg	+readData()
crop_img/software_design_principles_cheatsheet_177_crop_41.jpg	+readData()
crop_img/software_design_principles_cheatsheet_178_crop_0.jpg	Software Agreement & Testing:
crop_img/software_design_principles_cheatsheet_178_crop_1.jpg	) Dynamic Verification: test system until it fails (executing code in a
crop_img/software_design_principles_cheatsheet_178_crop_2.jpg	runtime env), include various levels
crop_img/software_design_principles_cheatsheet_178_crop_3.jpg	static verification: examining code without executing it. Use tools to
crop_img/software_design_principles_cheatsheet_178_crop_4.jpg	analyze code, can be performed very early on. Don't at runtime on
crop_img/software_design_principles_cheatsheet_178_crop_5.jpg	on compiled code
crop_img/software_design_principles_cheatsheet_178_crop_6.jpg	Inspection/review/Walkthrough: Human activity group-based + manual
crop_img/software_design_principles_cheatsheet_178_crop_7.jpg	Inspection: formal checklist + moderation
crop_img/software_design_principles_cheatsheet_178_crop_8.jpg	Review: less formal + peers
crop_img/software_design_principles_cheatsheet_178_crop_9.jpg	Walkthrough:
crop_img/software_design_principles_cheatsheet_178_crop_10.jpg	informal + author
crop_img/software_design_principles_cheatsheet_178_crop_11.jpg	A
crop_img/software_design_principles_cheatsheet_178_crop_12.jpg	) Formal verification: Math - exhaustive can be time-consuming + expensive
crop_img/software_design_principles_cheatsheet_178_crop_13.jpg	outside org
crop_img/software_design_principles_cheatsheet_178_crop_14.jpg	outside org
crop_img/software_design_principles_cheatsheet_178_crop_15.jpg	within org
crop_img/software_design_principles_cheatsheet_178_crop_16.jpg	within org
crop_img/software_design_principles_cheatsheet_178_crop_17.jpg	) Testing stages:
crop_img/software_design_principles_cheatsheet_178_crop_18.jpg	Dev Test α Test β Test Product Release
crop_img/software_design_principles_cheatsheet_178_crop_19.jpg	(open box)
crop_img/software_design_principles_cheatsheet_178_crop_20.jpg	(black box)
crop_img/software_design_principles_cheatsheet_178_crop_21.jpg	Testing technique: opaque box Test
crop_img/software_design_principles_cheatsheet_178_crop_22.jpg	Clear Box Test
crop_img/software_design_principles_cheatsheet_178_crop_23.jpg	) Test Driven Development (TDD): Test written before code and ~ all
crop_img/software_design_principles_cheatsheet_178_crop_24.jpg	production code have test unit
crop_img/software_design_principles_cheatsheet_178_crop_25.jpg	Rule:
crop_img/software_design_principles_cheatsheet_178_crop_26.jpg	make it fail
crop_img/software_design_principles_cheatsheet_178_crop_27.jpg	make it work (as simply as possible)
crop_img/software_design_principles_cheatsheet_178_crop_28.jpg	make it better (refactor)
crop_img/software_design_principles_cheatsheet_178_crop_29.jpg	Run Test → New test → Write new test → Run test
crop_img/software_design_principles_cheatsheet_178_crop_30.jpg	Test Cycle:
crop_img/software_design_principles_cheatsheet_178_crop_31.jpg	write new
crop_img/software_design_principles_cheatsheet_178_crop_32.jpg	refactor then test
crop_img/software_design_principles_cheatsheet_178_crop_33.jpg	code
crop_img/software_design_principles_cheatsheet_178_crop_34.jpg	Test dev disciplines
crop_img/software_design_principles_cheatsheet_178_crop_35.jpg	and provide incremental specification
crop_img/software_design_principles_cheatsheet_178_crop_36.jpg	) Why TDD?
crop_img/software_design_principles_cheatsheet_178_crop_37.jpg	④ confidence while changing
crop_img/software_design_principles_cheatsheet_178_crop_38.jpg	3
crop_img/software_design_principles_cheatsheet_178_crop_39.jpg	Avoid regression
crop_img/software_design_principles_cheatsheet_178_crop_40.jpg	erLon
crop_img/to_do_note_2_crop_0.jpg	About Login
crop_img/to_do_note_2_crop_1.jpg	1
crop_img/to_do_note_2_crop_2.jpg	Contact page
crop_img/to_do_note_2_crop_3.jpg	2
crop_img/to_do_note_2_crop_4.jpg	3
crop_img/to_do_note_2_crop_5.jpg	Cancel logout Redirect
crop_img/to_do_note_2_crop_6.jpg	By Sunday 20104
crop_img/user_stories_user_cases_26_crop_0.jpg	USER STORIES & USER CASES
crop_img/user_stories_user_cases_26_crop_1.jpg	) Use cases: How system will interact with end-user used to doc functional reqs
crop_img/user_stories_user_cases_26_crop_2.jpg	. 3 levels: brief, casual, fully-dressed
crop_img/user_stories_user_cases_26_crop_3.jpg	. structure: Actor/user (SUD) Goal, Preconditions, main success scenario
crop_img/user_stories_user_cases_26_crop_4.jpg	alternate scenario post condition (fully-dressed include all)
crop_img/user_stories_user_cases_26_crop_5.jpg	) User stories: simple informal way to describe user needs
crop_img/user_stories_user_cases_26_crop_6.jpg	.Structure: As a [role], I want [feature], so that [benefit]
crop_img/user_stories_user_cases_26_crop_7.jpg	. Accept Criteria: describe initial state what happens in the system when user
crop_img/user_stories_user_cases_26_crop_8.jpg	interacts result
crop_img/user_stories_user_cases_26_crop_9.jpg	(Given...→ And….→when.….→ then.…→And.)
crop_img/user_stories_user_cases_26_crop_10.jpg	SOFTWARE ARCHITECTURE
crop_img/user_stories_user_cases_26_crop_11.jpg	pf: Fundamental org of a system the components their relationships,
crop_img/user_stories_user_cases_26_crop_12.jpg	principles governing its design)
crop_img/user_stories_user_cases_26_crop_13.jpg	. Decided by early and hard-to-change decisions
crop_img/user_stories_user_cases_26_crop_14.jpg	design: org of modules, easy-to-change
crop_img/user_stories_user_cases_26_crop_15.jpg	communicate with all
crop_img/user_stories_user_cases_26_crop_16.jpg	cen
crop_img/user_stories_user_cases_26_crop_17.jpg	个
crop_img/user_stories_user_cases_26_crop_18.jpg	skate holders
crop_img/user_stories_user_cases_26_crop_19.jpg	) Software Architect: great comm shils, use effective mechanisms to repre software
crop_img/user_stories_user_cases_26_crop_20.jpg	logical
crop_img/user_stories_user_cases_26_crop_21.jpg	dev
crop_img/user_stories_user_cases_26_crop_22.jpg	Scenarios
crop_img/user_stories_user_cases_26_crop_23.jpg	4t1 view model : describing the arch of a sys wing process
crop_img/user_stories_user_cases_26_crop_24.jpg	physical
crop_img/user_stories_user_cases_26_crop_25.jpg	views
crop_img/user_stories_user_cases_26_crop_26.jpg	) client-Server : services crpd to servers, clientx access services via a network
crop_img/user_stories_user_cases_26_crop_27.jpg	2-tier arch style (client & server on a diff hardware)
crop_img/user_stories_user_cases_26_crop_28.jpg	 N-tier :>α-t0
crop_img/user_stories_user_cases_26_crop_29.jpg	 Peer-to-Peer: No distinction betwn client & server, computations
crop_img/user_stories_user_cases_26_crop_30.jpg	can be carried by any node in the network
crop_img/user_stories_user_cases_26_crop_31.jpg	.fo : fault + disconnection node tolerance
crop_img/user_stories_user_cases_26_crop_32.jpg	.lonely · malicious node (not fe)
crop_img/user_stories_user_cases_26_crop_33.jpg	Blackboard : each specialist knowledge source contribute a partial solution
crop_img/user_stories_user_cases_26_crop_34.jpg	.Components: blackboard, knowledge source control component
crop_img/user_stories_user_cases_26_crop_35.jpg	contain solution objects
crop_img/user_stories_user_cases_26_crop_36.jpg	select & execute knowledge source
crop_img/user_stories_user_cases_26_crop_37.jpg	) Layered:
crop_img/user_stories_user_cases_26_crop_38.jpg	layers w/related functions, ensure each layer depends on one beneath it
crop_img/user_stories_user_cases_26_crop_39.jpg	and is independent on top of it
crop_img/user_stories_user_cases_26_crop_40.jpg	.faoN ; isolation Reusability, separation of concerns
crop_img/user_stories_user_cases_26_crop_41.jpg	. Cons : redundant ) rigid, complex
crop_img/user_stories_user_cases_27_crop_0.jpg	Like
crop_img/user_stories_user_cases_27_crop_1.jpg	Filter →.Data Sink
crop_img/user_stories_user_cases_27_crop_2.jpg	) Pipe and Filter : Data Source
crop_img/user_stories_user_cases_27_crop_3.jpg	→
crop_img/user_stories_user_cases_27_crop_4.jpg	Piping: give the output of one command as input to subsequent command
crop_img/user_stories_user_cases_27_crop_5.jpg	) Event Driven : a component can announce events, other listen and do work
crop_img/user_stories_user_cases_27_crop_6.jpg	) Model-view-Controller: arch pattern follow layered approach
crop_img/user_stories_user_cases_27_crop_7.jpg	Controller: model update based on user actions
crop_img/user_stories_user_cases_27_crop_8.jpg	. view : render model, send user event to controller
crop_img/user_stories_user_cases_27_crop_9.jpg	Model : capture model updates, notifier changes → view
crop_img/user_stories_user_cases_27_crop_10.jpg	 Model-view-View Model: .model and view not connected
crop_img/user_stories_user_cases_27_crop_11.jpg	send request
crop_img/user_stories_user_cases_27_crop_12.jpg	VI Action
crop_img/user_stories_user_cases_27_crop_13.jpg	View
crop_img/user_stories_user_cases_27_crop_14.jpg	Model Data source
crop_img/user_stories_user_cases_27_crop_15.jpg	→
crop_img/user_stories_user_cases_27_crop_16.jpg	View Model
crop_img/user_stories_user_cases_27_crop_17.jpg	Observe
crop_img/user_stories_user_cases_27_crop_18.jpg	data change
crop_img/user_stories_user_cases_27_crop_19.jpg	response
crop_img/user_stories_user_cases_27_crop_20.jpg	 object Oriented Analysis : E RE phase
crop_img/user_stories_user_cases_27_crop_21.jpg	not software objects
crop_img/user_stories_user_cases_27_crop_22.jpg	Gather req: Domain Model (initialization of real-situation object)
crop_img/user_stories_user_cases_27_crop_23.jpg	 Domain Model in a UML
crop_img/user_stories_user_cases_27_crop_24.jpg	obtained from RE analysis
crop_img/user_stories_user_cases_27_crop_25.jpg	. Relationship :Ex:x
crop_img/user_stories_user_cases_27_crop_26.jpg	store
crop_img/user_stories_user_cases_27_crop_27.jpg	Y
crop_img/user_stories_user_cases_27_crop_28.jpg	) System Sequence Diagram : show how actors and system interact, capture
crop_img/user_stories_user_cases_27_crop_29.jpg	only one use case. Interactions go from top to down over time in cases
crop_img/user_stories_user_cases_27_crop_30.jpg	.Glossary : give more details about new terms in sso
crop_img/user_stories_user_cases_27_crop_31.jpg	.Follow DRY agile principle . Fragment : Loop) Alt, Opt, Ref
crop_img/user_stories_user_cases_27_crop_32.jpg	) Sequence Diagram: models a single scenario, no longer a black box
crop_img/user_stories_user_cases_27_crop_33.jpg	.Object life line : u--"
crop_img/user_stories_user_cases_27_crop_34.jpg	Activation bar: a rectangle bar represents active
crop_img/user_stories_user_cases_27_crop_35.jpg	• message→ : wait for receiver
crop_img/user_stories_user_cases_27_crop_36.jpg	message→: don't wait for receiver
crop_img/user_stories_user_cases_27_crop_37.jpg	) Design Class Diagram : models software classes and object + relationships
crop_img/user_stories_user_cases_27_crop_38.jpg	visibility: public (+) protected (#), private (), divided)
crop_img/user_stories_user_cases_27_crop_39.jpg	methods : vis + name (para): return-type
crop_img/user_stories_user_cases_27_crop_40.jpg	.D inheritance
crop_img/user_stories_user_cases_27_crop_41.jpg	------: interface implementation
crop_img/user_stories_user_cases_27_crop_42.jpg	on>:× related to y | ----→:× use x y as para
crop_img/user_stories_user_cases_27_crop_43.jpg	—: whole & part separable
crop_img/user_stories_user_cases_27_crop_44.jpg	: whole & part inseparable
crop_img/user_stories_user_cases_27_crop_45.jpg	0
crop_img/user_stories_user_cases_27_crop_46.jpg	Attribute Text vs Association Line